{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _isEqual from \"lodash/isEqual\";var _jsxFileName = \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useEffect, useMemo, useState, useRef, useCallback } from 'react';\nimport { styled, t } from '@superset-ui/core';\nimport AntdSelect from 'antd/lib/select';\nimport { DownOutlined, SearchOutlined } from '@ant-design/icons';\nimport debounce from 'lodash/debounce';\n\nimport { Spin } from 'antd';\nimport Icons from 'src/components/Icons';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport { hasOption } from './utils';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst { Option } = AntdSelect;\nconst StyledContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n`;\nconst StyledSelect = styled(AntdSelect)`\n  ${({ theme }) => `\n    && .ant-select-selector {\n      border-radius: ${theme.gridUnit}px;\n    }\n\n    // Open the dropdown when clicking on the suffix\n    // This is fixed in version 4.16\n    .ant-select-arrow .anticon:not(.ant-select-suffix) {\n      pointer-events: none;\n    }\n  `}\n`;\nconst StyledStopOutlined = styled(Icons.StopOutlined)`\n  vertical-align: 0;\n`;\nconst StyledCheckOutlined = styled(Icons.CheckOutlined)`\n  vertical-align: 0;\n`;\nconst StyledError = styled.div`\n  ${({ theme }) => `\n    display: flex;\n    justify-content: center;\n    align-items: flex-start;\n    width: 100%;\n    padding: ${theme.gridUnit * 2}px;\n    color: ${theme.colors.error.base};\n\n    & svg {\n      margin-right: ${theme.gridUnit * 2}px;\n    }\n  `}\n`;\nconst StyledErrorMessage = styled.div`\n  overflow: hidden;\n  text-overflow: ellipsis;\n`;\nconst StyledSpin = styled(Spin)`\n  margin-top: ${({ theme }) => -theme.gridUnit}px;\n`;\nconst StyledLoadingText = styled.div`\n  ${({ theme }) => `\n    margin-left: ${theme.gridUnit * 3}px;\n    line-height: ${theme.gridUnit * 8}px;\n    color: ${theme.colors.grayscale.light1};\n  `}\n`;\nconst MAX_TAG_COUNT = 4;\nconst TOKEN_SEPARATORS = [',', '\\n', '\\t', ';'];\nconst DEBOUNCE_TIMEOUT = 500;\nconst DEFAULT_PAGE_SIZE = 100;\nconst EMPTY_OPTIONS = [];\nconst Error = ({ error }) => ___EmotionJSX(StyledError, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 87, columnNumber: 31 } },\n___EmotionJSX(Icons.ErrorSolid, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 88, columnNumber: 5 } }), \" \", ___EmotionJSX(StyledErrorMessage, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 88, columnNumber: 26 } }, error));\n\nconst Select = ({ allowNewOptions = false, ariaLabel, fetchOnlyOnSearch, filterOption = true, header = null, invertSelection = false, labelInValue = false, lazyLoading = true, loading, mode = 'single', name, notFoundContent, onError, onChange, onClear, optionFilterProps = ['label', 'value'], options, pageSize = DEFAULT_PAGE_SIZE, placeholder = t('Select ...'), showSearch = true, value, ...props }) => {\n  const isAsync = typeof options === 'function';\n  const isSingleMode = mode === 'single';\n  const shouldShowSearch = isAsync || allowNewOptions ? true : showSearch;\n  const initialOptions = options && Array.isArray(options) ? options : EMPTY_OPTIONS;\n  const [selectOptions, setSelectOptions] = useState(initialOptions);\n  const shouldUseChildrenOptions = !!selectOptions.find((opt) => opt == null ? void 0 : opt.customLabel);\n  const [selectValue, setSelectValue] = useState(value);\n  const [searchedValue, setSearchedValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [isTyping, setIsTyping] = useState(false);\n  const [error, setError] = useState('');\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [page, setPage] = useState(0);\n  const [totalCount, setTotalCount] = useState(0);\n  const [loadingEnabled, setLoadingEnabled] = useState(!lazyLoading);\n  const [allValuesLoaded, setAllValuesLoaded] = useState(false);\n  const fetchedQueries = useRef(new Map());\n  const mappedMode = isSingleMode ?\n  undefined :\n  allowNewOptions ?\n  'tags' :\n  'multiple';\n  // TODO: Don't assume that isAsync is always labelInValue\n  const handleTopOptions = useCallback((selectedValue) => {\n    // bringing selected options to the top of the list\n    if (selectedValue !== undefined && selectedValue !== null) {\n      const isLabeledValue = isAsync || labelInValue;\n      const topOptions = [];\n      const otherOptions = [];\n      selectOptions.forEach((opt) => {\n        let found = false;\n        if (Array.isArray(selectedValue)) {\n          if (isLabeledValue) {\n            found =\n            selectedValue.find((element) => element.value === opt.value) !== undefined;\n          } else\n          {\n            found = selectedValue.includes(opt.value);\n          }\n        } else\n        {\n          found = isLabeledValue ?\n          selectedValue.value === opt.value :\n          selectedValue === opt.value;\n        }\n        if (found) {\n          topOptions.push(opt);\n        } else\n        {\n          otherOptions.push(opt);\n        }\n      });\n      // fallback for custom options in tags mode as they\n      // do not appear in the selectOptions state\n      if (!isSingleMode && Array.isArray(selectedValue)) {\n        selectedValue.forEach((val) => {\n          if (!topOptions.find((tOpt) => tOpt.value === (\n          isLabeledValue ? val == null ? void 0 : val.value : val))) {\n            if (isLabeledValue) {\n              const labelValue = val;\n              topOptions.push({\n                label: labelValue.label,\n                value: labelValue.value });\n\n            } else\n            {\n              const value = val;\n              topOptions.push({ label: String(value), value });\n            }\n          }\n        });\n      }\n      const sortedOptions = [...topOptions, ...otherOptions];\n      if (!_isEqual(sortedOptions, selectOptions)) {\n        setSelectOptions(sortedOptions);\n      }\n    }\n  }, [isAsync, isSingleMode, labelInValue, selectOptions]);\n  const handleOnSelect = (selectedValue) => {\n    if (isSingleMode) {\n      setSelectValue(selectedValue);\n    } else\n    {\n      const currentSelected = selectValue ?\n      Array.isArray(selectValue) ?\n      selectValue :\n      [selectValue] :\n      [];\n      if (typeof selectedValue === 'number' ||\n      typeof selectedValue === 'string') {\n        setSelectValue([\n        ...currentSelected,\n        selectedValue]);\n\n      } else\n      {\n        setSelectValue([\n        ...currentSelected,\n        selectedValue]);\n\n      }\n    }\n    setSearchedValue('');\n  };\n  const handleOnDeselect = (value) => {\n    if (Array.isArray(selectValue)) {\n      if (typeof value === 'number' || typeof value === 'string') {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element !== value));\n      } else\n      {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element.value !== value.value));\n      }\n    }\n    setSearchedValue('');\n  };\n  const internalOnError = useCallback((response) => getClientErrorObject(response).then((e) => {\n    const { error } = e;\n    setError(error);\n    if (onError) {\n      onError(error);\n    }\n  }), [onError]);\n  const handleData = (data) => {\n    let mergedData = [];\n    if (data && Array.isArray(data) && data.length) {\n      const dataValues = new Set();\n      data.forEach((option) => dataValues.add(String(option.value).toLocaleLowerCase()));\n      // merges with existing and creates unique options\n      setSelectOptions((prevOptions) => {\n        mergedData = [\n        ...prevOptions.filter((previousOption) => !dataValues.has(String(previousOption.value).toLocaleLowerCase())),\n        ...data];\n\n        return mergedData;\n      });\n    }\n    return mergedData;\n  };\n  const handlePaginatedFetch = useMemo(() => (value, page, pageSize) => {\n    if (allValuesLoaded) {\n      setIsLoading(false);\n      setIsTyping(false);\n      return;\n    }\n    const key = `${value};${page};${pageSize}`;\n    const cachedCount = fetchedQueries.current.get(key);\n    if (cachedCount) {\n      setTotalCount(cachedCount);\n      setIsLoading(false);\n      setIsTyping(false);\n      return;\n    }\n    setIsLoading(true);\n    const fetchOptions = options;\n    fetchOptions(value, page, pageSize).\n    then(({ data, totalCount }) => {\n      const mergedData = handleData(data);\n      fetchedQueries.current.set(key, totalCount);\n      setTotalCount(totalCount);\n      if (!fetchOnlyOnSearch &&\n      value === '' &&\n      mergedData.length >= totalCount) {\n        setAllValuesLoaded(true);\n      }\n    }).\n    catch(internalOnError).\n    finally(() => {\n      setIsLoading(false);\n      setIsTyping(false);\n    });\n  }, [allValuesLoaded, fetchOnlyOnSearch, internalOnError, options]);\n  const handleOnSearch = useMemo(() => debounce((search) => {\n    const searchValue = search.trim();\n    if (allowNewOptions && isSingleMode) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, selectOptions) && {\n        label: searchValue,\n        value: searchValue };\n\n      const newOptions = newOption ?\n      [\n      newOption,\n      ...selectOptions.filter((opt) => opt.value !== searchedValue)] :\n\n      [...selectOptions.filter((opt) => opt.value !== searchedValue)];\n      setSelectOptions(newOptions);\n    }\n    if (!searchValue || searchValue === searchedValue) {\n      setIsTyping(false);\n    }\n    setSearchedValue(searchValue);\n  }, DEBOUNCE_TIMEOUT), [allowNewOptions, isSingleMode, searchedValue, selectOptions]);\n  const handlePagination = (e) => {\n    const vScroll = e.currentTarget;\n    const thresholdReached = vScroll.scrollTop > (vScroll.scrollHeight - vScroll.offsetHeight) * 0.7;\n    const hasMoreData = page * pageSize + pageSize < totalCount;\n    if (!isLoading && isAsync && hasMoreData && thresholdReached) {\n      const newPage = page + 1;\n      handlePaginatedFetch(searchedValue, newPage, pageSize);\n      setPage(newPage);\n    }\n  };\n  const handleFilterOption = (search, option) => {\n    if (typeof filterOption === 'function') {\n      return filterOption(search, option);\n    }\n    if (filterOption) {\n      const searchValue = search.trim().toLowerCase();\n      if (optionFilterProps && optionFilterProps.length) {\n        return optionFilterProps.some((prop) => {\n          const optionProp = option != null && option[prop] ?\n          String(option[prop]).trim().toLowerCase() :\n          '';\n          return optionProp.includes(searchValue);\n        });\n      }\n    }\n    return false;\n  };\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    if (isAsync && !loadingEnabled) {\n      setLoadingEnabled(true);\n    }\n    // multiple or tags mode keep the dropdown visible while selecting options\n    // this waits for the dropdown to be closed before sorting the top options\n    if (!isSingleMode && !isDropdownVisible) {\n      handleTopOptions(selectValue);\n    }\n  };\n  const dropdownRender = (originNode) => {\n    if (!isDropdownVisible) {var _originNode$ref, _originNode$ref$curre;\n      (_originNode$ref = originNode.ref) == null ? void 0 : (_originNode$ref$curre = _originNode$ref.current) == null ? void 0 : _originNode$ref$curre.scrollTo({ top: 0 });\n    }\n    if (isLoading && selectOptions.length === 0 || isTyping) {\n      return ___EmotionJSX(StyledLoadingText, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 328, columnNumber: 20 } }, t('Loading...'));\n    }\n    return error ? ___EmotionJSX(Error, { error: error, __self: this, __source: { fileName: _jsxFileName, lineNumber: 330, columnNumber: 24 } }) : originNode;\n  };\n  const onInputKeyDown = (event) => {\n    if (event.key.length === 1 && isAsync && !isTyping) {\n      setIsTyping(true);\n    }\n  };\n  const SuffixIcon = () => {\n    if (isLoading) {\n      return ___EmotionJSX(StyledSpin, { size: \"small\", __self: this, __source: { fileName: _jsxFileName, lineNumber: 339, columnNumber: 20 } });\n    }\n    if (shouldShowSearch && isDropdownVisible) {\n      return ___EmotionJSX(SearchOutlined, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 342, columnNumber: 20 } });\n    }\n    return ___EmotionJSX(DownOutlined, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 344, columnNumber: 16 } });\n  };\n  const handleClear = () => {\n    setSelectValue(undefined);\n    if (onClear) {\n      onClear();\n    }\n  };\n  useEffect(() => {\n    fetchedQueries.current.clear();\n    setSelectOptions(options && Array.isArray(options) ? options : EMPTY_OPTIONS);\n    setAllValuesLoaded(false);\n  }, [options]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  useEffect(() => {\n    if (selectValue) {\n      const array = Array.isArray(selectValue) ?\n      selectValue :\n      [selectValue];\n      const options = [];\n      const isLabeledValue = isAsync || labelInValue;\n      array.forEach((element) => {\n        const found = selectOptions.find((option) => isLabeledValue ?\n        option.value === element.value :\n        option.value === element);\n        if (!found) {\n          options.push(isLabeledValue ?\n          element :\n          { value: element, label: element });\n        }\n      });\n      if (options.length > 0) {\n        setSelectOptions([...options, ...selectOptions]);\n      }\n    }\n  }, [labelInValue, isAsync, selectOptions, selectValue]);\n  // Stop the invocation of the debounced function after unmounting\n  useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n  useEffect(() => {\n    const allowFetch = !fetchOnlyOnSearch || searchedValue;\n    if (isAsync && loadingEnabled && allowFetch) {\n      const page = 0;\n      handlePaginatedFetch(searchedValue, page, pageSize);\n      setPage(page);\n    }\n  }, [\n  isAsync,\n  searchedValue,\n  pageSize,\n  handlePaginatedFetch,\n  loadingEnabled,\n  fetchOnlyOnSearch]);\n\n  useEffect(() => {\n    if (isSingleMode) {\n      handleTopOptions(selectValue);\n    }\n  }, [handleTopOptions, isSingleMode, selectValue]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  return ___EmotionJSX(StyledContainer, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 409, columnNumber: 13 } },\n  header,\n  ___EmotionJSX(StyledSelect, _extends({ \"aria-label\": ariaLabel || name, dropdownRender: dropdownRender, filterOption: handleFilterOption, getPopupContainer: (triggerNode) => triggerNode.parentNode, labelInValue: isAsync || labelInValue, maxTagCount: MAX_TAG_COUNT, mode: mappedMode, notFoundContent: allowNewOptions && !fetchOnlyOnSearch ? ___EmotionJSX(StyledLoadingText, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 411, columnNumber: 319 } }, t('Loading...')) : notFoundContent, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange, onInputKeyDown: onInputKeyDown, onPopupScroll: isAsync ? handlePagination : undefined, onSearch: shouldShowSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, onChange: onChange, options: shouldUseChildrenOptions ? undefined : selectOptions, placeholder: placeholder, showSearch: shouldShowSearch, showArrow: true, tokenSeparators: TOKEN_SEPARATORS, value: selectValue, suffixIcon: ___EmotionJSX(SuffixIcon, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 411, columnNumber: 892 } }), menuItemSelectedIcon: invertSelection ? ___EmotionJSX(StyledStopOutlined, { iconSize: \"m\", __self: this, __source: { fileName: _jsxFileName, lineNumber: 411, columnNumber: 949 } }) : ___EmotionJSX(StyledCheckOutlined, { iconSize: \"m\", __self: this, __source: { fileName: _jsxFileName, lineNumber: 411, columnNumber: 988 } }) }, props, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 411, columnNumber: 7 } }),\n  shouldUseChildrenOptions &&\n  selectOptions.map((opt) => {\n    const isOptObject = typeof opt === 'object';\n    const label = isOptObject ? (opt == null ? void 0 : opt.label) || opt.value : opt;\n    const value = isOptObject && opt.value || opt;\n    const { customLabel, ...optProps } = opt;\n    return ___EmotionJSX(Option, _extends({}, optProps, { key: value, label: label, value: value, __self: this, __source: { fileName: _jsxFileName, lineNumber: 418, columnNumber: 25 } }),\n    isOptObject && customLabel ? customLabel : label);\n\n  })));\n\n\n};__signature__(Select, \"useState{[selectOptions, setSelectOptions](initialOptions)}\\nuseState{[selectValue, setSelectValue](value)}\\nuseState{[searchedValue, setSearchedValue]('')}\\nuseState{[isLoading, setIsLoading](loading)}\\nuseState{[isTyping, setIsTyping](false)}\\nuseState{[error, setError]('')}\\nuseState{[isDropdownVisible, setIsDropdownVisible](false)}\\nuseState{[page, setPage](0)}\\nuseState{[totalCount, setTotalCount](0)}\\nuseState{[loadingEnabled, setLoadingEnabled](!lazyLoading)}\\nuseState{[allValuesLoaded, setAllValuesLoaded](false)}\\nuseRef{fetchedQueries}\\nuseCallback{handleTopOptions}\\nuseCallback{internalOnError}\\nuseMemo{handlePaginatedFetch}\\nuseMemo{handleOnSearch}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\");const _default =\nSelect;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Option, \"Option\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(StyledContainer, \"StyledContainer\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(StyledSelect, \"StyledSelect\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(StyledStopOutlined, \"StyledStopOutlined\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(StyledCheckOutlined, \"StyledCheckOutlined\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(StyledError, \"StyledError\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(StyledErrorMessage, \"StyledErrorMessage\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(StyledSpin, \"StyledSpin\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(StyledLoadingText, \"StyledLoadingText\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(MAX_TAG_COUNT, \"MAX_TAG_COUNT\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(TOKEN_SEPARATORS, \"TOKEN_SEPARATORS\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(DEBOUNCE_TIMEOUT, \"DEBOUNCE_TIMEOUT\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(DEFAULT_PAGE_SIZE, \"DEFAULT_PAGE_SIZE\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(EMPTY_OPTIONS, \"EMPTY_OPTIONS\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(Error, \"Error\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(Select, \"Select\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(_default, \"default\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/components/Select/Select.tsx"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, {\n  ReactElement,\n  ReactNode,\n  RefObject,\n  KeyboardEvent,\n  UIEvent,\n  useEffect,\n  useMemo,\n  useState,\n  useRef,\n  useCallback,\n} from 'react';\nimport { styled, t } from '@superset-ui/core';\nimport AntdSelect, {\n  SelectProps as AntdSelectProps,\n  SelectValue as AntdSelectValue,\n  LabeledValue as AntdLabeledValue,\n} from 'antd/lib/select';\nimport { DownOutlined, SearchOutlined } from '@ant-design/icons';\nimport debounce from 'lodash/debounce';\nimport { isEqual } from 'lodash';\nimport { Spin } from 'antd';\nimport Icons from 'src/components/Icons';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport { hasOption } from './utils';\n\nconst { Option } = AntdSelect;\n\ntype AntdSelectAllProps = AntdSelectProps<AntdSelectValue>;\n\ntype PickedSelectProps = Pick<\n  AntdSelectAllProps,\n  | 'allowClear'\n  | 'autoFocus'\n  | 'disabled'\n  | 'filterOption'\n  | 'labelInValue'\n  | 'loading'\n  | 'notFoundContent'\n  | 'onChange'\n  | 'onClear'\n  | 'onFocus'\n  | 'placeholder'\n  | 'showSearch'\n  | 'value'\n>;\n\ntype OptionsProps = Exclude<AntdSelectAllProps['options'], undefined>;\n\nexport interface OptionsType extends Omit<OptionsProps, 'label'> {\n  label?: string;\n  customLabel?: ReactNode;\n}\n\nexport type OptionsTypePage = {\n  data: OptionsType;\n  totalCount: number;\n};\n\nexport type OptionsPagePromise = (\n  search: string,\n  page: number,\n  pageSize: number,\n) => Promise<OptionsTypePage>;\n\nexport interface SelectProps extends PickedSelectProps {\n  allowNewOptions?: boolean;\n  ariaLabel: string;\n  header?: ReactNode;\n  lazyLoading?: boolean;\n  mode?: 'single' | 'multiple';\n  name?: string; // discourage usage\n  optionFilterProps?: string[];\n  options: OptionsType | OptionsPagePromise;\n  pageSize?: number;\n  invertSelection?: boolean;\n  fetchOnlyOnSearch?: boolean;\n  onError?: (error: string) => void;\n}\n\nconst StyledContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n`;\n\nconst StyledSelect = styled(AntdSelect)`\n  ${({ theme }) => `\n    && .ant-select-selector {\n      border-radius: ${theme.gridUnit}px;\n    }\n\n    // Open the dropdown when clicking on the suffix\n    // This is fixed in version 4.16\n    .ant-select-arrow .anticon:not(.ant-select-suffix) {\n      pointer-events: none;\n    }\n  `}\n`;\n\nconst StyledStopOutlined = styled(Icons.StopOutlined)`\n  vertical-align: 0;\n`;\n\nconst StyledCheckOutlined = styled(Icons.CheckOutlined)`\n  vertical-align: 0;\n`;\n\nconst StyledError = styled.div`\n  ${({ theme }) => `\n    display: flex;\n    justify-content: center;\n    align-items: flex-start;\n    width: 100%;\n    padding: ${theme.gridUnit * 2}px;\n    color: ${theme.colors.error.base};\n\n    & svg {\n      margin-right: ${theme.gridUnit * 2}px;\n    }\n  `}\n`;\n\nconst StyledErrorMessage = styled.div`\n  overflow: hidden;\n  text-overflow: ellipsis;\n`;\n\nconst StyledSpin = styled(Spin)`\n  margin-top: ${({ theme }) => -theme.gridUnit}px;\n`;\n\nconst StyledLoadingText = styled.div`\n  ${({ theme }) => `\n    margin-left: ${theme.gridUnit * 3}px;\n    line-height: ${theme.gridUnit * 8}px;\n    color: ${theme.colors.grayscale.light1};\n  `}\n`;\n\nconst MAX_TAG_COUNT = 4;\nconst TOKEN_SEPARATORS = [',', '\\n', '\\t', ';'];\nconst DEBOUNCE_TIMEOUT = 500;\nconst DEFAULT_PAGE_SIZE = 100;\nconst EMPTY_OPTIONS: OptionsType = [];\n\nconst Error = ({ error }: { error: string }) => (\n  <StyledError>\n    <Icons.ErrorSolid /> <StyledErrorMessage>{error}</StyledErrorMessage>\n  </StyledError>\n);\n\nconst Select = ({\n  allowNewOptions = false,\n  ariaLabel,\n  fetchOnlyOnSearch,\n  filterOption = true,\n  header = null,\n  invertSelection = false,\n  labelInValue = false,\n  lazyLoading = true,\n  loading,\n  mode = 'single',\n  name,\n  notFoundContent,\n  onError,\n  onChange,\n  onClear,\n  optionFilterProps = ['label', 'value'],\n  options,\n  pageSize = DEFAULT_PAGE_SIZE,\n  placeholder = t('Select ...'),\n  showSearch = true,\n  value,\n  ...props\n}: SelectProps) => {\n  const isAsync = typeof options === 'function';\n  const isSingleMode = mode === 'single';\n  const shouldShowSearch = isAsync || allowNewOptions ? true : showSearch;\n  const initialOptions =\n    options && Array.isArray(options) ? options : EMPTY_OPTIONS;\n  const [selectOptions, setSelectOptions] = useState<OptionsType>(\n    initialOptions,\n  );\n  const shouldUseChildrenOptions = !!selectOptions.find(\n    opt => opt?.customLabel,\n  );\n  const [selectValue, setSelectValue] = useState(value);\n  const [searchedValue, setSearchedValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [isTyping, setIsTyping] = useState(false);\n  const [error, setError] = useState('');\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [page, setPage] = useState(0);\n  const [totalCount, setTotalCount] = useState(0);\n  const [loadingEnabled, setLoadingEnabled] = useState(!lazyLoading);\n  const [allValuesLoaded, setAllValuesLoaded] = useState(false);\n  const fetchedQueries = useRef(new Map<string, number>());\n  const mappedMode = isSingleMode\n    ? undefined\n    : allowNewOptions\n    ? 'tags'\n    : 'multiple';\n\n  // TODO: Don't assume that isAsync is always labelInValue\n  const handleTopOptions = useCallback(\n    (selectedValue: AntdSelectValue | undefined) => {\n      // bringing selected options to the top of the list\n      if (selectedValue !== undefined && selectedValue !== null) {\n        const isLabeledValue = isAsync || labelInValue;\n        const topOptions: OptionsType = [];\n        const otherOptions: OptionsType = [];\n\n        selectOptions.forEach(opt => {\n          let found = false;\n          if (Array.isArray(selectedValue)) {\n            if (isLabeledValue) {\n              found =\n                (selectedValue as AntdLabeledValue[]).find(\n                  element => element.value === opt.value,\n                ) !== undefined;\n            } else {\n              found = selectedValue.includes(opt.value);\n            }\n          } else {\n            found = isLabeledValue\n              ? (selectedValue as AntdLabeledValue).value === opt.value\n              : selectedValue === opt.value;\n          }\n\n          if (found) {\n            topOptions.push(opt);\n          } else {\n            otherOptions.push(opt);\n          }\n        });\n\n        // fallback for custom options in tags mode as they\n        // do not appear in the selectOptions state\n        if (!isSingleMode && Array.isArray(selectedValue)) {\n          selectedValue.forEach((val: string | number | AntdLabeledValue) => {\n            if (\n              !topOptions.find(\n                tOpt =>\n                  tOpt.value ===\n                  (isLabeledValue ? (val as AntdLabeledValue)?.value : val),\n              )\n            ) {\n              if (isLabeledValue) {\n                const labelValue = val as AntdLabeledValue;\n                topOptions.push({\n                  label: labelValue.label,\n                  value: labelValue.value,\n                });\n              } else {\n                const value = val as string | number;\n                topOptions.push({ label: String(value), value });\n              }\n            }\n          });\n        }\n\n        const sortedOptions = [...topOptions, ...otherOptions];\n        if (!isEqual(sortedOptions, selectOptions)) {\n          setSelectOptions(sortedOptions);\n        }\n      }\n    },\n    [isAsync, isSingleMode, labelInValue, selectOptions],\n  );\n\n  const handleOnSelect = (\n    selectedValue: string | number | AntdLabeledValue,\n  ) => {\n    if (isSingleMode) {\n      setSelectValue(selectedValue);\n    } else {\n      const currentSelected = selectValue\n        ? Array.isArray(selectValue)\n          ? selectValue\n          : [selectValue]\n        : [];\n      if (\n        typeof selectedValue === 'number' ||\n        typeof selectedValue === 'string'\n      ) {\n        setSelectValue([\n          ...(currentSelected as (string | number)[]),\n          selectedValue as string | number,\n        ]);\n      } else {\n        setSelectValue([\n          ...(currentSelected as AntdLabeledValue[]),\n          selectedValue as AntdLabeledValue,\n        ]);\n      }\n    }\n    setSearchedValue('');\n  };\n\n  const handleOnDeselect = (value: string | number | AntdLabeledValue) => {\n    if (Array.isArray(selectValue)) {\n      if (typeof value === 'number' || typeof value === 'string') {\n        const array = selectValue as (string | number)[];\n        setSelectValue(array.filter(element => element !== value));\n      } else {\n        const array = selectValue as AntdLabeledValue[];\n        setSelectValue(array.filter(element => element.value !== value.value));\n      }\n    }\n    setSearchedValue('');\n  };\n\n  const internalOnError = useCallback(\n    (response: Response) =>\n      getClientErrorObject(response).then(e => {\n        const { error } = e;\n        setError(error);\n\n        if (onError) {\n          onError(error);\n        }\n      }),\n    [onError],\n  );\n\n  const handleData = (data: OptionsType) => {\n    let mergedData: OptionsType = [];\n    if (data && Array.isArray(data) && data.length) {\n      const dataValues = new Set();\n      data.forEach(option =>\n        dataValues.add(String(option.value).toLocaleLowerCase()),\n      );\n\n      // merges with existing and creates unique options\n      setSelectOptions(prevOptions => {\n        mergedData = [\n          ...prevOptions.filter(\n            previousOption =>\n              !dataValues.has(String(previousOption.value).toLocaleLowerCase()),\n          ),\n          ...data,\n        ];\n        return mergedData;\n      });\n    }\n    return mergedData;\n  };\n\n  const handlePaginatedFetch = useMemo(\n    () => (value: string, page: number, pageSize: number) => {\n      if (allValuesLoaded) {\n        setIsLoading(false);\n        setIsTyping(false);\n        return;\n      }\n      const key = `${value};${page};${pageSize}`;\n      const cachedCount = fetchedQueries.current.get(key);\n      if (cachedCount) {\n        setTotalCount(cachedCount);\n        setIsLoading(false);\n        setIsTyping(false);\n        return;\n      }\n      setIsLoading(true);\n      const fetchOptions = options as OptionsPagePromise;\n      fetchOptions(value, page, pageSize)\n        .then(({ data, totalCount }: OptionsTypePage) => {\n          const mergedData = handleData(data);\n          fetchedQueries.current.set(key, totalCount);\n          setTotalCount(totalCount);\n          if (\n            !fetchOnlyOnSearch &&\n            value === '' &&\n            mergedData.length >= totalCount\n          ) {\n            setAllValuesLoaded(true);\n          }\n        })\n        .catch(internalOnError)\n        .finally(() => {\n          setIsLoading(false);\n          setIsTyping(false);\n        });\n    },\n    [allValuesLoaded, fetchOnlyOnSearch, internalOnError, options],\n  );\n\n  const handleOnSearch = useMemo(\n    () =>\n      debounce((search: string) => {\n        const searchValue = search.trim();\n        if (allowNewOptions && isSingleMode) {\n          const newOption = searchValue &&\n            !hasOption(searchValue, selectOptions) && {\n              label: searchValue,\n              value: searchValue,\n            };\n          const newOptions = newOption\n            ? [\n                newOption,\n                ...selectOptions.filter(opt => opt.value !== searchedValue),\n              ]\n            : [...selectOptions.filter(opt => opt.value !== searchedValue)];\n\n          setSelectOptions(newOptions);\n        }\n\n        if (!searchValue || searchValue === searchedValue) {\n          setIsTyping(false);\n        }\n        setSearchedValue(searchValue);\n      }, DEBOUNCE_TIMEOUT),\n    [allowNewOptions, isSingleMode, searchedValue, selectOptions],\n  );\n\n  const handlePagination = (e: UIEvent<HTMLElement>) => {\n    const vScroll = e.currentTarget;\n    const thresholdReached =\n      vScroll.scrollTop > (vScroll.scrollHeight - vScroll.offsetHeight) * 0.7;\n    const hasMoreData = page * pageSize + pageSize < totalCount;\n\n    if (!isLoading && isAsync && hasMoreData && thresholdReached) {\n      const newPage = page + 1;\n      handlePaginatedFetch(searchedValue, newPage, pageSize);\n      setPage(newPage);\n    }\n  };\n\n  const handleFilterOption = (search: string, option: AntdLabeledValue) => {\n    if (typeof filterOption === 'function') {\n      return filterOption(search, option);\n    }\n\n    if (filterOption) {\n      const searchValue = search.trim().toLowerCase();\n\n      if (optionFilterProps && optionFilterProps.length) {\n        return optionFilterProps.some(prop => {\n          const optionProp = option?.[prop]\n            ? String(option[prop]).trim().toLowerCase()\n            : '';\n          return optionProp.includes(searchValue);\n        });\n      }\n    }\n\n    return false;\n  };\n\n  const handleOnDropdownVisibleChange = (isDropdownVisible: boolean) => {\n    setIsDropdownVisible(isDropdownVisible);\n\n    if (isAsync && !loadingEnabled) {\n      setLoadingEnabled(true);\n    }\n\n    // multiple or tags mode keep the dropdown visible while selecting options\n    // this waits for the dropdown to be closed before sorting the top options\n    if (!isSingleMode && !isDropdownVisible) {\n      handleTopOptions(selectValue);\n    }\n  };\n\n  const dropdownRender = (\n    originNode: ReactElement & { ref?: RefObject<HTMLElement> },\n  ) => {\n    if (!isDropdownVisible) {\n      originNode.ref?.current?.scrollTo({ top: 0 });\n    }\n    if ((isLoading && selectOptions.length === 0) || isTyping) {\n      return <StyledLoadingText>{t('Loading...')}</StyledLoadingText>;\n    }\n    return error ? <Error error={error} /> : originNode;\n  };\n\n  const onInputKeyDown = (event: KeyboardEvent<HTMLInputElement>) => {\n    if (event.key.length === 1 && isAsync && !isTyping) {\n      setIsTyping(true);\n    }\n  };\n\n  const SuffixIcon = () => {\n    if (isLoading) {\n      return <StyledSpin size=\"small\" />;\n    }\n    if (shouldShowSearch && isDropdownVisible) {\n      return <SearchOutlined />;\n    }\n    return <DownOutlined />;\n  };\n\n  const handleClear = () => {\n    setSelectValue(undefined);\n    if (onClear) {\n      onClear();\n    }\n  };\n\n  useEffect(() => {\n    fetchedQueries.current.clear();\n    setSelectOptions(\n      options && Array.isArray(options) ? options : EMPTY_OPTIONS,\n    );\n    setAllValuesLoaded(false);\n  }, [options]);\n\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n\n  useEffect(() => {\n    if (selectValue) {\n      const array = Array.isArray(selectValue)\n        ? (selectValue as AntdLabeledValue[])\n        : [selectValue as AntdLabeledValue | string | number];\n      const options: AntdLabeledValue[] = [];\n      const isLabeledValue = isAsync || labelInValue;\n      array.forEach(element => {\n        const found = selectOptions.find((option: { value: string | number }) =>\n          isLabeledValue\n            ? option.value === (element as AntdLabeledValue).value\n            : option.value === element,\n        );\n        if (!found) {\n          options.push(\n            isLabeledValue\n              ? (element as AntdLabeledValue)\n              : ({ value: element, label: element } as AntdLabeledValue),\n          );\n        }\n      });\n      if (options.length > 0) {\n        setSelectOptions([...options, ...selectOptions]);\n      }\n    }\n  }, [labelInValue, isAsync, selectOptions, selectValue]);\n\n  // Stop the invocation of the debounced function after unmounting\n  useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n\n  useEffect(() => {\n    const allowFetch = !fetchOnlyOnSearch || searchedValue;\n    if (isAsync && loadingEnabled && allowFetch) {\n      const page = 0;\n      handlePaginatedFetch(searchedValue, page, pageSize);\n      setPage(page);\n    }\n  }, [\n    isAsync,\n    searchedValue,\n    pageSize,\n    handlePaginatedFetch,\n    loadingEnabled,\n    fetchOnlyOnSearch,\n  ]);\n\n  useEffect(() => {\n    if (isSingleMode) {\n      handleTopOptions(selectValue);\n    }\n  }, [handleTopOptions, isSingleMode, selectValue]);\n\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n\n  return (\n    <StyledContainer>\n      {header}\n      <StyledSelect\n        aria-label={ariaLabel || name}\n        dropdownRender={dropdownRender}\n        filterOption={handleFilterOption}\n        getPopupContainer={triggerNode => triggerNode.parentNode}\n        labelInValue={isAsync || labelInValue}\n        maxTagCount={MAX_TAG_COUNT}\n        mode={mappedMode}\n        notFoundContent={\n          allowNewOptions && !fetchOnlyOnSearch ? (\n            <StyledLoadingText>{t('Loading...')}</StyledLoadingText>\n          ) : (\n            notFoundContent\n          )\n        }\n        onDeselect={handleOnDeselect}\n        onDropdownVisibleChange={handleOnDropdownVisibleChange}\n        onInputKeyDown={onInputKeyDown}\n        onPopupScroll={isAsync ? handlePagination : undefined}\n        onSearch={shouldShowSearch ? handleOnSearch : undefined}\n        onSelect={handleOnSelect}\n        onClear={handleClear}\n        onChange={onChange}\n        options={shouldUseChildrenOptions ? undefined : selectOptions}\n        placeholder={placeholder}\n        showSearch={shouldShowSearch}\n        showArrow\n        tokenSeparators={TOKEN_SEPARATORS}\n        value={selectValue}\n        suffixIcon={<SuffixIcon />}\n        menuItemSelectedIcon={\n          invertSelection ? (\n            <StyledStopOutlined iconSize=\"m\" />\n          ) : (\n            <StyledCheckOutlined iconSize=\"m\" />\n          )\n        }\n        {...props}\n      >\n        {shouldUseChildrenOptions &&\n          selectOptions.map(opt => {\n            const isOptObject = typeof opt === 'object';\n            const label = isOptObject ? opt?.label || opt.value : opt;\n            const value = (isOptObject && opt.value) || opt;\n            const { customLabel, ...optProps } = opt;\n\n            return (\n              <Option {...optProps} key={value} label={label} value={value}>\n                {isOptObject && customLabel ? customLabel : label}\n              </Option>\n            );\n          })}\n      </StyledSelect>\n    </StyledContainer>\n  );\n};\n\nexport default Select;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}