{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { sqlaAutoGeneratedMetricRegex } from 'src/explore/constants';\n\nexport const EXPRESSION_TYPES = {\n  SIMPLE: 'SIMPLE',\n  SQL: 'SQL' };\n\n\nfunction inferSqlExpressionColumn(adhocMetric) {\n  if (\n  adhocMetric.sqlExpression &&\n  sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression))\n  {\n    const indexFirstCloseParen = adhocMetric.sqlExpression.indexOf(')');\n    const indexPairedOpenParen = adhocMetric.sqlExpression.\n    substring(0, indexFirstCloseParen).\n    lastIndexOf('(');\n    if (indexFirstCloseParen > 0 && indexPairedOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(\n      indexPairedOpenParen + 1,\n      indexFirstCloseParen);\n\n    }\n  }\n  return null;\n}\n\nfunction inferSqlExpressionAggregate(adhocMetric) {\n  if (\n  adhocMetric.sqlExpression &&\n  sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression))\n  {\n    const indexFirstOpenParen = adhocMetric.sqlExpression.indexOf('(');\n    if (indexFirstOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(0, indexFirstOpenParen);\n    }\n  }\n  return null;\n}\n\nexport default class AdhocMetric {\n  constructor(adhocMetric) {\n    this.expressionType = adhocMetric.expressionType || EXPRESSION_TYPES.SIMPLE;\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      // try to be clever in the case of transitioning from Sql expression back to simple expression\n      const inferredColumn = inferSqlExpressionColumn(adhocMetric);\n      this.column =\n      adhocMetric.column ||\n      inferredColumn && { column_name: inferredColumn };\n      this.aggregate =\n      adhocMetric.aggregate || inferSqlExpressionAggregate(adhocMetric);\n      this.sqlExpression = null;\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      this.sqlExpression = adhocMetric.sqlExpression;\n      this.column = null;\n      this.aggregate = null;\n    }\n    this.isNew = !!adhocMetric.isNew;\n    this.hasCustomLabel = !!(adhocMetric.hasCustomLabel && adhocMetric.label);\n    this.label = this.hasCustomLabel ?\n    adhocMetric.label :\n    this.getDefaultLabel();\n\n    this.optionName =\n    adhocMetric.optionName ||\n    `metric_${Math.random().\n    toString(36).\n    substring(2, 15)}_${Math.random().toString(36).substring(2, 15)}`;\n  }\n\n  getDefaultLabel() {\n    const label = this.translateToSql(true);\n    return label.length < 43 ? label : `${label.substring(0, 40)}...`;\n  }\n\n  translateToSql(useVerboseName = false) {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {var _this$column, _this$column2;\n      const aggregate = this.aggregate || '';\n      // eslint-disable-next-line camelcase\n      const column =\n      useVerboseName && (_this$column = this.column) != null && _this$column.verbose_name ?\n      `(${this.column.verbose_name})` :\n      (_this$column2 = this.column) != null && _this$column2.column_name ?\n      `(${this.column.column_name})` :\n      '';\n      return aggregate + column;\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return this.sqlExpression;\n    }\n    return '';\n  }\n\n  duplicateWith(nextFields) {\n    return new AdhocMetric({\n      ...this,\n      // all duplicate metrics are not considered new by default\n      isNew: false,\n      // but still overriddable by nextFields\n      ...nextFields });\n\n  }\n\n  equals(adhocMetric) {\n    return (\n      adhocMetric.label === this.label &&\n      adhocMetric.expressionType === this.expressionType &&\n      adhocMetric.sqlExpression === this.sqlExpression &&\n      adhocMetric.aggregate === this.aggregate &&\n      (adhocMetric.column && adhocMetric.column.column_name) === (\n      this.column && this.column.column_name));\n\n  }\n\n  isValid() {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      return !!(this.column && this.aggregate);\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return !!this.sqlExpression;\n    }\n    return false;\n  }\n\n  inferSqlExpressionAggregate() {\n    return inferSqlExpressionAggregate(this);\n  }\n\n  inferSqlExpressionColumn() {\n    return inferSqlExpressionColumn(this);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(EXPRESSION_TYPES, \"EXPRESSION_TYPES\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(inferSqlExpressionColumn, \"inferSqlExpressionColumn\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(inferSqlExpressionAggregate, \"inferSqlExpressionAggregate\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(AdhocMetric, \"AdhocMetric\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(__signature__, \"__signature__\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(EXPRESSION_TYPES, \"EXPRESSION_TYPES\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(inferSqlExpressionColumn, \"inferSqlExpressionColumn\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(inferSqlExpressionAggregate, \"inferSqlExpressionAggregate\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(AdhocMetric, \"AdhocMetric\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js"],"names":["EXPRESSION_TYPES","SIMPLE","SQL","inferSqlExpressionColumn","adhocMetric","sqlaAutoGeneratedMetricRegex","indexFirstCloseParen","indexPairedOpenParen","inferSqlExpressionAggregate","indexFirstOpenParen","AdhocMetric","constructor","inferredColumn","column_name","Math","getDefaultLabel","label","translateToSql","useVerboseName","aggregate","column","verbose_name","duplicateWith","isNew","equals","isValid"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { sqlaAutoGeneratedMetricRegex } from 'src/explore/constants';\n\nexport const EXPRESSION_TYPES = {\n  SIMPLE: 'SIMPLE',\n  SQL: 'SQL',\n};\n\nfunction inferSqlExpressionColumn(adhocMetric) {\n  if (\n    adhocMetric.sqlExpression &&\n    sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression)\n  ) {\n    const indexFirstCloseParen = adhocMetric.sqlExpression.indexOf(')');\n    const indexPairedOpenParen = adhocMetric.sqlExpression\n      .substring(0, indexFirstCloseParen)\n      .lastIndexOf('(');\n    if (indexFirstCloseParen > 0 && indexPairedOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(\n        indexPairedOpenParen + 1,\n        indexFirstCloseParen,\n      );\n    }\n  }\n  return null;\n}\n\nfunction inferSqlExpressionAggregate(adhocMetric) {\n  if (\n    adhocMetric.sqlExpression &&\n    sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression)\n  ) {\n    const indexFirstOpenParen = adhocMetric.sqlExpression.indexOf('(');\n    if (indexFirstOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(0, indexFirstOpenParen);\n    }\n  }\n  return null;\n}\n\nexport default class AdhocMetric {\n  constructor(adhocMetric) {\n    this.expressionType = adhocMetric.expressionType || EXPRESSION_TYPES.SIMPLE;\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      // try to be clever in the case of transitioning from Sql expression back to simple expression\n      const inferredColumn = inferSqlExpressionColumn(adhocMetric);\n      this.column =\n        adhocMetric.column ||\n        (inferredColumn && { column_name: inferredColumn });\n      this.aggregate =\n        adhocMetric.aggregate || inferSqlExpressionAggregate(adhocMetric);\n      this.sqlExpression = null;\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      this.sqlExpression = adhocMetric.sqlExpression;\n      this.column = null;\n      this.aggregate = null;\n    }\n    this.isNew = !!adhocMetric.isNew;\n    this.hasCustomLabel = !!(adhocMetric.hasCustomLabel && adhocMetric.label);\n    this.label = this.hasCustomLabel\n      ? adhocMetric.label\n      : this.getDefaultLabel();\n\n    this.optionName =\n      adhocMetric.optionName ||\n      `metric_${Math.random()\n        .toString(36)\n        .substring(2, 15)}_${Math.random().toString(36).substring(2, 15)}`;\n  }\n\n  getDefaultLabel() {\n    const label = this.translateToSql(true);\n    return label.length < 43 ? label : `${label.substring(0, 40)}...`;\n  }\n\n  translateToSql(useVerboseName = false) {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      const aggregate = this.aggregate || '';\n      // eslint-disable-next-line camelcase\n      const column =\n        useVerboseName && this.column?.verbose_name\n          ? `(${this.column.verbose_name})`\n          : this.column?.column_name\n          ? `(${this.column.column_name})`\n          : '';\n      return aggregate + column;\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return this.sqlExpression;\n    }\n    return '';\n  }\n\n  duplicateWith(nextFields) {\n    return new AdhocMetric({\n      ...this,\n      // all duplicate metrics are not considered new by default\n      isNew: false,\n      // but still overriddable by nextFields\n      ...nextFields,\n    });\n  }\n\n  equals(adhocMetric) {\n    return (\n      adhocMetric.label === this.label &&\n      adhocMetric.expressionType === this.expressionType &&\n      adhocMetric.sqlExpression === this.sqlExpression &&\n      adhocMetric.aggregate === this.aggregate &&\n      (adhocMetric.column && adhocMetric.column.column_name) ===\n        (this.column && this.column.column_name)\n    );\n  }\n\n  isValid() {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      return !!(this.column && this.aggregate);\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return !!this.sqlExpression;\n    }\n    return false;\n  }\n\n  inferSqlExpressionAggregate() {\n    return inferSqlExpressionAggregate(this);\n  }\n\n  inferSqlExpressionColumn() {\n    return inferSqlExpressionColumn(this);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}