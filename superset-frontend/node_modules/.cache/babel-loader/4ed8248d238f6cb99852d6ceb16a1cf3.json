{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { getExtraFormData } from 'src/dashboard/components/nativeFilters/utils';\nimport { areObjectsEqual } from 'src/reduxUtils';\nimport getEffectiveExtraFilters from './getEffectiveExtraFilters';\nimport { getAllActiveFilters } from '../activeAllDashboardFilters';\n// We cache formData objects so that our connected container components don't always trigger\n// render cascades. we cannot leverage the reselect library because our cache size is >1\nconst cachedFiltersByChart = {};\nconst cachedFormdataByChart = {};\n// this function merge chart's formData with dashboard filters value,\n// and generate a new formData which will be used in the new query.\n// filters param only contains those applicable to this chart.\nexport default function getFormDataWithExtraFilters({ chart, charts, filters, nativeFilters, chartConfiguration, colorScheme, colorNamespace, sliceId, layout, dataMask, labelColors }) {\n  // if dashboard metadata + filters have not changed, use cache if possible\n  const cachedFormData = cachedFormdataByChart[sliceId];\n  if (cachedFiltersByChart[sliceId] === filters &&\n  areObjectsEqual(cachedFormData == null ? void 0 : cachedFormData.color_scheme, colorScheme, {\n    ignoreUndefined: true }) &&\n\n  areObjectsEqual(cachedFormData == null ? void 0 : cachedFormData.color_namespace, colorNamespace, {\n    ignoreUndefined: true }) &&\n\n  areObjectsEqual(cachedFormData == null ? void 0 : cachedFormData.label_colors, labelColors, {\n    ignoreUndefined: true }) &&\n\n  !!cachedFormData &&\n  areObjectsEqual(cachedFormData == null ? void 0 : cachedFormData.dataMask, dataMask, {\n    ignoreUndefined: true }))\n  {\n    return cachedFormData;\n  }\n  let extraData = {};\n  const activeFilters = getAllActiveFilters({\n    chartConfiguration,\n    dataMask,\n    layout,\n    nativeFilters: nativeFilters.filters });\n\n  const filterIdsAppliedOnChart = Object.entries(activeFilters).\n  filter(([, { scope }]) => scope.includes(chart.id)).\n  map(([filterId]) => filterId);\n  if (filterIdsAppliedOnChart.length) {\n    extraData = {\n      extra_form_data: getExtraFormData(dataMask, charts, filterIdsAppliedOnChart) };\n\n  }\n  const formData = {\n    ...chart.formData,\n    label_colors: labelColors,\n    ...(colorScheme && { color_scheme: colorScheme }),\n    extra_filters: getEffectiveExtraFilters(filters),\n    ...extraData };\n\n  cachedFiltersByChart[sliceId] = filters;\n  cachedFormdataByChart[sliceId] = { ...formData, dataMask };\n  return formData;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(cachedFiltersByChart, \"cachedFiltersByChart\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts\");reactHotLoader.register(cachedFormdataByChart, \"cachedFormdataByChart\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts\");reactHotLoader.register(getFormDataWithExtraFilters, \"getFormDataWithExtraFilters\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts"],"names":[],"mappings":"uSAoBA,SAAS,gBAAT,QAAiC,8CAAjC;AAEA,SAAS,eAAT,QAAgC,gBAAhC;AACA,OAAO,wBAAP,MAAqC,4BAArC;AAEA,SAAS,mBAAT,QAAoC,8BAApC;AAEA;AACA;AACA,MAAM,oBAAoB,GAAG,EAA7B;AACA,MAAM,qBAAqB,GAAG,EAA9B;AAgBA;AACA;AACA;AACA,eAAc,SAAU,2BAAV,CAAsC,EAClD,KADkD,EAElD,MAFkD,EAGlD,OAHkD,EAIlD,aAJkD,EAKlD,kBALkD,EAMlD,WANkD,EAOlD,cAPkD,EAQlD,OARkD,EASlD,MATkD,EAUlD,QAVkD,EAWlD,WAXkD,EAAtC,EAYyB;AACrC;AACA,QAAM,cAAc,GAAG,qBAAqB,CAAC,OAAD,CAA5C;AACA,MACE,oBAAoB,CAAC,OAAD,CAApB,KAAkC,OAAlC;AACA,EAAA,eAAe,CAAC,cAAD,oBAAC,cAAc,CAAE,YAAjB,EAA+B,WAA/B,EAA4C;AACzD,IAAA,eAAe,EAAE,IADwC,EAA5C,CADf;;AAIA,EAAA,eAAe,CAAC,cAAD,oBAAC,cAAc,CAAE,eAAjB,EAAkC,cAAlC,EAAkD;AAC/D,IAAA,eAAe,EAAE,IAD8C,EAAlD,CAJf;;AAOA,EAAA,eAAe,CAAC,cAAD,oBAAC,cAAc,CAAE,YAAjB,EAA+B,WAA/B,EAA4C;AACzD,IAAA,eAAe,EAAE,IADwC,EAA5C,CAPf;;AAUA,GAAC,CAAC,cAVF;AAWA,EAAA,eAAe,CAAC,cAAD,oBAAC,cAAc,CAAE,QAAjB,EAA2B,QAA3B,EAAqC;AAClD,IAAA,eAAe,EAAE,IADiC,EAArC,CAZjB;AAeE;AACA,WAAO,cAAP;AACD;AAED,MAAI,SAAS,GAAqC,EAAlD;AACA,QAAM,aAAa,GAAG,mBAAmB,CAAC;AACxC,IAAA,kBADwC;AAExC,IAAA,QAFwC;AAGxC,IAAA,MAHwC;AAIxC,IAAA,aAAa,EAAE,aAAa,CAAC,OAJW,EAAD,CAAzC;;AAMA,QAAM,uBAAuB,GAAG,MAAM,CAAC,OAAP,CAAe,aAAf;AAC7B,EAAA,MAD6B,CACtB,CAAC,GAAG,EAAE,KAAF,EAAH,CAAD,KAAmB,KAAK,CAAC,QAAN,CAAe,KAAK,CAAC,EAArB,CADG;AAE7B,EAAA,GAF6B,CAEzB,CAAC,CAAC,QAAD,CAAD,KAAgB,QAFS,CAAhC;AAGA,MAAI,uBAAuB,CAAC,MAA5B,EAAoC;AAClC,IAAA,SAAS,GAAG;AACV,MAAA,eAAe,EAAE,gBAAgB,CAC/B,QAD+B,EAE/B,MAF+B,EAG/B,uBAH+B,CADvB,EAAZ;;AAOD;AAED,QAAM,QAAQ,GAAG;AACf,OAAG,KAAK,CAAC,QADM;AAEf,IAAA,YAAY,EAAE,WAFC;AAGf,QAAI,WAAW,IAAI,EAAE,YAAY,EAAE,WAAhB,EAAnB,CAHe;AAIf,IAAA,aAAa,EAAE,wBAAwB,CAAC,OAAD,CAJxB;AAKf,OAAG,SALY,EAAjB;;AAQA,EAAA,oBAAoB,CAAC,OAAD,CAApB,GAAgC,OAAhC;AACA,EAAA,qBAAqB,CAAC,OAAD,CAArB,GAAiC,EAAE,GAAG,QAAL,EAAe,QAAf,EAAjC;AAEA,SAAO,QAAP;AACD,C,iLAtFK,oB,gKACA,qB,iKAmBkB,2B","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { DataRecordFilters, JsonObject } from '@superset-ui/core';\nimport { ChartQueryPayload, Charts, LayoutItem } from 'src/dashboard/types';\nimport { getExtraFormData } from 'src/dashboard/components/nativeFilters/utils';\nimport { DataMaskStateWithId } from 'src/dataMask/types';\nimport { areObjectsEqual } from 'src/reduxUtils';\nimport getEffectiveExtraFilters from './getEffectiveExtraFilters';\nimport { ChartConfiguration, NativeFiltersState } from '../../reducers/types';\nimport { getAllActiveFilters } from '../activeAllDashboardFilters';\n\n// We cache formData objects so that our connected container components don't always trigger\n// render cascades. we cannot leverage the reselect library because our cache size is >1\nconst cachedFiltersByChart = {};\nconst cachedFormdataByChart = {};\n\nexport interface GetFormDataWithExtraFiltersArguments {\n  chartConfiguration: ChartConfiguration;\n  chart: ChartQueryPayload;\n  charts: Charts;\n  filters: DataRecordFilters;\n  layout: { [key: string]: LayoutItem };\n  colorScheme?: string;\n  colorNamespace?: string;\n  sliceId: number;\n  dataMask: DataMaskStateWithId;\n  nativeFilters: NativeFiltersState;\n  labelColors?: Record<string, string>;\n}\n\n// this function merge chart's formData with dashboard filters value,\n// and generate a new formData which will be used in the new query.\n// filters param only contains those applicable to this chart.\nexport default function getFormDataWithExtraFilters({\n  chart,\n  charts,\n  filters,\n  nativeFilters,\n  chartConfiguration,\n  colorScheme,\n  colorNamespace,\n  sliceId,\n  layout,\n  dataMask,\n  labelColors,\n}: GetFormDataWithExtraFiltersArguments) {\n  // if dashboard metadata + filters have not changed, use cache if possible\n  const cachedFormData = cachedFormdataByChart[sliceId];\n  if (\n    cachedFiltersByChart[sliceId] === filters &&\n    areObjectsEqual(cachedFormData?.color_scheme, colorScheme, {\n      ignoreUndefined: true,\n    }) &&\n    areObjectsEqual(cachedFormData?.color_namespace, colorNamespace, {\n      ignoreUndefined: true,\n    }) &&\n    areObjectsEqual(cachedFormData?.label_colors, labelColors, {\n      ignoreUndefined: true,\n    }) &&\n    !!cachedFormData &&\n    areObjectsEqual(cachedFormData?.dataMask, dataMask, {\n      ignoreUndefined: true,\n    })\n  ) {\n    return cachedFormData;\n  }\n\n  let extraData: { extra_form_data?: JsonObject } = {};\n  const activeFilters = getAllActiveFilters({\n    chartConfiguration,\n    dataMask,\n    layout,\n    nativeFilters: nativeFilters.filters,\n  });\n  const filterIdsAppliedOnChart = Object.entries(activeFilters)\n    .filter(([, { scope }]) => scope.includes(chart.id))\n    .map(([filterId]) => filterId);\n  if (filterIdsAppliedOnChart.length) {\n    extraData = {\n      extra_form_data: getExtraFormData(\n        dataMask,\n        charts,\n        filterIdsAppliedOnChart,\n      ),\n    };\n  }\n\n  const formData = {\n    ...chart.formData,\n    label_colors: labelColors,\n    ...(colorScheme && { color_scheme: colorScheme }),\n    extra_filters: getEffectiveExtraFilters(filters),\n    ...extraData,\n  };\n\n  cachedFiltersByChart[sliceId] = filters;\n  cachedFormdataByChart[sliceId] = { ...formData, dataMask };\n\n  return formData;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}