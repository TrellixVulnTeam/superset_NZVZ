{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import \"core-js/modules/es.typed-array.from.js\";import \"core-js/modules/es.typed-array.uint32-array.js\";import \"core-js/modules/es.typed-array.sort.js\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import ascending from \"./ascending.js\";\nimport permute from \"./permute.js\";\n\nexport default function sort(values, ...F) {\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  values = Array.from(values);\n  let [f = ascending] = F;\n  if (f.length === 1 || F.length > 1) {\n    const index = Uint32Array.from(values, (d, i) => i);\n    if (F.length > 1) {\n      F = F.map((f) => values.map(f));\n      index.sort((i, j) => {\n        for (const f of F) {\n          const c = ascending(f[i], f[j]);\n          if (c) return c;\n        }\n      });\n    } else {\n      f = values.map(f);\n      index.sort((i, j) => ascending(f[i], f[j]));\n    }\n    return permute(values, index);\n  }\n  return values.sort(f);\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(sort, \"sort\", \"/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/color/node_modules/d3-array/src/sort.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/color/node_modules/d3-array/src/sort.js"],"names":["ascending","permute","sort","values","F","Symbol","iterator","TypeError","Array","from","f","length","index","Uint32Array","d","i","map","j","c"],"mappings":"+bAAA,OAAOA,SAAP,MAAsB,gBAAtB;AACA,OAAOC,OAAP,MAAoB,cAApB;;AAEA,eAAe,SAASC,IAAT,CAAcC,MAAd,EAAsB,GAAGC,CAAzB,EAA4B;AACzC,MAAI,OAAOD,MAAM,CAACE,MAAM,CAACC,QAAR,CAAb,KAAmC,UAAvC,EAAmD,MAAM,IAAIC,SAAJ,CAAc,wBAAd,CAAN;AACnDJ,EAAAA,MAAM,GAAGK,KAAK,CAACC,IAAN,CAAWN,MAAX,CAAT;AACA,MAAI,CAACO,CAAC,GAAGV,SAAL,IAAkBI,CAAtB;AACA,MAAIM,CAAC,CAACC,MAAF,KAAa,CAAb,IAAkBP,CAAC,CAACO,MAAF,GAAW,CAAjC,EAAoC;AAClC,UAAMC,KAAK,GAAGC,WAAW,CAACJ,IAAZ,CAAiBN,MAAjB,EAAyB,CAACW,CAAD,EAAIC,CAAJ,KAAUA,CAAnC,CAAd;AACA,QAAIX,CAAC,CAACO,MAAF,GAAW,CAAf,EAAkB;AAChBP,MAAAA,CAAC,GAAGA,CAAC,CAACY,GAAF,CAAM,CAAAN,CAAC,KAAIP,MAAM,CAACa,GAAP,CAAWN,CAAX,CAAX,CAAJ;AACAE,MAAAA,KAAK,CAACV,IAAN,CAAW,CAACa,CAAD,EAAIE,CAAJ,KAAU;AACnB,aAAK,MAAMP,CAAX,IAAgBN,CAAhB,EAAmB;AACjB,gBAAMc,CAAC,GAAGlB,SAAS,CAACU,CAAC,CAACK,CAAD,CAAF,EAAOL,CAAC,CAACO,CAAD,CAAR,CAAnB;AACA,cAAIC,CAAJ,EAAO,OAAOA,CAAP;AACR;AACF,OALD;AAMD,KARD,MAQO;AACLR,MAAAA,CAAC,GAAGP,MAAM,CAACa,GAAP,CAAWN,CAAX,CAAJ;AACAE,MAAAA,KAAK,CAACV,IAAN,CAAW,CAACa,CAAD,EAAIE,CAAJ,KAAUjB,SAAS,CAACU,CAAC,CAACK,CAAD,CAAF,EAAOL,CAAC,CAACO,CAAD,CAAR,CAA9B;AACD;AACD,WAAOhB,OAAO,CAACE,MAAD,EAASS,KAAT,CAAd;AACD;AACD,SAAOT,MAAM,CAACD,IAAP,CAAYQ,CAAZ,CAAP;AACD,C,iLArBuBR,I","sourcesContent":["import ascending from \"./ascending.js\";\nimport permute from \"./permute.js\";\n\nexport default function sort(values, ...F) {\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  values = Array.from(values);\n  let [f = ascending] = F;\n  if (f.length === 1 || F.length > 1) {\n    const index = Uint32Array.from(values, (d, i) => i);\n    if (F.length > 1) {\n      F = F.map(f => values.map(f));\n      index.sort((i, j) => {\n        for (const f of F) {\n          const c = ascending(f[i], f[j]);\n          if (c) return c;\n        }\n      });\n    } else {\n      f = values.map(f);\n      index.sort((i, j) => ascending(f[i], f[j]));\n    }\n    return permute(values, index);\n  }\n  return values.sort(f);\n}\n"]},"metadata":{},"sourceType":"module"}