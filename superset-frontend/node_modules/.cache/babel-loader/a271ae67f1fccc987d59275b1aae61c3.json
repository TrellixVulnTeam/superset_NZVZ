{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";import _flatMap from \"lodash/flatMap\";import _mapValues from \"lodash/fp/mapValues\";import _keyBy from \"lodash/fp/keyBy\";import _flow from \"lodash/fp/flow\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  tabs.forEach(({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !tabsInScope.includes(tab)) {\n      tabChildren.forEach(({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !tabsInScope.includes(subTab)) {\n          chartsNotInScope.push(\n          ...subTabChildren.filter(({ type }) => type === CHART_TYPE));\n\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map(({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = [] })\n{\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n  forceAggregate ||\n  !hasChartSiblings &&\n  Object.entries(tabScopes).every(\n  ([key, { scope }]) => scope && scope.length && key === scope[0]))\n\n  {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope = getImmuneChartIdsFromTabsNotInScope(\n    {\n      tabs: tabChildren,\n      tabsInScope: _flatMap(tabScopes, ({ scope }) => scope) });\n\n\n    const immuneChartIdsFromTabsInScope = _flatMap(\n    Object.values(tabScopes),\n    ({ immune }) => immune);\n\n    const immuneCharts = [\n    ...new Set([\n    ...immuneChartIdsFromTabsNotInScope,\n    ...immuneChartIdsFromTabsInScope])];\n\n\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts };\n\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n  ({ scope }) => scope && scope.length);\n\n  return {\n    scope: _flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length ?\n    _flatMap(componentsInScope, ({ immune }) => immune) :\n    _flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n    immuneChartSiblings) };\n\n\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren.\n  filter(\n  ({ value }) => filterId !== value && !checkedChartIds.includes(value)).\n\n  map(({ value }) => value);\n  const tabScopes = _flow(\n  _keyBy((child) => child.value),\n  _mapValues((child) =>\n  traverse({\n    currentNode: child,\n    filterId,\n    checkedChartIds })))(\n\n\n  tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n  !_isEmpty(chartChildren) &&\n  chartChildren.some(({ value }) => checkedChartIds.includes(value)))\n  {\n    if (_isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren });\n\n    return {\n      scope,\n      immune: chartsImmune.concat(immune) };\n\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !_isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune });\n\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune };\n\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [] })\n{\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds });\n\n  }\n\n  return {};\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getImmuneChartIdsFromTabsNotInScope, \"getImmuneChartIdsFromTabsNotInScope\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getTabChildrenScope, \"getTabChildrenScope\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(traverse, \"traverse\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getFilterScopeFromNodesTree, \"getFilterScopeFromNodesTree\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js"],"names":["CHART_TYPE","TAB_TYPE","getChartIdAndColumnFromFilterKey","getImmuneChartIdsFromTabsNotInScope","tabs","tabsInScope","chartsNotInScope","forEach","value","tab","children","tabChildren","includes","subTab","subTabChildren","push","filter","type","map","getTabChildrenScope","tabScopes","parentNodeValue","forceAggregate","hasChartSiblings","immuneChartSiblings","Object","entries","every","key","scope","length","immuneChartIdsFromTabsNotInScope","immuneChartIdsFromTabsInScope","values","immune","immuneCharts","Set","componentsInScope","concat","traverse","currentNode","filterId","checkedChartIds","currentValue","chartChildren","chartsImmune","child","some","getFilterScopeFromNodesTree","filterKey","nodes","chartId"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { flow, keyBy, mapValues } from 'lodash/fp';\nimport { flatMap, isEmpty } from 'lodash';\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  tabs.forEach(({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !tabsInScope.includes(tab)) {\n      tabChildren.forEach(({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !tabsInScope.includes(subTab)) {\n          chartsNotInScope.push(\n            ...subTabChildren.filter(({ type }) => type === CHART_TYPE),\n          );\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map(({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = [],\n}) {\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n    forceAggregate ||\n    (!hasChartSiblings &&\n      Object.entries(tabScopes).every(\n        ([key, { scope }]) => scope && scope.length && key === scope[0],\n      ))\n  ) {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope = getImmuneChartIdsFromTabsNotInScope(\n      {\n        tabs: tabChildren,\n        tabsInScope: flatMap(tabScopes, ({ scope }) => scope),\n      },\n    );\n    const immuneChartIdsFromTabsInScope = flatMap(\n      Object.values(tabScopes),\n      ({ immune }) => immune,\n    );\n    const immuneCharts = [\n      ...new Set([\n        ...immuneChartIdsFromTabsNotInScope,\n        ...immuneChartIdsFromTabsInScope,\n      ]),\n    ];\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts,\n    };\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n    ({ scope }) => scope && scope.length,\n  );\n  return {\n    scope: flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length\n      ? flatMap(componentsInScope, ({ immune }) => immune)\n      : flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n          immuneChartSiblings,\n        ),\n  };\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren\n    .filter(\n      ({ value }) => filterId !== value && !checkedChartIds.includes(value),\n    )\n    .map(({ value }) => value);\n  const tabScopes = flow(\n    keyBy(child => child.value),\n    mapValues(child =>\n      traverse({\n        currentNode: child,\n        filterId,\n        checkedChartIds,\n      }),\n    ),\n  )(tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n    !isEmpty(chartChildren) &&\n    chartChildren.some(({ value }) => checkedChartIds.includes(value))\n  ) {\n    if (isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren,\n    });\n    return {\n      scope,\n      immune: chartsImmune.concat(immune),\n    };\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune,\n    });\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune,\n  };\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [],\n}) {\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds,\n    });\n  }\n\n  return {};\n}\n"]},"metadata":{},"sourceType":"module"}