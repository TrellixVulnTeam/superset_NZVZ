{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { SyncRegistry, OverwritePolicy } from '@encodable/registry';\nexport default class FormatterRegistry extends SyncRegistry {\n  constructor({\n    overwritePolicy = OverwritePolicy.WARN,\n    ...rest })\n  {\n    super({\n      overwritePolicy,\n      ...rest });\n\n  }\n  /**\n   * Subclasses must implement this to create formatter from format string.\n   * Worst-case can return `fallbackFormatter`.\n   */\n\n\n  /**\n   * Get a Formatter by name\n   * @param format Formatter name, usually is a format string\n   */\n  get(format) {\n    const targetFormat = (\"\" + (format === null || typeof format === 'undefined' || format.trim().length === 0 ? this.getDefaultKey() : format)).trim();\n\n    if (this.has(targetFormat)) {\n      return super.get(targetFormat);\n    } // Create new formatter if does not exist\n\n\n    const formatter = this.createFormatter(targetFormat);\n    this.registerValue(targetFormat, formatter);\n    return formatter;\n  }\n  /**\n   * Format value with the named Formatter\n   * @param format Formatter name, usually is a format string\n   * @param value value to be formatted\n   */\n\n\n  format(format, value) {\n    return this.get(format)(value);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(FormatterRegistry, \"FormatterRegistry\", \"/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/format/esm/FormatterRegistry.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/format/esm/FormatterRegistry.js"],"names":["SyncRegistry","OverwritePolicy","FormatterRegistry","constructor","overwritePolicy","WARN","rest","get","format","targetFormat","trim","length","getDefaultKey","has","formatter","createFormatter","registerValue","value"],"mappings":"uSAAA,SAASA,YAAT,EAAuBC,eAAvB,QAA8C,qBAA9C;AACA,eAAe,MAAMC,iBAAN,SAAgCF,YAAhC,CAA6C;AAC1DG,EAAAA,WAAW,CAAC;AACVC,IAAAA,eAAe,GAAGH,eAAe,CAACI,IADxB;AAEV,OAAGC,IAFO,EAAD;AAGR;AACD,UAAM;AACJF,MAAAA,eADI;AAEJ,SAAGE,IAFC,EAAN;;AAID;AACD;AACF;AACA;AACA;;;AAGE;AACF;AACA;AACA;AACEC,EAAAA,GAAG,CAACC,MAAD,EAAS;AACV,UAAMC,YAAY,GAAG,CAAC,MAAMD,MAAM,KAAK,IAAX,IAAmB,OAAOA,MAAP,KAAkB,WAArC,IAAoDA,MAAM,CAACE,IAAP,GAAcC,MAAd,KAAyB,CAA7E,GAAiF,KAAKC,aAAL,EAAjF,GAAwGJ,MAA9G,CAAD,EAAwHE,IAAxH,EAArB;;AAEA,QAAI,KAAKG,GAAL,CAASJ,YAAT,CAAJ,EAA4B;AAC1B,aAAO,MAAMF,GAAN,CAAUE,YAAV,CAAP;AACD,KALS,CAKR;;;AAGF,UAAMK,SAAS,GAAG,KAAKC,eAAL,CAAqBN,YAArB,CAAlB;AACA,SAAKO,aAAL,CAAmBP,YAAnB,EAAiCK,SAAjC;AACA,WAAOA,SAAP;AACD;AACD;AACF;AACA;AACA;AACA;;;AAGEN,EAAAA,MAAM,CAACA,MAAD,EAASS,KAAT,EAAgB;AACpB,WAAO,KAAKV,GAAL,CAASC,MAAT,EAAiBS,KAAjB,CAAP;AACD,GAzCyD;AAAA;AAAA,6B,iLAAvCf,iB","sourcesContent":["import { SyncRegistry, OverwritePolicy } from '@encodable/registry';\nexport default class FormatterRegistry extends SyncRegistry {\n  constructor({\n    overwritePolicy = OverwritePolicy.WARN,\n    ...rest\n  }) {\n    super({\n      overwritePolicy,\n      ...rest\n    });\n  }\n  /**\n   * Subclasses must implement this to create formatter from format string.\n   * Worst-case can return `fallbackFormatter`.\n   */\n\n\n  /**\n   * Get a Formatter by name\n   * @param format Formatter name, usually is a format string\n   */\n  get(format) {\n    const targetFormat = (\"\" + (format === null || typeof format === 'undefined' || format.trim().length === 0 ? this.getDefaultKey() : format)).trim();\n\n    if (this.has(targetFormat)) {\n      return super.get(targetFormat);\n    } // Create new formatter if does not exist\n\n\n    const formatter = this.createFormatter(targetFormat);\n    this.registerValue(targetFormat, formatter);\n    return formatter;\n  }\n  /**\n   * Format value with the named Formatter\n   * @param format Formatter name, usually is a format string\n   * @param value value to be formatted\n   */\n\n\n  format(format, value) {\n    return this.get(format)(value);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}