{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\nDASHBOARD_ROOT_ID,\nDASHBOARD_GRID_ID,\nNEW_COMPONENTS_SOURCE_ID,\nDASHBOARD_HEADER_ID } from\n'../util/constants';\nimport componentIsResizable from '../util/componentIsResizable';\nimport findParentId from '../util/findParentId';\nimport getComponentWidthFromDrop from '../util/getComponentWidthFromDrop';\nimport updateComponentParentsList from '../util/updateComponentParentsList';\nimport newComponentFactory from '../util/newComponentFactory';\nimport newEntitiesFromDrop from '../util/newEntitiesFromDrop';\nimport reorderItem from '../util/dnd-reorder';\nimport shouldWrapChildInRow from '../util/shouldWrapChildInRow';\nimport { ROW_TYPE, TAB_TYPE, TABS_TYPE } from '../util/componentTypes';\n\nimport {\nUPDATE_COMPONENTS,\nUPDATE_COMPONENTS_PARENTS_LIST,\nDELETE_COMPONENT,\nCREATE_COMPONENT,\nMOVE_COMPONENT,\nCREATE_TOP_LEVEL_TABS,\nDELETE_TOP_LEVEL_TABS,\nDASHBOARD_TITLE_CHANGED } from\n'../actions/dashboardLayout';\n\nimport { HYDRATE_DASHBOARD } from '../actions/hydrate';\n\nconst actionHandlers = {\n  [HYDRATE_DASHBOARD](state, action) {\n    return {\n      ...action.data.dashboardLayout.present };\n\n  },\n\n  [UPDATE_COMPONENTS](state, action) {\n    const {\n      payload: { nextComponents } } =\n    action;\n    return {\n      ...state,\n      ...nextComponents };\n\n  },\n\n  [DELETE_COMPONENT](state, action) {\n    const {\n      payload: { id, parentId } } =\n    action;\n\n    if (!parentId || !id || !state[id] || !state[parentId]) return state;\n\n    const nextComponents = { ...state };\n\n    function recursivelyDeleteChildren(componentId, componentParentId) {\n      // delete child and it's children\n      const component = nextComponents[componentId];\n      delete nextComponents[componentId];\n\n      const { children = [] } = component;\n      children.forEach((childId) => {\n        recursivelyDeleteChildren(childId, componentId);\n      });\n\n      const parent = nextComponents[componentParentId];\n      if (parent) {\n        // may have been deleted in another recursion\n        const componentIndex = (parent.children || []).indexOf(componentId);\n        if (componentIndex > -1) {\n          const nextChildren = [...parent.children];\n          nextChildren.splice(componentIndex, 1);\n          nextComponents[componentParentId] = {\n            ...parent,\n            children: nextChildren };\n\n        }\n      }\n    }\n\n    recursivelyDeleteChildren(id, parentId);\n    const nextParent = nextComponents[parentId];\n    if (nextParent.type === ROW_TYPE && nextParent.children.length === 0) {\n      const grandparentId = findParentId({\n        childId: parentId,\n        layout: nextComponents });\n\n      recursivelyDeleteChildren(parentId, grandparentId);\n    }\n\n    return nextComponents;\n  },\n\n  [CREATE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n\n    return {\n      ...state,\n      ...newEntities };\n\n  },\n\n  [MOVE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n    const { source, destination, dragging } = dropResult;\n\n    if (!source || !destination || !dragging) return state;\n\n    const nextEntities = reorderItem({\n      entitiesMap: state,\n      source,\n      destination });\n\n\n    if (componentIsResizable(nextEntities[dragging.id])) {\n      // update component width if it changed\n      const nextWidth =\n      getComponentWidthFromDrop({\n        dropResult,\n        layout: state }) ||\n      undefined; // don't set a 0 width\n      if ((nextEntities[dragging.id].meta || {}).width !== nextWidth) {\n        nextEntities[dragging.id] = {\n          ...nextEntities[dragging.id],\n          meta: {\n            ...nextEntities[dragging.id].meta,\n            width: nextWidth } };\n\n\n      }\n    }\n\n    // wrap the dragged component in a row depending on destination type\n    const wrapInRow = shouldWrapChildInRow({\n      parentType: destination.type,\n      childType: dragging.type });\n\n\n    if (wrapInRow) {\n      const destinationEntity = nextEntities[destination.id];\n      const destinationChildren = destinationEntity.children;\n      const newRow = newComponentFactory(ROW_TYPE);\n      newRow.children = [destinationChildren[destination.index]];\n      newRow.parents = (destinationEntity.parents || []).concat(destination.id);\n      destinationChildren[destination.index] = newRow.id;\n      nextEntities[newRow.id] = newRow;\n    }\n\n    return {\n      ...state,\n      ...nextEntities };\n\n  },\n\n  [CREATE_TOP_LEVEL_TABS](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n    const { source, dragging } = dropResult;\n\n    // move children of current root to be children of the dragging tab\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelComponent = state[topLevelId];\n\n    if (source.id !== NEW_COMPONENTS_SOURCE_ID) {\n      // component already exists\n      const draggingTabs = state[dragging.id];\n      const draggingTabId = draggingTabs.children[0];\n      const draggingTab = state[draggingTabId];\n\n      // move all children except the one that is dragging\n      const childrenToMove = [...topLevelComponent.children].filter(\n      (id) => id !== dragging.id);\n\n\n      return {\n        ...state,\n        [DASHBOARD_ROOT_ID]: {\n          ...rootComponent,\n          children: [dragging.id] },\n\n        [topLevelId]: {\n          ...topLevelComponent,\n          children: [] },\n\n        [draggingTabId]: {\n          ...draggingTab,\n          children: [...draggingTab.children, ...childrenToMove] } };\n\n\n    }\n\n    // create new component\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n    const newEntitiesArray = Object.values(newEntities);\n    const tabComponent = newEntitiesArray.find(\n    (component) => component.type === TAB_TYPE);\n\n    const tabsComponent = newEntitiesArray.find(\n    (component) => component.type === TABS_TYPE);\n\n\n    tabComponent.children = [...topLevelComponent.children];\n    newEntities[topLevelId] = { ...topLevelComponent, children: [] };\n    newEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [tabsComponent.id] };\n\n\n    return {\n      ...state,\n      ...newEntities };\n\n  },\n\n  [DELETE_TOP_LEVEL_TABS](state) {\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelTabs = state[topLevelId];\n\n    if (topLevelTabs.type !== TABS_TYPE) return state;\n\n    let childrenToMove = [];\n    const nextEntities = { ...state };\n\n    topLevelTabs.children.forEach((tabId) => {\n      const tabComponent = state[tabId];\n      childrenToMove = [...childrenToMove, ...tabComponent.children];\n      delete nextEntities[tabId];\n    });\n\n    delete nextEntities[topLevelId];\n\n    nextEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [DASHBOARD_GRID_ID] };\n\n\n    nextEntities[DASHBOARD_GRID_ID] = {\n      ...state[DASHBOARD_GRID_ID],\n      children: childrenToMove };\n\n\n    return nextEntities;\n  },\n\n  [UPDATE_COMPONENTS_PARENTS_LIST](state) {\n    const nextState = {\n      ...state };\n\n\n    updateComponentParentsList({\n      currentComponent: nextState[DASHBOARD_ROOT_ID],\n      layout: nextState });\n\n\n    return {\n      ...nextState };\n\n  },\n\n  [DASHBOARD_TITLE_CHANGED](state, action) {\n    return {\n      ...state,\n      [DASHBOARD_HEADER_ID]: {\n        ...state[DASHBOARD_HEADER_ID],\n        meta: {\n          ...state[DASHBOARD_HEADER_ID].meta,\n          text: action.text } } };\n\n\n\n  } };\n\n\nexport default function layoutReducer(state = {}, action) {\n  if (action.type in actionHandlers) {\n    const handler = actionHandlers[action.type];\n    return handler(state, action);\n  }\n\n  return state;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(actionHandlers, \"actionHandlers\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/reducers/dashboardLayout.js\");reactHotLoader.register(layoutReducer, \"layoutReducer\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/reducers/dashboardLayout.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/reducers/dashboardLayout.js"],"names":["DASHBOARD_ROOT_ID","DASHBOARD_GRID_ID","NEW_COMPONENTS_SOURCE_ID","DASHBOARD_HEADER_ID","componentIsResizable","findParentId","getComponentWidthFromDrop","updateComponentParentsList","newComponentFactory","newEntitiesFromDrop","reorderItem","shouldWrapChildInRow","ROW_TYPE","TAB_TYPE","TABS_TYPE","UPDATE_COMPONENTS","UPDATE_COMPONENTS_PARENTS_LIST","DELETE_COMPONENT","CREATE_COMPONENT","MOVE_COMPONENT","CREATE_TOP_LEVEL_TABS","DELETE_TOP_LEVEL_TABS","DASHBOARD_TITLE_CHANGED","HYDRATE_DASHBOARD","actionHandlers","state","action","data","dashboardLayout","present","payload","nextComponents","id","parentId","recursivelyDeleteChildren","componentId","componentParentId","component","children","forEach","childId","parent","componentIndex","indexOf","nextChildren","splice","nextParent","type","length","grandparentId","layout","dropResult","newEntities","source","destination","dragging","nextEntities","entitiesMap","nextWidth","undefined","meta","width","wrapInRow","parentType","childType","destinationEntity","destinationChildren","newRow","index","parents","concat","rootComponent","topLevelId","topLevelComponent","draggingTabs","draggingTabId","draggingTab","childrenToMove","filter","newEntitiesArray","Object","values","tabComponent","find","tabsComponent","topLevelTabs","tabId","nextState","currentComponent","text","layoutReducer","handler"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  DASHBOARD_ROOT_ID,\n  DASHBOARD_GRID_ID,\n  NEW_COMPONENTS_SOURCE_ID,\n  DASHBOARD_HEADER_ID,\n} from '../util/constants';\nimport componentIsResizable from '../util/componentIsResizable';\nimport findParentId from '../util/findParentId';\nimport getComponentWidthFromDrop from '../util/getComponentWidthFromDrop';\nimport updateComponentParentsList from '../util/updateComponentParentsList';\nimport newComponentFactory from '../util/newComponentFactory';\nimport newEntitiesFromDrop from '../util/newEntitiesFromDrop';\nimport reorderItem from '../util/dnd-reorder';\nimport shouldWrapChildInRow from '../util/shouldWrapChildInRow';\nimport { ROW_TYPE, TAB_TYPE, TABS_TYPE } from '../util/componentTypes';\n\nimport {\n  UPDATE_COMPONENTS,\n  UPDATE_COMPONENTS_PARENTS_LIST,\n  DELETE_COMPONENT,\n  CREATE_COMPONENT,\n  MOVE_COMPONENT,\n  CREATE_TOP_LEVEL_TABS,\n  DELETE_TOP_LEVEL_TABS,\n  DASHBOARD_TITLE_CHANGED,\n} from '../actions/dashboardLayout';\n\nimport { HYDRATE_DASHBOARD } from '../actions/hydrate';\n\nconst actionHandlers = {\n  [HYDRATE_DASHBOARD](state, action) {\n    return {\n      ...action.data.dashboardLayout.present,\n    };\n  },\n\n  [UPDATE_COMPONENTS](state, action) {\n    const {\n      payload: { nextComponents },\n    } = action;\n    return {\n      ...state,\n      ...nextComponents,\n    };\n  },\n\n  [DELETE_COMPONENT](state, action) {\n    const {\n      payload: { id, parentId },\n    } = action;\n\n    if (!parentId || !id || !state[id] || !state[parentId]) return state;\n\n    const nextComponents = { ...state };\n\n    function recursivelyDeleteChildren(componentId, componentParentId) {\n      // delete child and it's children\n      const component = nextComponents[componentId];\n      delete nextComponents[componentId];\n\n      const { children = [] } = component;\n      children.forEach(childId => {\n        recursivelyDeleteChildren(childId, componentId);\n      });\n\n      const parent = nextComponents[componentParentId];\n      if (parent) {\n        // may have been deleted in another recursion\n        const componentIndex = (parent.children || []).indexOf(componentId);\n        if (componentIndex > -1) {\n          const nextChildren = [...parent.children];\n          nextChildren.splice(componentIndex, 1);\n          nextComponents[componentParentId] = {\n            ...parent,\n            children: nextChildren,\n          };\n        }\n      }\n    }\n\n    recursivelyDeleteChildren(id, parentId);\n    const nextParent = nextComponents[parentId];\n    if (nextParent.type === ROW_TYPE && nextParent.children.length === 0) {\n      const grandparentId = findParentId({\n        childId: parentId,\n        layout: nextComponents,\n      });\n      recursivelyDeleteChildren(parentId, grandparentId);\n    }\n\n    return nextComponents;\n  },\n\n  [CREATE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n\n    return {\n      ...state,\n      ...newEntities,\n    };\n  },\n\n  [MOVE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n    const { source, destination, dragging } = dropResult;\n\n    if (!source || !destination || !dragging) return state;\n\n    const nextEntities = reorderItem({\n      entitiesMap: state,\n      source,\n      destination,\n    });\n\n    if (componentIsResizable(nextEntities[dragging.id])) {\n      // update component width if it changed\n      const nextWidth =\n        getComponentWidthFromDrop({\n          dropResult,\n          layout: state,\n        }) || undefined; // don't set a 0 width\n      if ((nextEntities[dragging.id].meta || {}).width !== nextWidth) {\n        nextEntities[dragging.id] = {\n          ...nextEntities[dragging.id],\n          meta: {\n            ...nextEntities[dragging.id].meta,\n            width: nextWidth,\n          },\n        };\n      }\n    }\n\n    // wrap the dragged component in a row depending on destination type\n    const wrapInRow = shouldWrapChildInRow({\n      parentType: destination.type,\n      childType: dragging.type,\n    });\n\n    if (wrapInRow) {\n      const destinationEntity = nextEntities[destination.id];\n      const destinationChildren = destinationEntity.children;\n      const newRow = newComponentFactory(ROW_TYPE);\n      newRow.children = [destinationChildren[destination.index]];\n      newRow.parents = (destinationEntity.parents || []).concat(destination.id);\n      destinationChildren[destination.index] = newRow.id;\n      nextEntities[newRow.id] = newRow;\n    }\n\n    return {\n      ...state,\n      ...nextEntities,\n    };\n  },\n\n  [CREATE_TOP_LEVEL_TABS](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n    const { source, dragging } = dropResult;\n\n    // move children of current root to be children of the dragging tab\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelComponent = state[topLevelId];\n\n    if (source.id !== NEW_COMPONENTS_SOURCE_ID) {\n      // component already exists\n      const draggingTabs = state[dragging.id];\n      const draggingTabId = draggingTabs.children[0];\n      const draggingTab = state[draggingTabId];\n\n      // move all children except the one that is dragging\n      const childrenToMove = [...topLevelComponent.children].filter(\n        id => id !== dragging.id,\n      );\n\n      return {\n        ...state,\n        [DASHBOARD_ROOT_ID]: {\n          ...rootComponent,\n          children: [dragging.id],\n        },\n        [topLevelId]: {\n          ...topLevelComponent,\n          children: [],\n        },\n        [draggingTabId]: {\n          ...draggingTab,\n          children: [...draggingTab.children, ...childrenToMove],\n        },\n      };\n    }\n\n    // create new component\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n    const newEntitiesArray = Object.values(newEntities);\n    const tabComponent = newEntitiesArray.find(\n      component => component.type === TAB_TYPE,\n    );\n    const tabsComponent = newEntitiesArray.find(\n      component => component.type === TABS_TYPE,\n    );\n\n    tabComponent.children = [...topLevelComponent.children];\n    newEntities[topLevelId] = { ...topLevelComponent, children: [] };\n    newEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [tabsComponent.id],\n    };\n\n    return {\n      ...state,\n      ...newEntities,\n    };\n  },\n\n  [DELETE_TOP_LEVEL_TABS](state) {\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelTabs = state[topLevelId];\n\n    if (topLevelTabs.type !== TABS_TYPE) return state;\n\n    let childrenToMove = [];\n    const nextEntities = { ...state };\n\n    topLevelTabs.children.forEach(tabId => {\n      const tabComponent = state[tabId];\n      childrenToMove = [...childrenToMove, ...tabComponent.children];\n      delete nextEntities[tabId];\n    });\n\n    delete nextEntities[topLevelId];\n\n    nextEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [DASHBOARD_GRID_ID],\n    };\n\n    nextEntities[DASHBOARD_GRID_ID] = {\n      ...state[DASHBOARD_GRID_ID],\n      children: childrenToMove,\n    };\n\n    return nextEntities;\n  },\n\n  [UPDATE_COMPONENTS_PARENTS_LIST](state) {\n    const nextState = {\n      ...state,\n    };\n\n    updateComponentParentsList({\n      currentComponent: nextState[DASHBOARD_ROOT_ID],\n      layout: nextState,\n    });\n\n    return {\n      ...nextState,\n    };\n  },\n\n  [DASHBOARD_TITLE_CHANGED](state, action) {\n    return {\n      ...state,\n      [DASHBOARD_HEADER_ID]: {\n        ...state[DASHBOARD_HEADER_ID],\n        meta: {\n          ...state[DASHBOARD_HEADER_ID].meta,\n          text: action.text,\n        },\n      },\n    };\n  },\n};\n\nexport default function layoutReducer(state = {}, action) {\n  if (action.type in actionHandlers) {\n    const handler = actionHandlers[action.type];\n    return handler(state, action);\n  }\n\n  return state;\n}\n"]},"metadata":{},"sourceType":"module"}