{"ast":null,"code":"function _EMOTION_STRINGIFIED_CSS_ERROR__() {return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";} /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { CompactPicker } from 'react-color';\nimport Button from 'src/components/Button';\nimport {\nt,\nSupersetClient,\ngetCategoricalSchemeRegistry,\ngetChartMetadataRegistry,\nvalidateNonEmpty,\nisValidExpression } from\n'@superset-ui/core';\n\nimport SelectControl from 'src/explore/components/controls/SelectControl';\nimport TextControl from 'src/explore/components/controls/TextControl';\nimport CheckboxControl from 'src/explore/components/controls/CheckboxControl';\nimport {\nANNOTATION_SOURCE_TYPES,\nANNOTATION_TYPES,\nANNOTATION_TYPES_METADATA,\nDEFAULT_ANNOTATION_TYPE,\nrequiresQuery,\nANNOTATION_SOURCE_TYPES_METADATA } from\n'src/modules/AnnotationTypes';\nimport PopoverSection from 'src/components/PopoverSection';\nimport ControlHeader from 'src/explore/components/ControlHeader';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst AUTOMATIC_COLOR = '';\n\nconst propTypes = {\n  name: PropTypes.string,\n  annotationType: PropTypes.string,\n  sourceType: PropTypes.string,\n  color: PropTypes.string,\n  opacity: PropTypes.string,\n  style: PropTypes.string,\n  width: PropTypes.number,\n  showMarkers: PropTypes.bool,\n  hideLine: PropTypes.bool,\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  overrides: PropTypes.object,\n  show: PropTypes.bool,\n  titleColumn: PropTypes.string,\n  descriptionColumns: PropTypes.arrayOf(PropTypes.string),\n  timeColumn: PropTypes.string,\n  intervalEndColumn: PropTypes.string,\n  vizType: PropTypes.string,\n\n  error: PropTypes.string,\n  colorScheme: PropTypes.string,\n\n  addAnnotationLayer: PropTypes.func,\n  removeAnnotationLayer: PropTypes.func,\n  close: PropTypes.func };\n\n\nconst defaultProps = {\n  name: '',\n  annotationType: DEFAULT_ANNOTATION_TYPE,\n  sourceType: '',\n  color: AUTOMATIC_COLOR,\n  opacity: '',\n  style: 'solid',\n  width: 1,\n  showMarkers: false,\n  hideLine: false,\n  overrides: {},\n  colorScheme: 'd3Category10',\n  show: true,\n  titleColumn: '',\n  descriptionColumns: [],\n  timeColumn: '',\n  intervalEndColumn: '',\n\n  addAnnotationLayer: () => {},\n  removeAnnotationLayer: () => {},\n  close: () => {} };var _ref = process.env.NODE_ENV === \"production\" ? { name: \"1h52dri\", styles: \"overflow:hidden;text-overflow:ellipsis;white-space:nowrap\" } : { name: \"1jn9azd-AnnotationLayer\", styles: \"overflow:hidden;text-overflow:ellipsis;white-space:nowrap;label:AnnotationLayer;\", map: \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9teV9wbHVnaW4vc3VwZXJzZXQvc3VwZXJzZXQtZnJvbnRlbmQvc3JjL2V4cGxvcmUvY29tcG9uZW50cy9jb250cm9scy9Bbm5vdGF0aW9uTGF5ZXJDb250cm9sL0Fubm90YXRpb25MYXllci5qc3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBbVdRIiwiZmlsZSI6Ii9ob21lL3VidW50dS9teV9wbHVnaW4vc3VwZXJzZXQvc3VwZXJzZXQtZnJvbnRlbmQvc3JjL2V4cGxvcmUvY29tcG9uZW50cy9jb250cm9scy9Bbm5vdGF0aW9uTGF5ZXJDb250cm9sL0Fubm90YXRpb25MYXllci5qc3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IENvbXBhY3RQaWNrZXIgfSBmcm9tICdyZWFjdC1jb2xvcic7XG5pbXBvcnQgQnV0dG9uIGZyb20gJ3NyYy9jb21wb25lbnRzL0J1dHRvbic7XG5pbXBvcnQge1xuICB0LFxuICBTdXBlcnNldENsaWVudCxcbiAgZ2V0Q2F0ZWdvcmljYWxTY2hlbWVSZWdpc3RyeSxcbiAgZ2V0Q2hhcnRNZXRhZGF0YVJlZ2lzdHJ5LFxuICB2YWxpZGF0ZU5vbkVtcHR5LFxuICBpc1ZhbGlkRXhwcmVzc2lvbixcbn0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuXG5pbXBvcnQgU2VsZWN0Q29udHJvbCBmcm9tICdzcmMvZXhwbG9yZS9jb21wb25lbnRzL2NvbnRyb2xzL1NlbGVjdENvbnRyb2wnO1xuaW1wb3J0IFRleHRDb250cm9sIGZyb20gJ3NyYy9leHBsb3JlL2NvbXBvbmVudHMvY29udHJvbHMvVGV4dENvbnRyb2wnO1xuaW1wb3J0IENoZWNrYm94Q29udHJvbCBmcm9tICdzcmMvZXhwbG9yZS9jb21wb25lbnRzL2NvbnRyb2xzL0NoZWNrYm94Q29udHJvbCc7XG5pbXBvcnQge1xuICBBTk5PVEFUSU9OX1NPVVJDRV9UWVBFUyxcbiAgQU5OT1RBVElPTl9UWVBFUyxcbiAgQU5OT1RBVElPTl9UWVBFU19NRVRBREFUQSxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX1RZUEUsXG4gIHJlcXVpcmVzUXVlcnksXG4gIEFOTk9UQVRJT05fU09VUkNFX1RZUEVTX01FVEFEQVRBLFxufSBmcm9tICdzcmMvbW9kdWxlcy9Bbm5vdGF0aW9uVHlwZXMnO1xuaW1wb3J0IFBvcG92ZXJTZWN0aW9uIGZyb20gJ3NyYy9jb21wb25lbnRzL1BvcG92ZXJTZWN0aW9uJztcbmltcG9ydCBDb250cm9sSGVhZGVyIGZyb20gJ3NyYy9leHBsb3JlL2NvbXBvbmVudHMvQ29udHJvbEhlYWRlcic7XG5cbmNvbnN0IEFVVE9NQVRJQ19DT0xPUiA9ICcnO1xuXG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGFubm90YXRpb25UeXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzb3VyY2VUeXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgb3BhY2l0eTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3R5bGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzaG93TWFya2VyczogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVMaW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgb3ZlcnJpZGVzOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzaG93OiBQcm9wVHlwZXMuYm9vbCxcbiAgdGl0bGVDb2x1bW46IFByb3BUeXBlcy5zdHJpbmcsXG4gIGRlc2NyaXB0aW9uQ29sdW1uczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gIHRpbWVDb2x1bW46IFByb3BUeXBlcy5zdHJpbmcsXG4gIGludGVydmFsRW5kQ29sdW1uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB2aXpUeXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIGVycm9yOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb2xvclNjaGVtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICBhZGRBbm5vdGF0aW9uTGF5ZXI6IFByb3BUeXBlcy5mdW5jLFxuICByZW1vdmVBbm5vdGF0aW9uTGF5ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBjbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG59O1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIG5hbWU6ICcnLFxuICBhbm5vdGF0aW9uVHlwZTogREVGQVVMVF9BTk5PVEFUSU9OX1RZUEUsXG4gIHNvdXJjZVR5cGU6ICcnLFxuICBjb2xvcjogQVVUT01BVElDX0NPTE9SLFxuICBvcGFjaXR5OiAnJyxcbiAgc3R5bGU6ICdzb2xpZCcsXG4gIHdpZHRoOiAxLFxuICBzaG93TWFya2VyczogZmFsc2UsXG4gIGhpZGVMaW5lOiBmYWxzZSxcbiAgb3ZlcnJpZGVzOiB7fSxcbiAgY29sb3JTY2hlbWU6ICdkM0NhdGVnb3J5MTAnLFxuICBzaG93OiB0cnVlLFxuICB0aXRsZUNvbHVtbjogJycsXG4gIGRlc2NyaXB0aW9uQ29sdW1uczogW10sXG4gIHRpbWVDb2x1bW46ICcnLFxuICBpbnRlcnZhbEVuZENvbHVtbjogJycsXG5cbiAgYWRkQW5ub3RhdGlvbkxheWVyOiAoKSA9PiB7fSxcbiAgcmVtb3ZlQW5ub3RhdGlvbkxheWVyOiAoKSA9PiB7fSxcbiAgY2xvc2U6ICgpID0+IHt9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5ub3RhdGlvbkxheWVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBhbm5vdGF0aW9uVHlwZSxcbiAgICAgIHNvdXJjZVR5cGUsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHksXG4gICAgICBzdHlsZSxcbiAgICAgIHdpZHRoLFxuICAgICAgc2hvd01hcmtlcnMsXG4gICAgICBoaWRlTGluZSxcbiAgICAgIHZhbHVlLFxuICAgICAgb3ZlcnJpZGVzLFxuICAgICAgc2hvdyxcbiAgICAgIHRpdGxlQ29sdW1uLFxuICAgICAgZGVzY3JpcHRpb25Db2x1bW5zLFxuICAgICAgdGltZUNvbHVtbixcbiAgICAgIGludGVydmFsRW5kQ29sdW1uLFxuICAgICAgdml6VHlwZSxcbiAgICB9ID0gcHJvcHM7XG5cbiAgICAvLyBPbmx5IGFsbG93IG92ZXJyaWRlIHdob2xlIHRpbWVfcmFuZ2VcbiAgICBpZiAoJ3NpbmNlJyBpbiBvdmVycmlkZXMgfHwgJ3VudGlsJyBpbiBvdmVycmlkZXMpIHtcbiAgICAgIG92ZXJyaWRlcy50aW1lX3JhbmdlID0gbnVsbDtcbiAgICAgIGRlbGV0ZSBvdmVycmlkZXMuc2luY2U7XG4gICAgICBkZWxldGUgb3ZlcnJpZGVzLnVudGlsO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFubm90YXRpb25UeXBlIGlzIHN1cHBvcnRlZCBieSB0aGlzIGNoYXJ0XG4gICAgY29uc3QgbWV0YWRhdGEgPSBnZXRDaGFydE1ldGFkYXRhUmVnaXN0cnkoKS5nZXQodml6VHlwZSk7XG4gICAgY29uc3Qgc3VwcG9ydGVkQW5ub3RhdGlvblR5cGVzID0gbWV0YWRhdGE/LnN1cHBvcnRlZEFubm90YXRpb25UeXBlcyB8fCBbXTtcbiAgICBjb25zdCB2YWxpZEFubm90YXRpb25UeXBlID0gc3VwcG9ydGVkQW5ub3RhdGlvblR5cGVzLmluY2x1ZGVzKFxuICAgICAgYW5ub3RhdGlvblR5cGUsXG4gICAgKVxuICAgICAgPyBhbm5vdGF0aW9uVHlwZVxuICAgICAgOiBzdXBwb3J0ZWRBbm5vdGF0aW9uVHlwZXNbMF07XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLy8gYmFzZVxuICAgICAgbmFtZSxcbiAgICAgIGFubm90YXRpb25UeXBlOiB2YWxpZEFubm90YXRpb25UeXBlLFxuICAgICAgc291cmNlVHlwZSxcbiAgICAgIHZhbHVlLFxuICAgICAgb3ZlcnJpZGVzLFxuICAgICAgc2hvdyxcbiAgICAgIC8vIHNsaWNlXG4gICAgICB0aXRsZUNvbHVtbixcbiAgICAgIGRlc2NyaXB0aW9uQ29sdW1ucyxcbiAgICAgIHRpbWVDb2x1bW4sXG4gICAgICBpbnRlcnZhbEVuZENvbHVtbixcbiAgICAgIC8vIGRpc3BsYXlcbiAgICAgIGNvbG9yOiBjb2xvciB8fCBBVVRPTUFUSUNfQ09MT1IsXG4gICAgICBvcGFjaXR5LFxuICAgICAgc3R5bGUsXG4gICAgICB3aWR0aCxcbiAgICAgIHNob3dNYXJrZXJzLFxuICAgICAgaGlkZUxpbmUsXG4gICAgICAvLyByZWZEYXRhXG4gICAgICBpc05ldzogIW5hbWUsXG4gICAgICBpc0xvYWRpbmdPcHRpb25zOiB0cnVlLFxuICAgICAgdmFsdWVPcHRpb25zOiBbXSxcbiAgICB9O1xuICAgIHRoaXMuc3VibWl0QW5ub3RhdGlvbiA9IHRoaXMuc3VibWl0QW5ub3RhdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZGVsZXRlQW5ub3RhdGlvbiA9IHRoaXMuZGVsZXRlQW5ub3RhdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYXBwbHlBbm5vdGF0aW9uID0gdGhpcy5hcHBseUFubm90YXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmZldGNoT3B0aW9ucyA9IHRoaXMuZmV0Y2hPcHRpb25zLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVBbm5vdGF0aW9uVHlwZSA9IHRoaXMuaGFuZGxlQW5ub3RhdGlvblR5cGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUFubm90YXRpb25Tb3VyY2VUeXBlID0gdGhpcy5oYW5kbGVBbm5vdGF0aW9uU291cmNlVHlwZS5iaW5kKFxuICAgICAgdGhpcyxcbiAgICApO1xuICAgIHRoaXMuaGFuZGxlVmFsdWUgPSB0aGlzLmhhbmRsZVZhbHVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5pc1ZhbGlkRm9ybSA9IHRoaXMuaXNWYWxpZEZvcm0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgYW5ub3RhdGlvblR5cGUsIHNvdXJjZVR5cGUsIGlzTG9hZGluZ09wdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5mZXRjaE9wdGlvbnMoYW5ub3RhdGlvblR5cGUsIHNvdXJjZVR5cGUsIGlzTG9hZGluZ09wdGlvbnMpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgaWYgKHByZXZTdGF0ZS5zb3VyY2VUeXBlICE9PSB0aGlzLnN0YXRlLnNvdXJjZVR5cGUpIHtcbiAgICAgIHRoaXMuZmV0Y2hPcHRpb25zKHRoaXMuc3RhdGUuYW5ub3RhdGlvblR5cGUsIHRoaXMuc3RhdGUuc291cmNlVHlwZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U3VwcG9ydGVkU291cmNlVHlwZXMoYW5ub3RhdGlvblR5cGUpIHtcbiAgICAvLyBHZXQgdmlzIHR5cGVzIHRoYXQgY2FuIGJlIHNvdXJjZS5cbiAgICBjb25zdCBzb3VyY2VzID0gZ2V0Q2hhcnRNZXRhZGF0YVJlZ2lzdHJ5KClcbiAgICAgIC5lbnRyaWVzKClcbiAgICAgIC5maWx0ZXIoKHsgdmFsdWU6IGNoYXJ0TWV0YWRhdGEgfSkgPT5cbiAgICAgICAgY2hhcnRNZXRhZGF0YS5jYW5CZUFubm90YXRpb25UeXBlKGFubm90YXRpb25UeXBlKSxcbiAgICAgIClcbiAgICAgIC5tYXAoKHsga2V5LCB2YWx1ZTogY2hhcnRNZXRhZGF0YSB9KSA9PiAoe1xuICAgICAgICB2YWx1ZToga2V5LFxuICAgICAgICBsYWJlbDogY2hhcnRNZXRhZGF0YS5uYW1lLFxuICAgICAgfSkpO1xuICAgIC8vIFByZXBlbmQgbmF0aXZlIHNvdXJjZSBpZiBhcHBsaWNhYmxlXG4gICAgaWYgKEFOTk9UQVRJT05fVFlQRVNfTUVUQURBVEFbYW5ub3RhdGlvblR5cGVdPy5zdXBwb3J0TmF0aXZlU291cmNlKSB7XG4gICAgICBzb3VyY2VzLnVuc2hpZnQoQU5OT1RBVElPTl9TT1VSQ0VfVFlQRVNfTUVUQURBVEEuTkFUSVZFKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cblxuICBpc1ZhbGlkRm9ybXVsYUFubm90YXRpb24oZXhwcmVzc2lvbiwgYW5ub3RhdGlvblR5cGUpIHtcbiAgICBpZiAoYW5ub3RhdGlvblR5cGUgPT09IEFOTk9UQVRJT05fVFlQRVMuRk9STVVMQSkge1xuICAgICAgcmV0dXJuIGlzVmFsaWRFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzVmFsaWRGb3JtKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBhbm5vdGF0aW9uVHlwZSxcbiAgICAgIHNvdXJjZVR5cGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIHRpbWVDb2x1bW4sXG4gICAgICBpbnRlcnZhbEVuZENvbHVtbixcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBlcnJvcnMgPSBbXG4gICAgICB2YWxpZGF0ZU5vbkVtcHR5KG5hbWUpLFxuICAgICAgdmFsaWRhdGVOb25FbXB0eShhbm5vdGF0aW9uVHlwZSksXG4gICAgICB2YWxpZGF0ZU5vbkVtcHR5KHZhbHVlKSxcbiAgICBdO1xuICAgIGlmIChzb3VyY2VUeXBlICE9PSBBTk5PVEFUSU9OX1NPVVJDRV9UWVBFUy5OQVRJVkUpIHtcbiAgICAgIGlmIChhbm5vdGF0aW9uVHlwZSA9PT0gQU5OT1RBVElPTl9UWVBFUy5FVkVOVCkge1xuICAgICAgICBlcnJvcnMucHVzaCh2YWxpZGF0ZU5vbkVtcHR5KHRpbWVDb2x1bW4pKTtcbiAgICAgIH1cbiAgICAgIGlmIChhbm5vdGF0aW9uVHlwZSA9PT0gQU5OT1RBVElPTl9UWVBFUy5JTlRFUlZBTCkge1xuICAgICAgICBlcnJvcnMucHVzaCh2YWxpZGF0ZU5vbkVtcHR5KHRpbWVDb2x1bW4pKTtcbiAgICAgICAgZXJyb3JzLnB1c2godmFsaWRhdGVOb25FbXB0eShpbnRlcnZhbEVuZENvbHVtbikpO1xuICAgICAgfVxuICAgIH1cbiAgICBlcnJvcnMucHVzaCghdGhpcy5pc1ZhbGlkRm9ybXVsYUFubm90YXRpb24odmFsdWUsIGFubm90YXRpb25UeXBlKSk7XG4gICAgcmV0dXJuICFlcnJvcnMuZmlsdGVyKHggPT4geCkubGVuZ3RoO1xuICB9XG5cbiAgaGFuZGxlQW5ub3RhdGlvblR5cGUoYW5ub3RhdGlvblR5cGUpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFubm90YXRpb25UeXBlLFxuICAgICAgc291cmNlVHlwZTogbnVsbCxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlQW5ub3RhdGlvblNvdXJjZVR5cGUoc291cmNlVHlwZSkge1xuICAgIGNvbnN0IHsgc291cmNlVHlwZTogcHJldlNvdXJjZVR5cGUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAocHJldlNvdXJjZVR5cGUgIT09IHNvdXJjZVR5cGUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBzb3VyY2VUeXBlLCB2YWx1ZTogbnVsbCwgaXNMb2FkaW5nT3B0aW9uczogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsdWUsXG4gICAgICBkZXNjcmlwdGlvbkNvbHVtbnM6IFtdLFxuICAgICAgaW50ZXJ2YWxFbmRDb2x1bW46IG51bGwsXG4gICAgICB0aW1lQ29sdW1uOiBudWxsLFxuICAgICAgdGl0bGVDb2x1bW46IG51bGwsXG4gICAgICBvdmVycmlkZXM6IHsgdGltZV9yYW5nZTogbnVsbCB9LFxuICAgIH0pO1xuICB9XG5cbiAgZmV0Y2hPcHRpb25zKGFubm90YXRpb25UeXBlLCBzb3VyY2VUeXBlLCBpc0xvYWRpbmdPcHRpb25zKSB7XG4gICAgaWYgKGlzTG9hZGluZ09wdGlvbnMpIHtcbiAgICAgIGlmIChzb3VyY2VUeXBlID09PSBBTk5PVEFUSU9OX1NPVVJDRV9UWVBFUy5OQVRJVkUpIHtcbiAgICAgICAgU3VwZXJzZXRDbGllbnQuZ2V0KHtcbiAgICAgICAgICBlbmRwb2ludDogJy9hbm5vdGF0aW9ubGF5ZXJtb2RlbHZpZXcvYXBpL3JlYWQ/JyxcbiAgICAgICAgfSkudGhlbigoeyBqc29uIH0pID0+IHtcbiAgICAgICAgICBjb25zdCBsYXllcnMgPSBqc29uXG4gICAgICAgICAgICA/IGpzb24ucmVzdWx0Lm1hcChsYXllciA9PiAoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsYXllci5pZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogbGF5ZXIubmFtZSxcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXNMb2FkaW5nT3B0aW9uczogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZU9wdGlvbnM6IGxheWVycyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVpcmVzUXVlcnkoc291cmNlVHlwZSkpIHtcbiAgICAgICAgU3VwZXJzZXRDbGllbnQuZ2V0KHsgZW5kcG9pbnQ6ICcvc3VwZXJzZXQvdXNlcl9zbGljZXMnIH0pLnRoZW4oXG4gICAgICAgICAgKHsganNvbiB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWdpc3RyeSA9IGdldENoYXJ0TWV0YWRhdGFSZWdpc3RyeSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIGlzTG9hZGluZ09wdGlvbnM6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZU9wdGlvbnM6IGpzb25cbiAgICAgICAgICAgICAgICAuZmlsdGVyKHggPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSByZWdpc3RyeS5nZXQoeC52aXpfdHlwZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSAmJiBtZXRhZGF0YS5jYW5CZUFubm90YXRpb25UeXBlKGFubm90YXRpb25UeXBlKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoeCA9PiAoeyB2YWx1ZTogeC5pZCwgbGFiZWw6IHgudGl0bGUsIHNsaWNlOiB4IH0pKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpc0xvYWRpbmdPcHRpb25zOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZU9wdGlvbnM6IFtdLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWxldGVBbm5vdGF0aW9uKCkge1xuICAgIHRoaXMucHJvcHMucmVtb3ZlQW5ub3RhdGlvbkxheWVyKCk7XG4gICAgdGhpcy5wcm9wcy5jbG9zZSgpO1xuICB9XG5cbiAgYXBwbHlBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWRGb3JtKCkpIHtcbiAgICAgIGNvbnN0IGFubm90YXRpb25GaWVsZHMgPSBbXG4gICAgICAgICduYW1lJyxcbiAgICAgICAgJ2Fubm90YXRpb25UeXBlJyxcbiAgICAgICAgJ3NvdXJjZVR5cGUnLFxuICAgICAgICAnY29sb3InLFxuICAgICAgICAnb3BhY2l0eScsXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgICd3aWR0aCcsXG4gICAgICAgICdzaG93TWFya2VycycsXG4gICAgICAgICdoaWRlTGluZScsXG4gICAgICAgICd2YWx1ZScsXG4gICAgICAgICdvdmVycmlkZXMnLFxuICAgICAgICAnc2hvdycsXG4gICAgICAgICd0aXRsZUNvbHVtbicsXG4gICAgICAgICdkZXNjcmlwdGlvbkNvbHVtbnMnLFxuICAgICAgICAndGltZUNvbHVtbicsXG4gICAgICAgICdpbnRlcnZhbEVuZENvbHVtbicsXG4gICAgICBdO1xuICAgICAgY29uc3QgbmV3QW5ub3RhdGlvbiA9IHt9O1xuICAgICAgYW5ub3RhdGlvbkZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVbZmllbGRdICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV3QW5ub3RhdGlvbltmaWVsZF0gPSB0aGlzLnN0YXRlW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZXdBbm5vdGF0aW9uLmNvbG9yID09PSBBVVRPTUFUSUNfQ09MT1IpIHtcbiAgICAgICAgbmV3QW5ub3RhdGlvbi5jb2xvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMuYWRkQW5ub3RhdGlvbkxheWVyKG5ld0Fubm90YXRpb24pO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzTmV3OiBmYWxzZSB9KTtcbiAgICB9XG4gIH1cblxuICBzdWJtaXRBbm5vdGF0aW9uKCkge1xuICAgIHRoaXMuYXBwbHlBbm5vdGF0aW9uKCk7XG4gICAgdGhpcy5wcm9wcy5jbG9zZSgpO1xuICB9XG5cbiAgcmVuZGVyT3B0aW9uKG9wdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICA8c3BhblxuICAgICAgICBjc3M9e3tcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgICB9fVxuICAgICAgICB0aXRsZT17b3B0aW9uLmxhYmVsfVxuICAgICAgPlxuICAgICAgICB7b3B0aW9uLmxhYmVsfVxuICAgICAgPC9zcGFuPlxuICAgICk7XG4gIH1cblxuICByZW5kZXJWYWx1ZUNvbmZpZ3VyYXRpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvblR5cGUsXG4gICAgICBzb3VyY2VUeXBlLFxuICAgICAgdmFsdWUsXG4gICAgICB2YWx1ZU9wdGlvbnMsXG4gICAgICBpc0xvYWRpbmdPcHRpb25zLFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBsYWJlbCA9ICcnO1xuICAgIGxldCBkZXNjcmlwdGlvbiA9ICcnO1xuICAgIGlmIChyZXF1aXJlc1F1ZXJ5KHNvdXJjZVR5cGUpKSB7XG4gICAgICBpZiAoc291cmNlVHlwZSA9PT0gQU5OT1RBVElPTl9TT1VSQ0VfVFlQRVMuTkFUSVZFKSB7XG4gICAgICAgIGxhYmVsID0gJ0Fubm90YXRpb24gbGF5ZXInO1xuICAgICAgICBkZXNjcmlwdGlvbiA9ICdTZWxlY3QgdGhlIEFubm90YXRpb24gTGF5ZXIgeW91IHdvdWxkIGxpa2UgdG8gdXNlLic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbCA9IHQoJ0NoYXJ0Jyk7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gYFVzZSBhIHByZSBkZWZpbmVkIFN1cGVyc2V0IENoYXJ0IGFzIGEgc291cmNlIGZvciBhbm5vdGF0aW9ucyBhbmQgb3ZlcmxheXMuXG4gICAgICAgIHlvdXIgY2hhcnQgbXVzdCBiZSBvbmUgb2YgdGhlc2UgdmlzdWFsaXphdGlvbiB0eXBlczpcbiAgICAgICAgWyR7dGhpcy5nZXRTdXBwb3J0ZWRTb3VyY2VUeXBlcyhhbm5vdGF0aW9uVHlwZSlcbiAgICAgICAgICAubWFwKHggPT4geC5sYWJlbClcbiAgICAgICAgICAuam9pbignLCAnKX1dYDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFubm90YXRpb25UeXBlID09PSBBTk5PVEFUSU9OX1RZUEVTLkZPUk1VTEEpIHtcbiAgICAgIGxhYmVsID0gJ0Zvcm11bGEnO1xuICAgICAgZGVzY3JpcHRpb24gPSBgRXhwZWN0cyBhIGZvcm11bGEgd2l0aCBkZXBlbmRpbmcgdGltZSBwYXJhbWV0ZXIgJ3gnXG4gICAgICAgIGluIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC4gbWF0aGpzIGlzIHVzZWQgdG8gZXZhbHVhdGUgdGhlIGZvcm11bGFzLlxuICAgICAgICBFeGFtcGxlOiAnMngrNSdgO1xuICAgIH1cbiAgICBpZiAocmVxdWlyZXNRdWVyeShzb3VyY2VUeXBlKSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPFNlbGVjdENvbnRyb2xcbiAgICAgICAgICBhcmlhTGFiZWw9e3QoJ0Fubm90YXRpb24gbGF5ZXIgdmFsdWUnKX1cbiAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci12YWx1ZVwiXG4gICAgICAgICAgc2hvd0hlYWRlclxuICAgICAgICAgIGhvdmVyZWRcbiAgICAgICAgICBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259XG4gICAgICAgICAgbGFiZWw9e2xhYmVsfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiXCJcbiAgICAgICAgICBvcHRpb25zPXt2YWx1ZU9wdGlvbnN9XG4gICAgICAgICAgaXNMb2FkaW5nPXtpc0xvYWRpbmdPcHRpb25zfVxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVWYWx1ZX1cbiAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzPXshdmFsdWUgPyBbJ01hbmRhdG9yeSddIDogW119XG4gICAgICAgICAgb3B0aW9uUmVuZGVyZXI9e3RoaXMucmVuZGVyT3B0aW9ufVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGFubm90YXRpb25UeXBlID09PSBBTk5PVEFUSU9OX1RZUEVTLkZPUk1VTEEpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxUZXh0Q29udHJvbFxuICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLWxheWVyLXZhbHVlXCJcbiAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgc2hvd0hlYWRlclxuICAgICAgICAgIGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn1cbiAgICAgICAgICBsYWJlbD17bGFiZWx9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJcIlxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVWYWx1ZX1cbiAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzPXtcbiAgICAgICAgICAgICF0aGlzLmlzVmFsaWRGb3JtdWxhQW5ub3RhdGlvbih2YWx1ZSwgYW5ub3RhdGlvblR5cGUpXG4gICAgICAgICAgICAgID8gWydCYWQgZm9ybXVsYS4nXVxuICAgICAgICAgICAgICA6IFtdXG4gICAgICAgICAgfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmVuZGVyU2xpY2VDb25maWd1cmF0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25UeXBlLFxuICAgICAgc291cmNlVHlwZSxcbiAgICAgIHZhbHVlLFxuICAgICAgdmFsdWVPcHRpb25zLFxuICAgICAgb3ZlcnJpZGVzLFxuICAgICAgdGl0bGVDb2x1bW4sXG4gICAgICB0aW1lQ29sdW1uLFxuICAgICAgaW50ZXJ2YWxFbmRDb2x1bW4sXG4gICAgICBkZXNjcmlwdGlvbkNvbHVtbnMsXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBzbGljZSB9ID0gdmFsdWVPcHRpb25zLmZpbmQoeCA9PiB4LnZhbHVlID09PSB2YWx1ZSkgfHwge307XG4gICAgaWYgKHNvdXJjZVR5cGUgIT09IEFOTk9UQVRJT05fU09VUkNFX1RZUEVTLk5BVElWRSAmJiBzbGljZSkge1xuICAgICAgY29uc3QgY29sdW1ucyA9IChzbGljZS5kYXRhLmdyb3VwYnkgfHwgW10pXG4gICAgICAgIC5jb25jYXQoc2xpY2UuZGF0YS5hbGxfY29sdW1ucyB8fCBbXSlcbiAgICAgICAgLm1hcCh4ID0+ICh7IHZhbHVlOiB4LCBsYWJlbDogeCB9KSk7XG4gICAgICBjb25zdCB0aW1lQ29sdW1uT3B0aW9ucyA9IHNsaWNlLmRhdGEuaW5jbHVkZV90aW1lXG4gICAgICAgID8gW3sgdmFsdWU6ICdfX3RpbWVzdGFtcCcsIGxhYmVsOiAnX190aW1lc3RhbXAnIH1dLmNvbmNhdChjb2x1bW5zKVxuICAgICAgICA6IGNvbHVtbnM7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpblJpZ2h0OiAnMnJlbScgfX0+XG4gICAgICAgICAgPFBvcG92ZXJTZWN0aW9uXG4gICAgICAgICAgICBpc1NlbGVjdGVkXG4gICAgICAgICAgICB0aXRsZT17dCgnQW5ub3RhdGlvbiBTbGljZSBDb25maWd1cmF0aW9uJyl9XG4gICAgICAgICAgICBpbmZvPXt0KGBUaGlzIHNlY3Rpb24gYWxsb3dzIHlvdSB0byBjb25maWd1cmUgaG93IHRvIHVzZSB0aGUgc2xpY2VcbiAgICAgICAgICAgICAgIHRvIGdlbmVyYXRlIGFubm90YXRpb25zLmApfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHsoYW5ub3RhdGlvblR5cGUgPT09IEFOTk9UQVRJT05fVFlQRVMuRVZFTlQgfHxcbiAgICAgICAgICAgICAgYW5ub3RhdGlvblR5cGUgPT09IEFOTk9UQVRJT05fVFlQRVMuSU5URVJWQUwpICYmIChcbiAgICAgICAgICAgICAgPFNlbGVjdENvbnRyb2xcbiAgICAgICAgICAgICAgICBhcmlhTGFiZWw9e3QoJ0Fubm90YXRpb24gbGF5ZXIgdGltZSBjb2x1bW4nKX1cbiAgICAgICAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItdGltZS1jb2x1bW5cIlxuICAgICAgICAgICAgICAgIGxhYmVsPXtcbiAgICAgICAgICAgICAgICAgIGFubm90YXRpb25UeXBlID09PSBBTk5PVEFUSU9OX1RZUEVTLklOVEVSVkFMXG4gICAgICAgICAgICAgICAgICAgID8gdCgnSW50ZXJ2YWwgc3RhcnQgY29sdW1uJylcbiAgICAgICAgICAgICAgICAgICAgOiB0KCdFdmVudCB0aW1lIGNvbHVtbicpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXt0KFxuICAgICAgICAgICAgICAgICAgJ1RoaXMgY29sdW1uIG11c3QgY29udGFpbiBkYXRlL3RpbWUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnM9eyF0aW1lQ29sdW1uID8gWydNYW5kYXRvcnknXSA6IFtdfVxuICAgICAgICAgICAgICAgIGNsZWFyYWJsZT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17dGltZUNvbHVtbk9wdGlvbnN9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3RpbWVDb2x1bW59XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3YgPT4gdGhpcy5zZXRTdGF0ZSh7IHRpbWVDb2x1bW46IHYgfSl9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge2Fubm90YXRpb25UeXBlID09PSBBTk5PVEFUSU9OX1RZUEVTLklOVEVSVkFMICYmIChcbiAgICAgICAgICAgICAgPFNlbGVjdENvbnRyb2xcbiAgICAgICAgICAgICAgICBhcmlhTGFiZWw9e3QoJ0Fubm90YXRpb24gbGF5ZXIgaW50ZXJ2YWwgZW5kJyl9XG4gICAgICAgICAgICAgICAgaG92ZXJlZFxuICAgICAgICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLWxheWVyLWludGVydmFsRW5kXCJcbiAgICAgICAgICAgICAgICBsYWJlbD17dCgnSW50ZXJ2YWwgRW5kIGNvbHVtbicpfVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXt0KFxuICAgICAgICAgICAgICAgICAgJ1RoaXMgY29sdW1uIG11c3QgY29udGFpbiBkYXRlL3RpbWUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnM9eyFpbnRlcnZhbEVuZENvbHVtbiA/IFsnTWFuZGF0b3J5J10gOiBbXX1cbiAgICAgICAgICAgICAgICBvcHRpb25zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgIHZhbHVlPXtpbnRlcnZhbEVuZENvbHVtbn1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IGludGVydmFsRW5kQ29sdW1uOiB2YWx1ZSB9KX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8U2VsZWN0Q29udHJvbFxuICAgICAgICAgICAgICBhcmlhTGFiZWw9e3QoJ0Fubm90YXRpb24gbGF5ZXIgdGl0bGUgY29sdW1uJyl9XG4gICAgICAgICAgICAgIGhvdmVyZWRcbiAgICAgICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItdGl0bGVcIlxuICAgICAgICAgICAgICBsYWJlbD17dCgnVGl0bGUgQ29sdW1uJyl9XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXt0KCdQaWNrIGEgdGl0bGUgZm9yIHlvdSBhbm5vdGF0aW9uLicpfVxuICAgICAgICAgICAgICBvcHRpb25zPXtbeyB2YWx1ZTogJycsIGxhYmVsOiAnTm9uZScgfV0uY29uY2F0KGNvbHVtbnMpfVxuICAgICAgICAgICAgICB2YWx1ZT17dGl0bGVDb2x1bW59XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgdGl0bGVDb2x1bW46IHZhbHVlIH0pfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHthbm5vdGF0aW9uVHlwZSAhPT0gQU5OT1RBVElPTl9UWVBFUy5USU1FX1NFUklFUyAmJiAoXG4gICAgICAgICAgICAgIDxTZWxlY3RDb250cm9sXG4gICAgICAgICAgICAgICAgYXJpYUxhYmVsPXt0KCdBbm5vdGF0aW9uIGxheWVyIGRlc2NyaXB0aW9uIGNvbHVtbnMnKX1cbiAgICAgICAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItdGl0bGVcIlxuICAgICAgICAgICAgICAgIGxhYmVsPXt0KCdEZXNjcmlwdGlvbiBDb2x1bW5zJyl9XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb249e3QoXG4gICAgICAgICAgICAgICAgICBcIlBpY2sgb25lIG9yIG1vcmUgY29sdW1ucyB0aGF0IHNob3VsZCBiZSBzaG93biBpbiB0aGUgYW5ub3RhdGlvbi4gSWYgeW91IGRvbid0IHNlbGVjdCBhIGNvbHVtbiBhbGwgb2YgdGhlbSB3aWxsIGJlIHNob3duLlwiLFxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgbXVsdGlcbiAgICAgICAgICAgICAgICBvcHRpb25zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgIHZhbHVlPXtkZXNjcmlwdGlvbkNvbHVtbnN9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3ZhbHVlID0+IHRoaXMuc2V0U3RhdGUoeyBkZXNjcmlwdGlvbkNvbHVtbnM6IHZhbHVlIH0pfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luVG9wOiAnMXJlbScgfX0+XG4gICAgICAgICAgICAgIDxDaGVja2JveENvbnRyb2xcbiAgICAgICAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgICAgICAgbmFtZT1cImFubm90YXRpb24tb3ZlcnJpZGUtdGltZV9yYW5nZVwiXG4gICAgICAgICAgICAgICAgbGFiZWw9XCJPdmVycmlkZSB0aW1lIHJhbmdlXCJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbj17YFRoaXMgY29udHJvbHMgd2hldGhlciB0aGUgXCJ0aW1lX3JhbmdlXCIgZmllbGQgZnJvbSB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgdmlldyBzaG91bGQgYmUgcGFzc2VkIGRvd24gdG8gdGhlIGNoYXJ0IGNvbnRhaW5pbmcgdGhlIGFubm90YXRpb24gZGF0YS5gfVxuICAgICAgICAgICAgICAgIHZhbHVlPXsndGltZV9yYW5nZScgaW4gb3ZlcnJpZGVzfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2ID0+IHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMudGltZV9yYW5nZTtcbiAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlczogeyAuLi5vdmVycmlkZXMsIHRpbWVfcmFuZ2U6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgb3ZlcnJpZGVzOiB7IC4uLm92ZXJyaWRlcyB9IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxDaGVja2JveENvbnRyb2xcbiAgICAgICAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgICAgICAgbmFtZT1cImFubm90YXRpb24tb3ZlcnJpZGUtdGltZWdyYWluXCJcbiAgICAgICAgICAgICAgICBsYWJlbD1cIk92ZXJyaWRlIHRpbWUgZ3JhaW5cIlxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtgVGhpcyBjb250cm9scyB3aGV0aGVyIHRoZSB0aW1lIGdyYWluIGZpZWxkIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgIHZpZXcgc2hvdWxkIGJlIHBhc3NlZCBkb3duIHRvIHRoZSBjaGFydCBjb250YWluaW5nIHRoZSBhbm5vdGF0aW9uIGRhdGEuYH1cbiAgICAgICAgICAgICAgICB2YWx1ZT17J3RpbWVfZ3JhaW5fc3FsYScgaW4gb3ZlcnJpZGVzfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2ID0+IHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMudGltZV9ncmFpbl9zcWxhO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5ncmFudWxhcml0eTtcbiAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3ZlcnJpZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZV9ncmFpbl9zcWxhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbnVsYXJpdHk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgb3ZlcnJpZGVzOiB7IC4uLm92ZXJyaWRlcyB9IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxUZXh0Q29udHJvbFxuICAgICAgICAgICAgICAgIGhvdmVyZWRcbiAgICAgICAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci10aW1lc2hpZnRcIlxuICAgICAgICAgICAgICAgIGxhYmVsPVwiVGltZSBTaGlmdFwiXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb249e2BUaW1lIGRlbHRhIGluIG5hdHVyYWwgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgIChleGFtcGxlOiAgMjQgaG91cnMsIDcgZGF5cywgNTYgd2Vla3MsIDM2NSBkYXlzKWB9XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtvdmVycmlkZXMudGltZV9zaGlmdH1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17diA9PlxuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG92ZXJyaWRlczogeyAuLi5vdmVycmlkZXMsIHRpbWVfc2hpZnQ6IHYgfSB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvUG9wb3ZlclNlY3Rpb24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmVuZGVyRGlzcGxheUNvbmZpZ3VyYXRpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5LFxuICAgICAgc3R5bGUsXG4gICAgICB3aWR0aCxcbiAgICAgIHNob3dNYXJrZXJzLFxuICAgICAgaGlkZUxpbmUsXG4gICAgICBhbm5vdGF0aW9uVHlwZSxcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb2xvclNjaGVtZSA9IGdldENhdGVnb3JpY2FsU2NoZW1lUmVnaXN0cnkoKVxuICAgICAgLmdldCh0aGlzLnByb3BzLmNvbG9yU2NoZW1lKVxuICAgICAgLmNvbG9ycy5jb25jYXQoKTtcbiAgICBpZiAoXG4gICAgICBjb2xvciAmJlxuICAgICAgY29sb3IgIT09IEFVVE9NQVRJQ19DT0xPUiAmJlxuICAgICAgIWNvbG9yU2NoZW1lLmZpbmQoeCA9PiB4LnRvTG93ZXJDYXNlKCkgPT09IGNvbG9yLnRvTG93ZXJDYXNlKCkpXG4gICAgKSB7XG4gICAgICBjb2xvclNjaGVtZS5wdXNoKGNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIDxQb3BvdmVyU2VjdGlvblxuICAgICAgICBpc1NlbGVjdGVkXG4gICAgICAgIHRpdGxlPXt0KCdEaXNwbGF5IGNvbmZpZ3VyYXRpb24nKX1cbiAgICAgICAgaW5mbz17dCgnQ29uZmlndXJlIHlvdXIgaG93IHlvdSBvdmVybGF5IGlzIGRpc3BsYXllZCBoZXJlLicpfVxuICAgICAgPlxuICAgICAgICA8U2VsZWN0Q29udHJvbFxuICAgICAgICAgIGFyaWFMYWJlbD17dCgnQW5ub3RhdGlvbiBsYXllciBzdHJva2UnKX1cbiAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci1zdHJva2VcIlxuICAgICAgICAgIGxhYmVsPXt0KCdTdHlsZScpfVxuICAgICAgICAgIC8vIHNlZSAnLi4vLi4vLi4vdmlzdWFsaXphdGlvbnMvbnZkM192aXMuY3NzJ1xuICAgICAgICAgIG9wdGlvbnM9e1tcbiAgICAgICAgICAgIHsgdmFsdWU6ICdzb2xpZCcsIGxhYmVsOiAnU29saWQnIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiAnZGFzaGVkJywgbGFiZWw6ICdEYXNoZWQnIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiAnbG9uZ0Rhc2hlZCcsIGxhYmVsOiAnTG9uZyBkYXNoZWQnIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiAnZG90dGVkJywgbGFiZWw6ICdEb3R0ZWQnIH0sXG4gICAgICAgICAgXX1cbiAgICAgICAgICB2YWx1ZT17c3R5bGV9XG4gICAgICAgICAgY2xlYXJhYmxlPXtmYWxzZX1cbiAgICAgICAgICBvbkNoYW5nZT17diA9PiB0aGlzLnNldFN0YXRlKHsgc3R5bGU6IHYgfSl9XG4gICAgICAgIC8+XG4gICAgICAgIDxTZWxlY3RDb250cm9sXG4gICAgICAgICAgYXJpYUxhYmVsPXt0KCdBbm5vdGF0aW9uIGxheWVyIG9wYWNpdHknKX1cbiAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci1vcGFjaXR5XCJcbiAgICAgICAgICBsYWJlbD17dCgnT3BhY2l0eScpfVxuICAgICAgICAgIC8vIHNlZSAnLi4vLi4vLi4vdmlzdWFsaXphdGlvbnMvbnZkM192aXMuY3NzJ1xuICAgICAgICAgIG9wdGlvbnM9e1tcbiAgICAgICAgICAgIHsgdmFsdWU6ICcnLCBsYWJlbDogJ1NvbGlkJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogJ29wYWNpdHlMb3cnLCBsYWJlbDogJzAuMicgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6ICdvcGFjaXR5TWVkaXVtJywgbGFiZWw6ICcwLjUnIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiAnb3BhY2l0eUhpZ2gnLCBsYWJlbDogJzAuOCcgfSxcbiAgICAgICAgICBdfVxuICAgICAgICAgIHZhbHVlPXtvcGFjaXR5fVxuICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgb3BhY2l0eTogdmFsdWUgfSl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPENvbnRyb2xIZWFkZXIgbGFiZWw9e3QoJ0NvbG9yJyl9IC8+XG4gICAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nIH19PlxuICAgICAgICAgICAgPENvbXBhY3RQaWNrZXJcbiAgICAgICAgICAgICAgY29sb3I9e2NvbG9yfVxuICAgICAgICAgICAgICBjb2xvcnM9e2NvbG9yU2NoZW1lfVxuICAgICAgICAgICAgICBvbkNoYW5nZUNvbXBsZXRlPXt2ID0+IHRoaXMuc2V0U3RhdGUoeyBjb2xvcjogdi5oZXggfSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICBzdHlsZT17eyBtYXJnaW5Ub3A6ICcwLjVyZW0nLCBtYXJnaW5Cb3R0b206ICcwLjVyZW0nIH19XG4gICAgICAgICAgICAgIGJ1dHRvblN0eWxlPXtjb2xvciA9PT0gQVVUT01BVElDX0NPTE9SID8gJ3N1Y2Nlc3MnIDogJ2RlZmF1bHQnfVxuICAgICAgICAgICAgICBidXR0b25TaXplPVwieHNtYWxsXCJcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGNvbG9yOiBBVVRPTUFUSUNfQ09MT1IgfSl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIEF1dG9tYXRpYyBDb2xvclxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8VGV4dENvbnRyb2xcbiAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci1zdHJva2Utd2lkdGhcIlxuICAgICAgICAgIGxhYmVsPXt0KCdMaW5lIHdpZHRoJyl9XG4gICAgICAgICAgaXNJbnRcbiAgICAgICAgICB2YWx1ZT17d2lkdGh9XG4gICAgICAgICAgb25DaGFuZ2U9e3YgPT4gdGhpcy5zZXRTdGF0ZSh7IHdpZHRoOiB2IH0pfVxuICAgICAgICAvPlxuICAgICAgICB7YW5ub3RhdGlvblR5cGUgPT09IEFOTk9UQVRJT05fVFlQRVMuVElNRV9TRVJJRVMgJiYgKFxuICAgICAgICAgIDxDaGVja2JveENvbnRyb2xcbiAgICAgICAgICAgIGhvdmVyZWRcbiAgICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLWxheWVyLXNob3ctbWFya2Vyc1wiXG4gICAgICAgICAgICBsYWJlbD1cIlNob3cgTWFya2Vyc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj1cIlNob3dzIG9yIGhpZGVzIG1hcmtlcnMgZm9yIHRoZSB0aW1lIHNlcmllc1wiXG4gICAgICAgICAgICB2YWx1ZT17c2hvd01hcmtlcnN9XG4gICAgICAgICAgICBvbkNoYW5nZT17diA9PiB0aGlzLnNldFN0YXRlKHsgc2hvd01hcmtlcnM6IHYgfSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgICAge2Fubm90YXRpb25UeXBlID09PSBBTk5PVEFUSU9OX1RZUEVTLlRJTUVfU0VSSUVTICYmIChcbiAgICAgICAgICA8Q2hlY2tib3hDb250cm9sXG4gICAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci1oaWRlLWxpbmVcIlxuICAgICAgICAgICAgbGFiZWw9XCJIaWRlIExpbmVcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249XCJIaWRlcyB0aGUgTGluZSBmb3IgdGhlIHRpbWUgc2VyaWVzXCJcbiAgICAgICAgICAgIHZhbHVlPXtoaWRlTGluZX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXt2ID0+IHRoaXMuc2V0U3RhdGUoeyBoaWRlTGluZTogdiB9KX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC9Qb3BvdmVyU2VjdGlvbj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaXNOZXcsIG5hbWUsIGFubm90YXRpb25UeXBlLCBzb3VyY2VUeXBlLCBzaG93IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGlzVmFsaWQgPSB0aGlzLmlzVmFsaWRGb3JtKCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBnZXRDaGFydE1ldGFkYXRhUmVnaXN0cnkoKS5nZXQodGhpcy5wcm9wcy52aXpUeXBlKTtcbiAgICBjb25zdCBzdXBwb3J0ZWRBbm5vdGF0aW9uVHlwZXMgPSBtZXRhZGF0YVxuICAgICAgPyBtZXRhZGF0YS5zdXBwb3J0ZWRBbm5vdGF0aW9uVHlwZXMubWFwKFxuICAgICAgICAgIHR5cGUgPT4gQU5OT1RBVElPTl9UWVBFU19NRVRBREFUQVt0eXBlXSxcbiAgICAgICAgKVxuICAgICAgOiBbXTtcbiAgICBjb25zdCBzdXBwb3J0ZWRTb3VyY2VUeXBlcyA9IHRoaXMuZ2V0U3VwcG9ydGVkU291cmNlVHlwZXMoYW5ub3RhdGlvblR5cGUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDw+XG4gICAgICAgIHt0aGlzLnByb3BzLmVycm9yICYmIChcbiAgICAgICAgICA8c3BhbiBzdHlsZT17eyBjb2xvcjogJ3JlZCcgfX0+RVJST1I6IHt0aGlzLnByb3BzLmVycm9yfTwvc3Bhbj5cbiAgICAgICAgKX1cbiAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGZsZXhEaXJlY3Rpb246ICdyb3cnIH19PlxuICAgICAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luUmlnaHQ6ICcycmVtJyB9fT5cbiAgICAgICAgICAgIDxQb3BvdmVyU2VjdGlvblxuICAgICAgICAgICAgICBpc1NlbGVjdGVkXG4gICAgICAgICAgICAgIHRpdGxlPXt0KCdMYXllciBjb25maWd1cmF0aW9uJyl9XG4gICAgICAgICAgICAgIGluZm89e3QoJ0NvbmZpZ3VyZSB0aGUgYmFzaWNzIG9mIHlvdXIgQW5ub3RhdGlvbiBMYXllci4nKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPFRleHRDb250cm9sXG4gICAgICAgICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItbmFtZVwiXG4gICAgICAgICAgICAgICAgbGFiZWw9e3QoJ05hbWUnKX1cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlwiXG4gICAgICAgICAgICAgICAgdmFsdWU9e25hbWV9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3YgPT4gdGhpcy5zZXRTdGF0ZSh7IG5hbWU6IHYgfSl9XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9ycz17IW5hbWUgPyBbdCgnTWFuZGF0b3J5JyldIDogW119XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxDaGVja2JveENvbnRyb2xcbiAgICAgICAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci1oaWRlXCJcbiAgICAgICAgICAgICAgICBsYWJlbD17dCgnSGlkZSBsYXllcicpfVxuICAgICAgICAgICAgICAgIHZhbHVlPXshc2hvd31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17diA9PiB0aGlzLnNldFN0YXRlKHsgc2hvdzogIXYgfSl9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxTZWxlY3RDb250cm9sXG4gICAgICAgICAgICAgICAgYXJpYUxhYmVsPXt0KCdBbm5vdGF0aW9uIGxheWVyIHR5cGUnKX1cbiAgICAgICAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb249e3QoJ0Nob29zZSB0aGUgYW5ub3RhdGlvbiBsYXllciB0eXBlJyl9XG4gICAgICAgICAgICAgICAgbGFiZWw9e3QoJ0Fubm90YXRpb24gbGF5ZXIgdHlwZScpfVxuICAgICAgICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLWxheWVyLXR5cGVcIlxuICAgICAgICAgICAgICAgIGNsZWFyYWJsZT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17c3VwcG9ydGVkQW5ub3RhdGlvblR5cGVzfVxuICAgICAgICAgICAgICAgIHZhbHVlPXthbm5vdGF0aW9uVHlwZX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVBbm5vdGF0aW9uVHlwZX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAge3N1cHBvcnRlZFNvdXJjZVR5cGVzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgICAgIDxTZWxlY3RDb250cm9sXG4gICAgICAgICAgICAgICAgICBhcmlhTGFiZWw9e3QoJ0Fubm90YXRpb24gc291cmNlIHR5cGUnKX1cbiAgICAgICAgICAgICAgICAgIGhvdmVyZWRcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXt0KCdDaG9vc2UgdGhlIHNvdXJjZSBvZiB5b3VyIGFubm90YXRpb25zJyl9XG4gICAgICAgICAgICAgICAgICBsYWJlbD17dCgnQW5ub3RhdGlvbiBTb3VyY2UnKX1cbiAgICAgICAgICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLXNvdXJjZS10eXBlXCJcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e3N1cHBvcnRlZFNvdXJjZVR5cGVzfVxuICAgICAgICAgICAgICAgICAgdmFsdWU9e3NvdXJjZVR5cGV9XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVBbm5vdGF0aW9uU291cmNlVHlwZX1cbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnM9eyFzb3VyY2VUeXBlID8gW3QoJ01hbmRhdG9yeScpXSA6IFtdfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIHt0aGlzLnJlbmRlclZhbHVlQ29uZmlndXJhdGlvbigpfVxuICAgICAgICAgICAgPC9Qb3BvdmVyU2VjdGlvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7dGhpcy5yZW5kZXJTbGljZUNvbmZpZ3VyYXRpb24oKX1cbiAgICAgICAgICB7dGhpcy5yZW5kZXJEaXNwbGF5Q29uZmlndXJhdGlvbigpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicgfX0+XG4gICAgICAgICAge2lzTmV3ID8gKFxuICAgICAgICAgICAgPEJ1dHRvbiBidXR0b25TaXplPVwic21hbGxcIiBvbkNsaWNrPXsoKSA9PiB0aGlzLnByb3BzLmNsb3NlKCl9PlxuICAgICAgICAgICAgICB7dCgnQ2FuY2VsJyl9XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgPEJ1dHRvbiBidXR0b25TaXplPVwic21hbGxcIiBvbkNsaWNrPXt0aGlzLmRlbGV0ZUFubm90YXRpb259PlxuICAgICAgICAgICAgICB7dCgnUmVtb3ZlJyl9XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIGJ1dHRvblNpemU9XCJzbWFsbFwiXG4gICAgICAgICAgICAgIGRpc2FibGVkPXshaXNWYWxpZH1cbiAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5hcHBseUFubm90YXRpb259XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHt0KCdBcHBseScpfVxuICAgICAgICAgICAgPC9CdXR0b24+XG5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgYnV0dG9uU2l6ZT1cInNtYWxsXCJcbiAgICAgICAgICAgICAgYnV0dG9uU3R5bGU9XCJwcmltYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFpc1ZhbGlkfVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLnN1Ym1pdEFubm90YXRpb259XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHt0KCdPSycpfVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC8+XG4gICAgKTtcbiAgfVxufVxuXG5Bbm5vdGF0aW9uTGF5ZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuQW5ub3RhdGlvbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ== */\", toString: _EMOTION_STRINGIFIED_CSS_ERROR__ };\n\n\nexport default class AnnotationLayer extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    const {\n      name,\n      annotationType,\n      sourceType,\n      color,\n      opacity,\n      style,\n      width,\n      showMarkers,\n      hideLine,\n      value,\n      overrides,\n      show,\n      titleColumn,\n      descriptionColumns,\n      timeColumn,\n      intervalEndColumn,\n      vizType } =\n    props;\n\n    // Only allow override whole time_range\n    if ('since' in overrides || 'until' in overrides) {\n      overrides.time_range = null;\n      delete overrides.since;\n      delete overrides.until;\n    }\n\n    // Check if annotationType is supported by this chart\n    const metadata = getChartMetadataRegistry().get(vizType);\n    const supportedAnnotationTypes = (metadata == null ? void 0 : metadata.supportedAnnotationTypes) || [];\n    const validAnnotationType = supportedAnnotationTypes.includes(\n    annotationType) ?\n\n    annotationType :\n    supportedAnnotationTypes[0];\n\n    this.state = {\n      // base\n      name,\n      annotationType: validAnnotationType,\n      sourceType,\n      value,\n      overrides,\n      show,\n      // slice\n      titleColumn,\n      descriptionColumns,\n      timeColumn,\n      intervalEndColumn,\n      // display\n      color: color || AUTOMATIC_COLOR,\n      opacity,\n      style,\n      width,\n      showMarkers,\n      hideLine,\n      // refData\n      isNew: !name,\n      isLoadingOptions: true,\n      valueOptions: [] };\n\n    this.submitAnnotation = this.submitAnnotation.bind(this);\n    this.deleteAnnotation = this.deleteAnnotation.bind(this);\n    this.applyAnnotation = this.applyAnnotation.bind(this);\n    this.fetchOptions = this.fetchOptions.bind(this);\n    this.handleAnnotationType = this.handleAnnotationType.bind(this);\n    this.handleAnnotationSourceType = this.handleAnnotationSourceType.bind(\n    this);\n\n    this.handleValue = this.handleValue.bind(this);\n    this.isValidForm = this.isValidForm.bind(this);\n  }\n\n  componentDidMount() {\n    const { annotationType, sourceType, isLoadingOptions } = this.state;\n    this.fetchOptions(annotationType, sourceType, isLoadingOptions);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.sourceType !== this.state.sourceType) {\n      this.fetchOptions(this.state.annotationType, this.state.sourceType, true);\n    }\n  }\n\n  getSupportedSourceTypes(annotationType) {var _ANNOTATION_TYPES_MET;\n    // Get vis types that can be source.\n    const sources = getChartMetadataRegistry().\n    entries().\n    filter(({ value: chartMetadata }) =>\n    chartMetadata.canBeAnnotationType(annotationType)).\n\n    map(({ key, value: chartMetadata }) => ({\n      value: key,\n      label: chartMetadata.name }));\n\n    // Prepend native source if applicable\n    if ((_ANNOTATION_TYPES_MET = ANNOTATION_TYPES_METADATA[annotationType]) != null && _ANNOTATION_TYPES_MET.supportNativeSource) {\n      sources.unshift(ANNOTATION_SOURCE_TYPES_METADATA.NATIVE);\n    }\n    return sources;\n  }\n\n  isValidFormulaAnnotation(expression, annotationType) {\n    if (annotationType === ANNOTATION_TYPES.FORMULA) {\n      return isValidExpression(expression);\n    }\n    return true;\n  }\n\n  isValidForm() {\n    const {\n      name,\n      annotationType,\n      sourceType,\n      value,\n      timeColumn,\n      intervalEndColumn } =\n    this.state;\n    const errors = [\n    validateNonEmpty(name),\n    validateNonEmpty(annotationType),\n    validateNonEmpty(value)];\n\n    if (sourceType !== ANNOTATION_SOURCE_TYPES.NATIVE) {\n      if (annotationType === ANNOTATION_TYPES.EVENT) {\n        errors.push(validateNonEmpty(timeColumn));\n      }\n      if (annotationType === ANNOTATION_TYPES.INTERVAL) {\n        errors.push(validateNonEmpty(timeColumn));\n        errors.push(validateNonEmpty(intervalEndColumn));\n      }\n    }\n    errors.push(!this.isValidFormulaAnnotation(value, annotationType));\n    return !errors.filter((x) => x).length;\n  }\n\n  handleAnnotationType(annotationType) {\n    this.setState({\n      annotationType,\n      sourceType: null,\n      value: null });\n\n  }\n\n  handleAnnotationSourceType(sourceType) {\n    const { sourceType: prevSourceType } = this.state;\n\n    if (prevSourceType !== sourceType) {\n      this.setState({ sourceType, value: null, isLoadingOptions: true });\n    }\n  }\n\n  handleValue(value) {\n    this.setState({\n      value,\n      descriptionColumns: [],\n      intervalEndColumn: null,\n      timeColumn: null,\n      titleColumn: null,\n      overrides: { time_range: null } });\n\n  }\n\n  fetchOptions(annotationType, sourceType, isLoadingOptions) {\n    if (isLoadingOptions) {\n      if (sourceType === ANNOTATION_SOURCE_TYPES.NATIVE) {\n        SupersetClient.get({\n          endpoint: '/annotationlayermodelview/api/read?' }).\n        then(({ json }) => {\n          const layers = json ?\n          json.result.map((layer) => ({\n            value: layer.id,\n            label: layer.name })) :\n\n          [];\n          this.setState({\n            isLoadingOptions: false,\n            valueOptions: layers });\n\n        });\n      } else if (requiresQuery(sourceType)) {\n        SupersetClient.get({ endpoint: '/superset/user_slices' }).then(\n        ({ json }) => {\n          const registry = getChartMetadataRegistry();\n          this.setState({\n            isLoadingOptions: false,\n            valueOptions: json.\n            filter((x) => {\n              const metadata = registry.get(x.viz_type);\n              return (\n                metadata && metadata.canBeAnnotationType(annotationType));\n\n            }).\n            map((x) => ({ value: x.id, label: x.title, slice: x })) });\n\n        });\n\n      } else {\n        this.setState({\n          isLoadingOptions: false,\n          valueOptions: [] });\n\n      }\n    }\n  }\n\n  deleteAnnotation() {\n    this.props.removeAnnotationLayer();\n    this.props.close();\n  }\n\n  applyAnnotation() {\n    if (this.isValidForm()) {\n      const annotationFields = [\n      'name',\n      'annotationType',\n      'sourceType',\n      'color',\n      'opacity',\n      'style',\n      'width',\n      'showMarkers',\n      'hideLine',\n      'value',\n      'overrides',\n      'show',\n      'titleColumn',\n      'descriptionColumns',\n      'timeColumn',\n      'intervalEndColumn'];\n\n      const newAnnotation = {};\n      annotationFields.forEach((field) => {\n        if (this.state[field] !== null) {\n          newAnnotation[field] = this.state[field];\n        }\n      });\n\n      if (newAnnotation.color === AUTOMATIC_COLOR) {\n        newAnnotation.color = null;\n      }\n\n      this.props.addAnnotationLayer(newAnnotation);\n      this.setState({ isNew: false });\n    }\n  }\n\n  submitAnnotation() {\n    this.applyAnnotation();\n    this.props.close();\n  }\n\n  renderOption(option) {\n    return (\n      ___EmotionJSX(\"span\", {\n        css: _ref,\n\n\n\n\n        title: option.label },\n\n      option.label));\n\n\n  }\n\n  renderValueConfiguration() {\n    const {\n      annotationType,\n      sourceType,\n      value,\n      valueOptions,\n      isLoadingOptions } =\n    this.state;\n    let label = '';\n    let description = '';\n    if (requiresQuery(sourceType)) {\n      if (sourceType === ANNOTATION_SOURCE_TYPES.NATIVE) {\n        label = 'Annotation layer';\n        description = 'Select the Annotation Layer you would like to use.';\n      } else {\n        label = t('Chart');\n        description = `Use a pre defined Superset Chart as a source for annotations and overlays.\n        your chart must be one of these visualization types:\n        [${this.getSupportedSourceTypes(annotationType).\n        map((x) => x.label).\n        join(', ')}]`;\n      }\n    } else if (annotationType === ANNOTATION_TYPES.FORMULA) {\n      label = 'Formula';\n      description = `Expects a formula with depending time parameter 'x'\n        in milliseconds since epoch. mathjs is used to evaluate the formulas.\n        Example: '2x+5'`;\n    }\n    if (requiresQuery(sourceType)) {\n      return (\n        ___EmotionJSX(SelectControl, {\n          ariaLabel: t('Annotation layer value'),\n          name: \"annotation-layer-value\",\n          showHeader: true,\n          hovered: true,\n          description: description,\n          label: label,\n          placeholder: \"\",\n          options: valueOptions,\n          isLoading: isLoadingOptions,\n          value: value,\n          onChange: this.handleValue,\n          validationErrors: !value ? ['Mandatory'] : [],\n          optionRenderer: this.renderOption }));\n\n\n    }\n    if (annotationType === ANNOTATION_TYPES.FORMULA) {\n      return (\n        ___EmotionJSX(TextControl, {\n          name: \"annotation-layer-value\",\n          hovered: true,\n          showHeader: true,\n          description: description,\n          label: label,\n          placeholder: \"\",\n          value: value,\n          onChange: this.handleValue,\n          validationErrors:\n          !this.isValidFormulaAnnotation(value, annotationType) ?\n          ['Bad formula.'] :\n          [] }));\n\n\n\n    }\n    return '';\n  }\n\n  renderSliceConfiguration() {\n    const {\n      annotationType,\n      sourceType,\n      value,\n      valueOptions,\n      overrides,\n      titleColumn,\n      timeColumn,\n      intervalEndColumn,\n      descriptionColumns } =\n    this.state;\n    const { slice } = valueOptions.find((x) => x.value === value) || {};\n    if (sourceType !== ANNOTATION_SOURCE_TYPES.NATIVE && slice) {\n      const columns = (slice.data.groupby || []).\n      concat(slice.data.all_columns || []).\n      map((x) => ({ value: x, label: x }));\n      const timeColumnOptions = slice.data.include_time ?\n      [{ value: '__timestamp', label: '__timestamp' }].concat(columns) :\n      columns;\n      return (\n        ___EmotionJSX(\"div\", { style: { marginRight: '2rem' } },\n        ___EmotionJSX(PopoverSection, {\n          isSelected: true,\n          title: t('Annotation Slice Configuration'),\n          info: t(`This section allows you to configure how to use the slice\n               to generate annotations.`) },\n\n        (annotationType === ANNOTATION_TYPES.EVENT ||\n        annotationType === ANNOTATION_TYPES.INTERVAL) &&\n        ___EmotionJSX(SelectControl, {\n          ariaLabel: t('Annotation layer time column'),\n          hovered: true,\n          name: \"annotation-layer-time-column\",\n          label:\n          annotationType === ANNOTATION_TYPES.INTERVAL ?\n          t('Interval start column') :\n          t('Event time column'),\n\n          description: t(\n          'This column must contain date/time information.'),\n\n          validationErrors: !timeColumn ? ['Mandatory'] : [],\n          clearable: false,\n          options: timeColumnOptions,\n          value: timeColumn,\n          onChange: (v) => this.setState({ timeColumn: v }) }),\n\n\n        annotationType === ANNOTATION_TYPES.INTERVAL &&\n        ___EmotionJSX(SelectControl, {\n          ariaLabel: t('Annotation layer interval end'),\n          hovered: true,\n          name: \"annotation-layer-intervalEnd\",\n          label: t('Interval End column'),\n          description: t(\n          'This column must contain date/time information.'),\n\n          validationErrors: !intervalEndColumn ? ['Mandatory'] : [],\n          options: columns,\n          value: intervalEndColumn,\n          onChange: (value) => this.setState({ intervalEndColumn: value }) }),\n\n\n        ___EmotionJSX(SelectControl, {\n          ariaLabel: t('Annotation layer title column'),\n          hovered: true,\n          name: \"annotation-layer-title\",\n          label: t('Title Column'),\n          description: t('Pick a title for you annotation.'),\n          options: [{ value: '', label: 'None' }].concat(columns),\n          value: titleColumn,\n          onChange: (value) => this.setState({ titleColumn: value }) }),\n\n        annotationType !== ANNOTATION_TYPES.TIME_SERIES &&\n        ___EmotionJSX(SelectControl, {\n          ariaLabel: t('Annotation layer description columns'),\n          hovered: true,\n          name: \"annotation-layer-title\",\n          label: t('Description Columns'),\n          description: t(\n          \"Pick one or more columns that should be shown in the annotation. If you don't select a column all of them will be shown.\"),\n\n          multi: true,\n          options: columns,\n          value: descriptionColumns,\n          onChange: (value) => this.setState({ descriptionColumns: value }) }),\n\n\n        ___EmotionJSX(\"div\", { style: { marginTop: '1rem' } },\n        ___EmotionJSX(CheckboxControl, {\n          hovered: true,\n          name: \"annotation-override-time_range\",\n          label: \"Override time range\",\n          description: `This controls whether the \"time_range\" field from the current\n                  view should be passed down to the chart containing the annotation data.`,\n          value: 'time_range' in overrides,\n          onChange: (v) => {\n            delete overrides.time_range;\n            if (v) {\n              this.setState({\n                overrides: { ...overrides, time_range: null } });\n\n            } else {\n              this.setState({ overrides: { ...overrides } });\n            }\n          } }),\n\n        ___EmotionJSX(CheckboxControl, {\n          hovered: true,\n          name: \"annotation-override-timegrain\",\n          label: \"Override time grain\",\n          description: `This controls whether the time grain field from the current\n                  view should be passed down to the chart containing the annotation data.`,\n          value: 'time_grain_sqla' in overrides,\n          onChange: (v) => {\n            delete overrides.time_grain_sqla;\n            delete overrides.granularity;\n            if (v) {\n              this.setState({\n                overrides: {\n                  ...overrides,\n                  time_grain_sqla: null,\n                  granularity: null } });\n\n\n            } else {\n              this.setState({ overrides: { ...overrides } });\n            }\n          } }),\n\n        ___EmotionJSX(TextControl, {\n          hovered: true,\n          name: \"annotation-layer-timeshift\",\n          label: \"Time Shift\",\n          description: `Time delta in natural language\n                  (example:  24 hours, 7 days, 56 weeks, 365 days)`,\n          placeholder: \"\",\n          value: overrides.time_shift,\n          onChange: (v) =>\n          this.setState({ overrides: { ...overrides, time_shift: v } }) })))));\n\n\n\n\n\n\n    }\n    return '';\n  }\n\n  renderDisplayConfiguration() {\n    const {\n      color,\n      opacity,\n      style,\n      width,\n      showMarkers,\n      hideLine,\n      annotationType } =\n    this.state;\n    const colorScheme = getCategoricalSchemeRegistry().\n    get(this.props.colorScheme).\n    colors.concat();\n    if (\n    color &&\n    color !== AUTOMATIC_COLOR &&\n    !colorScheme.find((x) => x.toLowerCase() === color.toLowerCase()))\n    {\n      colorScheme.push(color);\n    }\n    return (\n      ___EmotionJSX(PopoverSection, {\n        isSelected: true,\n        title: t('Display configuration'),\n        info: t('Configure your how you overlay is displayed here.') },\n\n      ___EmotionJSX(SelectControl, {\n        ariaLabel: t('Annotation layer stroke'),\n        name: \"annotation-layer-stroke\",\n        label: t('Style')\n        // see '../../../visualizations/nvd3_vis.css'\n        , options: [\n        { value: 'solid', label: 'Solid' },\n        { value: 'dashed', label: 'Dashed' },\n        { value: 'longDashed', label: 'Long dashed' },\n        { value: 'dotted', label: 'Dotted' }],\n\n        value: style,\n        clearable: false,\n        onChange: (v) => this.setState({ style: v }) }),\n\n      ___EmotionJSX(SelectControl, {\n        ariaLabel: t('Annotation layer opacity'),\n        name: \"annotation-layer-opacity\",\n        label: t('Opacity')\n        // see '../../../visualizations/nvd3_vis.css'\n        , options: [\n        { value: '', label: 'Solid' },\n        { value: 'opacityLow', label: '0.2' },\n        { value: 'opacityMedium', label: '0.5' },\n        { value: 'opacityHigh', label: '0.8' }],\n\n        value: opacity,\n        onChange: (value) => this.setState({ opacity: value }) }),\n\n      ___EmotionJSX(\"div\", null,\n      ___EmotionJSX(ControlHeader, { label: t('Color') }),\n      ___EmotionJSX(\"div\", { style: { display: 'flex', flexDirection: 'column' } },\n      ___EmotionJSX(CompactPicker, {\n        color: color,\n        colors: colorScheme,\n        onChangeComplete: (v) => this.setState({ color: v.hex }) }),\n\n      ___EmotionJSX(Button, {\n        style: { marginTop: '0.5rem', marginBottom: '0.5rem' },\n        buttonStyle: color === AUTOMATIC_COLOR ? 'success' : 'default',\n        buttonSize: \"xsmall\",\n        onClick: () => this.setState({ color: AUTOMATIC_COLOR }) }, \"Automatic Color\"))),\n\n\n\n\n\n      ___EmotionJSX(TextControl, {\n        name: \"annotation-layer-stroke-width\",\n        label: t('Line width'),\n        isInt: true,\n        value: width,\n        onChange: (v) => this.setState({ width: v }) }),\n\n      annotationType === ANNOTATION_TYPES.TIME_SERIES &&\n      ___EmotionJSX(CheckboxControl, {\n        hovered: true,\n        name: \"annotation-layer-show-markers\",\n        label: \"Show Markers\",\n        description: \"Shows or hides markers for the time series\",\n        value: showMarkers,\n        onChange: (v) => this.setState({ showMarkers: v }) }),\n\n\n      annotationType === ANNOTATION_TYPES.TIME_SERIES &&\n      ___EmotionJSX(CheckboxControl, {\n        hovered: true,\n        name: \"annotation-layer-hide-line\",\n        label: \"Hide Line\",\n        description: \"Hides the Line for the time series\",\n        value: hideLine,\n        onChange: (v) => this.setState({ hideLine: v }) })));\n\n\n\n\n  }\n\n  render() {\n    const { isNew, name, annotationType, sourceType, show } = this.state;\n    const isValid = this.isValidForm();\n    const metadata = getChartMetadataRegistry().get(this.props.vizType);\n    const supportedAnnotationTypes = metadata ?\n    metadata.supportedAnnotationTypes.map(\n    (type) => ANNOTATION_TYPES_METADATA[type]) :\n\n    [];\n    const supportedSourceTypes = this.getSupportedSourceTypes(annotationType);\n\n    return (\n      ___EmotionJSX(React.Fragment, null,\n      this.props.error &&\n      ___EmotionJSX(\"span\", { style: { color: 'red' } }, \"ERROR: \", this.props.error),\n\n      ___EmotionJSX(\"div\", { style: { display: 'flex', flexDirection: 'row' } },\n      ___EmotionJSX(\"div\", { style: { marginRight: '2rem' } },\n      ___EmotionJSX(PopoverSection, {\n        isSelected: true,\n        title: t('Layer configuration'),\n        info: t('Configure the basics of your Annotation Layer.') },\n\n      ___EmotionJSX(TextControl, {\n        name: \"annotation-layer-name\",\n        label: t('Name'),\n        placeholder: \"\",\n        value: name,\n        onChange: (v) => this.setState({ name: v }),\n        validationErrors: !name ? [t('Mandatory')] : [] }),\n\n      ___EmotionJSX(CheckboxControl, {\n        name: \"annotation-layer-hide\",\n        label: t('Hide layer'),\n        value: !show,\n        onChange: (v) => this.setState({ show: !v }) }),\n\n      ___EmotionJSX(SelectControl, {\n        ariaLabel: t('Annotation layer type'),\n        hovered: true,\n        description: t('Choose the annotation layer type'),\n        label: t('Annotation layer type'),\n        name: \"annotation-layer-type\",\n        clearable: false,\n        options: supportedAnnotationTypes,\n        value: annotationType,\n        onChange: this.handleAnnotationType }),\n\n      supportedSourceTypes.length > 0 &&\n      ___EmotionJSX(SelectControl, {\n        ariaLabel: t('Annotation source type'),\n        hovered: true,\n        description: t('Choose the source of your annotations'),\n        label: t('Annotation Source'),\n        name: \"annotation-source-type\",\n        options: supportedSourceTypes,\n        value: sourceType,\n        onChange: this.handleAnnotationSourceType,\n        validationErrors: !sourceType ? [t('Mandatory')] : [] }),\n\n\n      this.renderValueConfiguration())),\n\n\n      this.renderSliceConfiguration(),\n      this.renderDisplayConfiguration()),\n\n      ___EmotionJSX(\"div\", { style: { display: 'flex', justifyContent: 'space-between' } },\n      isNew ?\n      ___EmotionJSX(Button, { buttonSize: \"small\", onClick: () => this.props.close() },\n      t('Cancel')) :\n\n\n      ___EmotionJSX(Button, { buttonSize: \"small\", onClick: this.deleteAnnotation },\n      t('Remove')),\n\n\n      ___EmotionJSX(\"div\", null,\n      ___EmotionJSX(Button, {\n        buttonSize: \"small\",\n        disabled: !isValid,\n        onClick: this.applyAnnotation },\n\n      t('Apply')),\n\n\n      ___EmotionJSX(Button, {\n        buttonSize: \"small\",\n        buttonStyle: \"primary\",\n        disabled: !isValid,\n        onClick: this.submitAnnotation },\n\n      t('OK'))))));\n\n\n\n\n\n  }}\n\n\nAnnotationLayer.propTypes = propTypes;\nAnnotationLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}