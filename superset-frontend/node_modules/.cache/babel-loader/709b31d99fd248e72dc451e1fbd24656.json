{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { DYNAMIC_PLUGIN_CONTROLS_READY } from 'src/chart/chartAction';\nimport { DEFAULT_TIME_RANGE } from 'src/explore/constants';\nimport { getControlsState } from 'src/explore/store';\nimport {\ngetControlConfig,\ngetFormDataFromControls,\ngetControlStateFromControlConfig } from\n'src/explore/controlUtils';\nimport * as actions from 'src/explore/actions/exploreActions';\n\nexport default function exploreReducer(state = {}, action) {\n  const actionHandlers = {\n    [DYNAMIC_PLUGIN_CONTROLS_READY]() {\n      return {\n        ...state,\n        controls: action.controlsState };\n\n    },\n    [actions.TOGGLE_FAVE_STAR]() {\n      return {\n        ...state,\n        isStarred: action.isStarred };\n\n    },\n    [actions.POST_DATASOURCE_STARTED]() {\n      return {\n        ...state,\n        isDatasourceMetaLoading: true };\n\n    },\n    [actions.SET_DATASOURCE]() {\n      const newFormData = { ...state.form_data };\n      if (action.datasource.type !== state.datasource.type) {\n        if (action.datasource.type === 'table') {\n          newFormData.granularity_sqla = action.datasource.granularity_sqla;\n          newFormData.time_grain_sqla = action.datasource.time_grain_sqla;\n          delete newFormData.druid_time_origin;\n          delete newFormData.granularity;\n        } else {\n          newFormData.druid_time_origin = action.datasource.druid_time_origin;\n          newFormData.granularity = action.datasource.granularity;\n          delete newFormData.granularity_sqla;\n          delete newFormData.time_grain_sqla;\n        }\n      }\n\n      const controls = { ...state.controls };\n      if (\n      action.datasource.id !== state.datasource.id ||\n      action.datasource.type !== state.datasource.type)\n      {\n        // reset time range filter to default\n        newFormData.time_range = DEFAULT_TIME_RANGE;\n\n        // reset control values for column/metric related controls\n        Object.entries(controls).forEach(([controlName, controlState]) => {\n          if (\n          // for direct column select controls\n          controlState.valueKey === 'column_name' ||\n          // for all other controls\n          'columns' in controlState)\n          {\n            // if a control use datasource columns, reset its value to `undefined`,\n            // then `getControlsState` will pick up the default.\n            // TODO: filter out only invalid columns and keep others\n            controls[controlName] = {\n              ...controlState,\n              value: undefined };\n\n            newFormData[controlName] = undefined;\n          }\n        });\n      }\n\n      const newState = {\n        ...state,\n        controls,\n        datasource: action.datasource,\n        datasource_id: action.datasource.id,\n        datasource_type: action.datasource.type };\n\n      return {\n        ...newState,\n        form_data: newFormData,\n        controls: getControlsState(newState, newFormData) };\n\n    },\n    [actions.FETCH_DATASOURCES_STARTED]() {\n      return {\n        ...state,\n        isDatasourcesLoading: true };\n\n    },\n    [actions.SET_DATASOURCES]() {\n      return {\n        ...state,\n        datasources: action.datasources };\n\n    },\n    [actions.SET_FIELD_VALUE]() {\n      const new_form_data = state.form_data;\n      const { controlName, value, validationErrors } = action;\n      new_form_data[controlName] = value;\n\n      const vizType = new_form_data.viz_type;\n\n      // Use the processed control config (with overrides and everything)\n      // if `controlName` does not existing in current controls,\n      const controlConfig =\n      state.controls[action.controlName] ||\n      getControlConfig(action.controlName, vizType) ||\n      {};\n\n      // will call validators again\n      const control = {\n        ...getControlStateFromControlConfig(controlConfig, state, action.value) };\n\n\n      const newState = {\n        ...state,\n        controls: { ...state.controls, [action.controlName]: control } };\n\n\n      const rerenderedControls = {};\n      if (Array.isArray(control.rerender)) {\n        control.rerender.forEach((controlName) => {\n          rerenderedControls[controlName] = {\n            ...getControlStateFromControlConfig(\n            newState.controls[controlName],\n            newState,\n            newState.controls[controlName].value) };\n\n\n        });\n      }\n\n      // combine newly detected errors with errors from `onChange` event of\n      // each control component (passed via reducer action).\n      const errors = control.validationErrors || [];\n      (validationErrors || []).forEach((err) => {\n        // skip duplicated errors\n        if (!errors.includes(err)) {\n          errors.push(err);\n        }\n      });\n      const hasErrors = errors && errors.length > 0;\n\n      const currentControlsState =\n      action.controlName === 'viz_type' &&\n      action.value !== state.controls.viz_type.value ?\n      // rebuild the full control state if switching viz type\n      getControlsState(\n      state,\n      getFormDataFromControls({\n        ...state.controls,\n        viz_type: control })) :\n\n\n      state.controls;\n\n      return {\n        ...state,\n        form_data: new_form_data,\n        triggerRender: control.renderTrigger && !hasErrors,\n        controls: {\n          ...currentControlsState,\n          [action.controlName]: {\n            ...control,\n            validationErrors: errors },\n\n          ...rerenderedControls } };\n\n\n    },\n    [actions.SET_EXPLORE_CONTROLS]() {\n      return {\n        ...state,\n        controls: getControlsState(state, action.formData) };\n\n    },\n    [actions.UPDATE_CHART_TITLE]() {\n      return {\n        ...state,\n        sliceName: action.sliceName };\n\n    },\n    [actions.CREATE_NEW_SLICE]() {\n      return {\n        ...state,\n        slice: action.slice,\n        controls: getControlsState(state, action.form_data),\n        can_add: action.can_add,\n        can_download: action.can_download,\n        can_overwrite: action.can_overwrite };\n\n    },\n    [actions.SLICE_UPDATED]() {var _action$slice$owners, _action$slice$slice_n;\n      return {\n        ...state,\n        slice: {\n          ...state.slice,\n          ...action.slice,\n          owners: (_action$slice$owners = action.slice.owners) != null ? _action$slice$owners : null },\n\n        sliceName: (_action$slice$slice_n = action.slice.slice_name) != null ? _action$slice$slice_n : state.sliceName };\n\n    } };\n\n  if (action.type in actionHandlers) {\n    return actionHandlers[action.type]();\n  }\n  return state;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(exploreReducer, \"exploreReducer\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/reducers/exploreReducer.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/reducers/exploreReducer.js"],"names":["DYNAMIC_PLUGIN_CONTROLS_READY","DEFAULT_TIME_RANGE","getControlsState","getControlConfig","getFormDataFromControls","getControlStateFromControlConfig","actions","exploreReducer","state","action","actionHandlers","controls","controlsState","TOGGLE_FAVE_STAR","isStarred","POST_DATASOURCE_STARTED","isDatasourceMetaLoading","SET_DATASOURCE","newFormData","form_data","datasource","type","granularity_sqla","time_grain_sqla","druid_time_origin","granularity","id","time_range","Object","entries","forEach","controlName","controlState","valueKey","value","undefined","newState","datasource_id","datasource_type","FETCH_DATASOURCES_STARTED","isDatasourcesLoading","SET_DATASOURCES","datasources","SET_FIELD_VALUE","new_form_data","validationErrors","vizType","viz_type","controlConfig","control","rerenderedControls","Array","isArray","rerender","errors","err","includes","push","hasErrors","length","currentControlsState","triggerRender","renderTrigger","SET_EXPLORE_CONTROLS","formData","UPDATE_CHART_TITLE","sliceName","CREATE_NEW_SLICE","slice","can_add","can_download","can_overwrite","SLICE_UPDATED","owners","slice_name"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { DYNAMIC_PLUGIN_CONTROLS_READY } from 'src/chart/chartAction';\nimport { DEFAULT_TIME_RANGE } from 'src/explore/constants';\nimport { getControlsState } from 'src/explore/store';\nimport {\n  getControlConfig,\n  getFormDataFromControls,\n  getControlStateFromControlConfig,\n} from 'src/explore/controlUtils';\nimport * as actions from 'src/explore/actions/exploreActions';\n\nexport default function exploreReducer(state = {}, action) {\n  const actionHandlers = {\n    [DYNAMIC_PLUGIN_CONTROLS_READY]() {\n      return {\n        ...state,\n        controls: action.controlsState,\n      };\n    },\n    [actions.TOGGLE_FAVE_STAR]() {\n      return {\n        ...state,\n        isStarred: action.isStarred,\n      };\n    },\n    [actions.POST_DATASOURCE_STARTED]() {\n      return {\n        ...state,\n        isDatasourceMetaLoading: true,\n      };\n    },\n    [actions.SET_DATASOURCE]() {\n      const newFormData = { ...state.form_data };\n      if (action.datasource.type !== state.datasource.type) {\n        if (action.datasource.type === 'table') {\n          newFormData.granularity_sqla = action.datasource.granularity_sqla;\n          newFormData.time_grain_sqla = action.datasource.time_grain_sqla;\n          delete newFormData.druid_time_origin;\n          delete newFormData.granularity;\n        } else {\n          newFormData.druid_time_origin = action.datasource.druid_time_origin;\n          newFormData.granularity = action.datasource.granularity;\n          delete newFormData.granularity_sqla;\n          delete newFormData.time_grain_sqla;\n        }\n      }\n\n      const controls = { ...state.controls };\n      if (\n        action.datasource.id !== state.datasource.id ||\n        action.datasource.type !== state.datasource.type\n      ) {\n        // reset time range filter to default\n        newFormData.time_range = DEFAULT_TIME_RANGE;\n\n        // reset control values for column/metric related controls\n        Object.entries(controls).forEach(([controlName, controlState]) => {\n          if (\n            // for direct column select controls\n            controlState.valueKey === 'column_name' ||\n            // for all other controls\n            'columns' in controlState\n          ) {\n            // if a control use datasource columns, reset its value to `undefined`,\n            // then `getControlsState` will pick up the default.\n            // TODO: filter out only invalid columns and keep others\n            controls[controlName] = {\n              ...controlState,\n              value: undefined,\n            };\n            newFormData[controlName] = undefined;\n          }\n        });\n      }\n\n      const newState = {\n        ...state,\n        controls,\n        datasource: action.datasource,\n        datasource_id: action.datasource.id,\n        datasource_type: action.datasource.type,\n      };\n      return {\n        ...newState,\n        form_data: newFormData,\n        controls: getControlsState(newState, newFormData),\n      };\n    },\n    [actions.FETCH_DATASOURCES_STARTED]() {\n      return {\n        ...state,\n        isDatasourcesLoading: true,\n      };\n    },\n    [actions.SET_DATASOURCES]() {\n      return {\n        ...state,\n        datasources: action.datasources,\n      };\n    },\n    [actions.SET_FIELD_VALUE]() {\n      const new_form_data = state.form_data;\n      const { controlName, value, validationErrors } = action;\n      new_form_data[controlName] = value;\n\n      const vizType = new_form_data.viz_type;\n\n      // Use the processed control config (with overrides and everything)\n      // if `controlName` does not existing in current controls,\n      const controlConfig =\n        state.controls[action.controlName] ||\n        getControlConfig(action.controlName, vizType) ||\n        {};\n\n      // will call validators again\n      const control = {\n        ...getControlStateFromControlConfig(controlConfig, state, action.value),\n      };\n\n      const newState = {\n        ...state,\n        controls: { ...state.controls, [action.controlName]: control },\n      };\n\n      const rerenderedControls = {};\n      if (Array.isArray(control.rerender)) {\n        control.rerender.forEach(controlName => {\n          rerenderedControls[controlName] = {\n            ...getControlStateFromControlConfig(\n              newState.controls[controlName],\n              newState,\n              newState.controls[controlName].value,\n            ),\n          };\n        });\n      }\n\n      // combine newly detected errors with errors from `onChange` event of\n      // each control component (passed via reducer action).\n      const errors = control.validationErrors || [];\n      (validationErrors || []).forEach(err => {\n        // skip duplicated errors\n        if (!errors.includes(err)) {\n          errors.push(err);\n        }\n      });\n      const hasErrors = errors && errors.length > 0;\n\n      const currentControlsState =\n        action.controlName === 'viz_type' &&\n        action.value !== state.controls.viz_type.value\n          ? // rebuild the full control state if switching viz type\n            getControlsState(\n              state,\n              getFormDataFromControls({\n                ...state.controls,\n                viz_type: control,\n              }),\n            )\n          : state.controls;\n\n      return {\n        ...state,\n        form_data: new_form_data,\n        triggerRender: control.renderTrigger && !hasErrors,\n        controls: {\n          ...currentControlsState,\n          [action.controlName]: {\n            ...control,\n            validationErrors: errors,\n          },\n          ...rerenderedControls,\n        },\n      };\n    },\n    [actions.SET_EXPLORE_CONTROLS]() {\n      return {\n        ...state,\n        controls: getControlsState(state, action.formData),\n      };\n    },\n    [actions.UPDATE_CHART_TITLE]() {\n      return {\n        ...state,\n        sliceName: action.sliceName,\n      };\n    },\n    [actions.CREATE_NEW_SLICE]() {\n      return {\n        ...state,\n        slice: action.slice,\n        controls: getControlsState(state, action.form_data),\n        can_add: action.can_add,\n        can_download: action.can_download,\n        can_overwrite: action.can_overwrite,\n      };\n    },\n    [actions.SLICE_UPDATED]() {\n      return {\n        ...state,\n        slice: {\n          ...state.slice,\n          ...action.slice,\n          owners: action.slice.owners ?? null,\n        },\n        sliceName: action.slice.slice_name ?? state.sliceName,\n      };\n    },\n  };\n  if (action.type in actionHandlers) {\n    return actionHandlers[action.type]();\n  }\n  return state;\n}\n"]},"metadata":{},"sourceType":"module"}