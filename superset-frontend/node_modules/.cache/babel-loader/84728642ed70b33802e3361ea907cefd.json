{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _isEmpty from \"lodash/isEmpty\";import _flatMap from \"lodash/flatMap\";import _mapValues from \"lodash/fp/mapValues\";import _keyBy from \"lodash/fp/keyBy\";import _flow from \"lodash/fp/flow\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  tabs.forEach(({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !tabsInScope.includes(tab)) {\n      tabChildren.forEach(({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !tabsInScope.includes(subTab)) {\n          chartsNotInScope.push(\n          ...subTabChildren.filter(({ type }) => type === CHART_TYPE));\n\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map(({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = [] })\n{\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n  forceAggregate ||\n  !hasChartSiblings &&\n  Object.entries(tabScopes).every(\n  ([key, { scope }]) => scope && scope.length && key === scope[0]))\n\n  {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope = getImmuneChartIdsFromTabsNotInScope(\n    {\n      tabs: tabChildren,\n      tabsInScope: _flatMap(tabScopes, ({ scope }) => scope) });\n\n\n    const immuneChartIdsFromTabsInScope = _flatMap(\n    Object.values(tabScopes),\n    ({ immune }) => immune);\n\n    const immuneCharts = [\n    ...new Set([\n    ...immuneChartIdsFromTabsNotInScope,\n    ...immuneChartIdsFromTabsInScope])];\n\n\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts };\n\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n  ({ scope }) => scope && scope.length);\n\n  return {\n    scope: _flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length ?\n    _flatMap(componentsInScope, ({ immune }) => immune) :\n    _flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n    immuneChartSiblings) };\n\n\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren.\n  filter(\n  ({ value }) => filterId !== value && !checkedChartIds.includes(value)).\n\n  map(({ value }) => value);\n  const tabScopes = _flow(\n  _keyBy((child) => child.value),\n  _mapValues((child) =>\n  traverse({\n    currentNode: child,\n    filterId,\n    checkedChartIds })))(\n\n\n  tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n  !_isEmpty(chartChildren) &&\n  chartChildren.some(({ value }) => checkedChartIds.includes(value)))\n  {\n    if (_isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren });\n\n    return {\n      scope,\n      immune: chartsImmune.concat(immune) };\n\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !_isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune });\n\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune };\n\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [] })\n{\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds });\n\n  }\n\n  return {};\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getImmuneChartIdsFromTabsNotInScope, \"getImmuneChartIdsFromTabsNotInScope\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getTabChildrenScope, \"getTabChildrenScope\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(traverse, \"traverse\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getFilterScopeFromNodesTree, \"getFilterScopeFromNodesTree\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(__signature__, \"__signature__\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getImmuneChartIdsFromTabsNotInScope, \"getImmuneChartIdsFromTabsNotInScope\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getTabChildrenScope, \"getTabChildrenScope\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(traverse, \"traverse\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getFilterScopeFromNodesTree, \"getFilterScopeFromNodesTree\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js"],"names":["getImmuneChartIdsFromTabsNotInScope","tabs","tabsInScope","chartsNotInScope","value","children","tabChildren","subTabChildren","type","getTabChildrenScope","forceAggregate","hasChartSiblings","immuneChartSiblings","Object","scope","key","immuneChartIdsFromTabsNotInScope","immuneChartIdsFromTabsInScope","immuneCharts","immune","componentsInScope","traverse","currentNode","checkedChartIds","chartChildren","chartsImmune","filterId","tabScopes","child","parentNodeValue","getFilterScopeFromNodesTree","nodes","getChartIdAndColumnFromFilterKey"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { flow, keyBy, mapValues } from 'lodash/fp';\nimport { flatMap, isEmpty } from 'lodash';\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  tabs.forEach(({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !tabsInScope.includes(tab)) {\n      tabChildren.forEach(({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !tabsInScope.includes(subTab)) {\n          chartsNotInScope.push(\n            ...subTabChildren.filter(({ type }) => type === CHART_TYPE),\n          );\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map(({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = [],\n}) {\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n    forceAggregate ||\n    (!hasChartSiblings &&\n      Object.entries(tabScopes).every(\n        ([key, { scope }]) => scope && scope.length && key === scope[0],\n      ))\n  ) {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope = getImmuneChartIdsFromTabsNotInScope(\n      {\n        tabs: tabChildren,\n        tabsInScope: flatMap(tabScopes, ({ scope }) => scope),\n      },\n    );\n    const immuneChartIdsFromTabsInScope = flatMap(\n      Object.values(tabScopes),\n      ({ immune }) => immune,\n    );\n    const immuneCharts = [\n      ...new Set([\n        ...immuneChartIdsFromTabsNotInScope,\n        ...immuneChartIdsFromTabsInScope,\n      ]),\n    ];\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts,\n    };\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n    ({ scope }) => scope && scope.length,\n  );\n  return {\n    scope: flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length\n      ? flatMap(componentsInScope, ({ immune }) => immune)\n      : flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n          immuneChartSiblings,\n        ),\n  };\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren\n    .filter(\n      ({ value }) => filterId !== value && !checkedChartIds.includes(value),\n    )\n    .map(({ value }) => value);\n  const tabScopes = flow(\n    keyBy(child => child.value),\n    mapValues(child =>\n      traverse({\n        currentNode: child,\n        filterId,\n        checkedChartIds,\n      }),\n    ),\n  )(tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n    !isEmpty(chartChildren) &&\n    chartChildren.some(({ value }) => checkedChartIds.includes(value))\n  ) {\n    if (isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren,\n    });\n    return {\n      scope,\n      immune: chartsImmune.concat(immune),\n    };\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune,\n    });\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune,\n  };\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [],\n}) {\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds,\n    });\n  }\n\n  return {};\n}\n"]},"metadata":{},"sourceType":"module"}