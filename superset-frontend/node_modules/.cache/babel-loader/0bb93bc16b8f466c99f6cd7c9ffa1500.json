{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport {\nCUSTOM_OPERATORS,\nOperators,\nOPERATOR_ENUM_TO_OPERATOR_TYPE } from\n'src/explore/constants';\nimport { getSimpleSQLExpression } from 'src/explore/exploreUtils';\n\nexport const EXPRESSION_TYPES = {\n  SIMPLE: 'SIMPLE',\n  SQL: 'SQL' };\n\n\nexport const CLAUSES = {\n  HAVING: 'HAVING',\n  WHERE: 'WHERE' };\n\n\nconst OPERATORS_TO_SQL = {\n  '==': '=',\n  '!=': '<>',\n  '>': '>',\n  '<': '<',\n  '>=': '>=',\n  '<=': '<=',\n  IN: 'IN',\n  'NOT IN': 'NOT IN',\n  LIKE: 'LIKE',\n  ILIKE: 'ILIKE',\n  REGEX: 'REGEX',\n  'IS NOT NULL': 'IS NOT NULL',\n  'IS NULL': 'IS NULL',\n  'IS TRUE': 'IS TRUE',\n  'IS FALSE': 'IS FALSE',\n  'LATEST PARTITION': ({ datasource }) =>\n  `= '{{ presto.latest_partition('${datasource.schema}.${datasource.datasource_name}') }}'` };\n\n\nconst CUSTOM_OPERATIONS = [...CUSTOM_OPERATORS].map(\n(op) => OPERATOR_ENUM_TO_OPERATOR_TYPE[op].operation);\n\n\nfunction translateToSql(adhocMetric, { useSimple } = {}) {\n  if (adhocMetric.expressionType === EXPRESSION_TYPES.SIMPLE || useSimple) {\n    const { subject, comparator } = adhocMetric;\n    const operator =\n    adhocMetric.operator &&\n    CUSTOM_OPERATIONS.indexOf(adhocMetric.operator) >= 0 ?\n    OPERATORS_TO_SQL[adhocMetric.operator](adhocMetric) :\n    OPERATORS_TO_SQL[adhocMetric.operator];\n    return getSimpleSQLExpression(subject, operator, comparator);\n  }\n  if (adhocMetric.expressionType === EXPRESSION_TYPES.SQL) {\n    return adhocMetric.sqlExpression;\n  }\n  return '';\n}\n\nexport default class AdhocFilter {\n  constructor(adhocFilter) {\n    this.expressionType = adhocFilter.expressionType || EXPRESSION_TYPES.SIMPLE;\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {var _adhocFilter$operator;\n      this.subject = adhocFilter.subject;\n      this.operator = (_adhocFilter$operator = adhocFilter.operator) == null ? void 0 : _adhocFilter$operator.toUpperCase();\n      this.operatorId = adhocFilter.operatorId;\n      this.comparator = adhocFilter.comparator;\n      if (\n      [Operators.IS_TRUE, Operators.IS_FALSE].indexOf(\n      adhocFilter.operatorId) >=\n      0)\n      {\n        this.comparator = adhocFilter.operatorId === Operators.IS_TRUE;\n      }\n      if (\n      [Operators.IS_NULL, Operators.IS_NOT_NULL].indexOf(\n      adhocFilter.operatorId) >=\n      0)\n      {\n        this.comparator = null;\n      }\n      this.clause = adhocFilter.clause || CLAUSES.WHERE;\n      this.sqlExpression = null;\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      this.sqlExpression =\n      typeof adhocFilter.sqlExpression === 'string' ?\n      adhocFilter.sqlExpression :\n      translateToSql(adhocFilter, { useSimple: true });\n      this.clause = adhocFilter.clause;\n      if (\n      adhocFilter.operator &&\n      CUSTOM_OPERATIONS.indexOf(adhocFilter.operator) >= 0)\n      {\n        this.subject = adhocFilter.subject;\n        this.operator = adhocFilter.operator;\n        this.operatorId = adhocFilter.operatorId;\n      } else {\n        this.subject = null;\n        this.operator = null;\n      }\n      this.comparator = null;\n    }\n    this.isExtra = !!adhocFilter.isExtra;\n    this.isNew = !!adhocFilter.isNew;\n\n    this.filterOptionName =\n    adhocFilter.filterOptionName ||\n    `filter_${Math.random().\n    toString(36).\n    substring(2, 15)}_${Math.random().toString(36).substring(2, 15)}`;\n  }\n\n  duplicateWith(nextFields) {\n    return new AdhocFilter({\n      ...this,\n      // all duplicated fields are not new (i.e. will not open popup automatically)\n      isNew: false,\n      ...nextFields });\n\n  }\n\n  equals(adhocFilter) {\n    return (\n      adhocFilter.expressionType === this.expressionType &&\n      adhocFilter.sqlExpression === this.sqlExpression &&\n      adhocFilter.operator === this.operator &&\n      adhocFilter.operatorId === this.operatorId &&\n      adhocFilter.comparator === this.comparator &&\n      adhocFilter.subject === this.subject);\n\n  }\n\n  isValid() {\n    const nullCheckOperators = [Operators.IS_NOT_NULL, Operators.IS_NULL].map(\n    (op) => OPERATOR_ENUM_TO_OPERATOR_TYPE[op].operation);\n\n    const truthCheckOperators = [Operators.IS_TRUE, Operators.IS_FALSE].map(\n    (op) => OPERATOR_ENUM_TO_OPERATOR_TYPE[op].operation);\n\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      if (nullCheckOperators.indexOf(this.operator) >= 0) {\n        return !!(this.operator && this.subject);\n      }\n      if (truthCheckOperators.indexOf(this.operator) >= 0) {\n        return !!(this.subject && this.comparator !== null);\n      }\n      if (this.operator && this.subject && this.clause) {\n        if (Array.isArray(this.comparator)) {\n          if (this.comparator.length > 0) {\n            // A non-empty array of values ('IN' or 'NOT IN' clauses)\n            return true;\n          }\n        } else if (this.comparator !== null) {\n          // A value has been selected or typed\n          return true;\n        }\n      }\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return !!(this.sqlExpression && this.clause);\n    }\n    return false;\n  }\n\n  getDefaultLabel() {\n    const label = this.translateToSql();\n    return label.length < 43 ? label : `${label.substring(0, 40)}...`;\n  }\n\n  getTooltipTitle() {\n    return this.translateToSql();\n  }\n\n  translateToSql() {\n    return translateToSql(this);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(EXPRESSION_TYPES, \"EXPRESSION_TYPES\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(CLAUSES, \"CLAUSES\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(OPERATORS_TO_SQL, \"OPERATORS_TO_SQL\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(CUSTOM_OPERATIONS, \"CUSTOM_OPERATIONS\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(translateToSql, \"translateToSql\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(AdhocFilter, \"AdhocFilter\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(__signature__, \"__signature__\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(EXPRESSION_TYPES, \"EXPRESSION_TYPES\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(CLAUSES, \"CLAUSES\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(OPERATORS_TO_SQL, \"OPERATORS_TO_SQL\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(CUSTOM_OPERATIONS, \"CUSTOM_OPERATIONS\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(translateToSql, \"translateToSql\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");reactHotLoader.register(AdhocFilter, \"AdhocFilter\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter/index.js"],"names":["EXPRESSION_TYPES","SIMPLE","SQL","CLAUSES","HAVING","WHERE","OPERATORS_TO_SQL","IN","LIKE","ILIKE","REGEX","datasource","schema","datasource_name","CUSTOM_OPERATIONS","OPERATOR_ENUM_TO_OPERATOR_TYPE","translateToSql","adhocMetric","operator","getSimpleSQLExpression","AdhocFilter","constructor","adhocFilter","Operators","useSimple","Math","duplicateWith","isNew","equals","isValid","nullCheckOperators","truthCheckOperators","Array","getDefaultLabel","label","getTooltipTitle"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  CUSTOM_OPERATORS,\n  Operators,\n  OPERATOR_ENUM_TO_OPERATOR_TYPE,\n} from 'src/explore/constants';\nimport { getSimpleSQLExpression } from 'src/explore/exploreUtils';\n\nexport const EXPRESSION_TYPES = {\n  SIMPLE: 'SIMPLE',\n  SQL: 'SQL',\n};\n\nexport const CLAUSES = {\n  HAVING: 'HAVING',\n  WHERE: 'WHERE',\n};\n\nconst OPERATORS_TO_SQL = {\n  '==': '=',\n  '!=': '<>',\n  '>': '>',\n  '<': '<',\n  '>=': '>=',\n  '<=': '<=',\n  IN: 'IN',\n  'NOT IN': 'NOT IN',\n  LIKE: 'LIKE',\n  ILIKE: 'ILIKE',\n  REGEX: 'REGEX',\n  'IS NOT NULL': 'IS NOT NULL',\n  'IS NULL': 'IS NULL',\n  'IS TRUE': 'IS TRUE',\n  'IS FALSE': 'IS FALSE',\n  'LATEST PARTITION': ({ datasource }) =>\n    `= '{{ presto.latest_partition('${datasource.schema}.${datasource.datasource_name}') }}'`,\n};\n\nconst CUSTOM_OPERATIONS = [...CUSTOM_OPERATORS].map(\n  op => OPERATOR_ENUM_TO_OPERATOR_TYPE[op].operation,\n);\n\nfunction translateToSql(adhocMetric, { useSimple } = {}) {\n  if (adhocMetric.expressionType === EXPRESSION_TYPES.SIMPLE || useSimple) {\n    const { subject, comparator } = adhocMetric;\n    const operator =\n      adhocMetric.operator &&\n      CUSTOM_OPERATIONS.indexOf(adhocMetric.operator) >= 0\n        ? OPERATORS_TO_SQL[adhocMetric.operator](adhocMetric)\n        : OPERATORS_TO_SQL[adhocMetric.operator];\n    return getSimpleSQLExpression(subject, operator, comparator);\n  }\n  if (adhocMetric.expressionType === EXPRESSION_TYPES.SQL) {\n    return adhocMetric.sqlExpression;\n  }\n  return '';\n}\n\nexport default class AdhocFilter {\n  constructor(adhocFilter) {\n    this.expressionType = adhocFilter.expressionType || EXPRESSION_TYPES.SIMPLE;\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      this.subject = adhocFilter.subject;\n      this.operator = adhocFilter.operator?.toUpperCase();\n      this.operatorId = adhocFilter.operatorId;\n      this.comparator = adhocFilter.comparator;\n      if (\n        [Operators.IS_TRUE, Operators.IS_FALSE].indexOf(\n          adhocFilter.operatorId,\n        ) >= 0\n      ) {\n        this.comparator = adhocFilter.operatorId === Operators.IS_TRUE;\n      }\n      if (\n        [Operators.IS_NULL, Operators.IS_NOT_NULL].indexOf(\n          adhocFilter.operatorId,\n        ) >= 0\n      ) {\n        this.comparator = null;\n      }\n      this.clause = adhocFilter.clause || CLAUSES.WHERE;\n      this.sqlExpression = null;\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      this.sqlExpression =\n        typeof adhocFilter.sqlExpression === 'string'\n          ? adhocFilter.sqlExpression\n          : translateToSql(adhocFilter, { useSimple: true });\n      this.clause = adhocFilter.clause;\n      if (\n        adhocFilter.operator &&\n        CUSTOM_OPERATIONS.indexOf(adhocFilter.operator) >= 0\n      ) {\n        this.subject = adhocFilter.subject;\n        this.operator = adhocFilter.operator;\n        this.operatorId = adhocFilter.operatorId;\n      } else {\n        this.subject = null;\n        this.operator = null;\n      }\n      this.comparator = null;\n    }\n    this.isExtra = !!adhocFilter.isExtra;\n    this.isNew = !!adhocFilter.isNew;\n\n    this.filterOptionName =\n      adhocFilter.filterOptionName ||\n      `filter_${Math.random()\n        .toString(36)\n        .substring(2, 15)}_${Math.random().toString(36).substring(2, 15)}`;\n  }\n\n  duplicateWith(nextFields) {\n    return new AdhocFilter({\n      ...this,\n      // all duplicated fields are not new (i.e. will not open popup automatically)\n      isNew: false,\n      ...nextFields,\n    });\n  }\n\n  equals(adhocFilter) {\n    return (\n      adhocFilter.expressionType === this.expressionType &&\n      adhocFilter.sqlExpression === this.sqlExpression &&\n      adhocFilter.operator === this.operator &&\n      adhocFilter.operatorId === this.operatorId &&\n      adhocFilter.comparator === this.comparator &&\n      adhocFilter.subject === this.subject\n    );\n  }\n\n  isValid() {\n    const nullCheckOperators = [Operators.IS_NOT_NULL, Operators.IS_NULL].map(\n      op => OPERATOR_ENUM_TO_OPERATOR_TYPE[op].operation,\n    );\n    const truthCheckOperators = [Operators.IS_TRUE, Operators.IS_FALSE].map(\n      op => OPERATOR_ENUM_TO_OPERATOR_TYPE[op].operation,\n    );\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      if (nullCheckOperators.indexOf(this.operator) >= 0) {\n        return !!(this.operator && this.subject);\n      }\n      if (truthCheckOperators.indexOf(this.operator) >= 0) {\n        return !!(this.subject && this.comparator !== null);\n      }\n      if (this.operator && this.subject && this.clause) {\n        if (Array.isArray(this.comparator)) {\n          if (this.comparator.length > 0) {\n            // A non-empty array of values ('IN' or 'NOT IN' clauses)\n            return true;\n          }\n        } else if (this.comparator !== null) {\n          // A value has been selected or typed\n          return true;\n        }\n      }\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return !!(this.sqlExpression && this.clause);\n    }\n    return false;\n  }\n\n  getDefaultLabel() {\n    const label = this.translateToSql();\n    return label.length < 43 ? label : `${label.substring(0, 40)}...`;\n  }\n\n  getTooltipTitle() {\n    return this.translateToSql();\n  }\n\n  translateToSql() {\n    return translateToSql(this);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}