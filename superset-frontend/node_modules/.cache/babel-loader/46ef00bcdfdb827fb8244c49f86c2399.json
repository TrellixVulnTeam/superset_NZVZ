{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { interpolateRgb, piecewise, quantize } from 'd3-interpolate';\nimport { scaleSequential, scaleLinear } from 'd3-scale';\nimport SchemeWrapper from './SchemeWrapper';\n\nfunction isArrayOfArray(x) {\n  return Array.isArray(x[x.length - 1]);\n}\n\nexport default class ContinuousSchemeWrapper extends SchemeWrapper {\n  get colors() {\n    if ('colors' in this.scheme && typeof this.scheme.colors !== 'undefined') {\n      return this.scheme.colors;\n    }\n\n    return this.getColors();\n  }\n\n  get interpolator() {\n    if ('interpolator' in this.scheme && typeof this.scheme.interpolator !== 'undefined') {\n      return this.scheme.interpolator;\n    }\n\n    const colors = this.scheme.colors;\n    return piecewise(interpolateRgb, (isArrayOfArray(colors) ? colors[colors.length - 1] : colors).slice());\n  }\n  /**\n   * Get colors from this scheme\n   * @param numColors number of colors to return.\n   * Will interpolate the current scheme to match the number of colors requested\n   * @param extent The extent of the color range to use.\n   * For example [0.2, 1] will rescale the color scheme\n   * such that color values in the range [0, 0.2) are excluded from the scheme.\n   */\n\n\n  getColors(numColors = 2, extent = [0, 1]) {\n    if ('colors' in this.scheme && typeof this.scheme.colors !== 'undefined' && extent[0] === 0 && extent[1] === 1) {\n      const {\n        colors } =\n      this.scheme;\n\n      if (isArrayOfArray(colors)) {\n        if (typeof colors[numColors] !== 'undefined') {\n          return colors[numColors].slice();\n        }\n      } else if (numColors === colors.length) {\n        return colors.slice();\n      }\n    }\n\n    const {\n      interpolator } =\n    this;\n    const adjustExtent = scaleLinear().range(extent).clamp(true);\n    return quantize((t) => interpolator(adjustExtent(t)), numColors);\n  }\n\n  createScaleLinear() {\n    // The manual casting is necessary until @types/d3-scale is corrected\n    // In recent version of d3-scale the output from scaleSequential is compatible with linear scale\n    // (It has .range(),  ...)\n    return scaleSequential(this.interpolator);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(isArrayOfArray, \"isArrayOfArray\", \"/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/color/esm/scheme/wrappers/ContinuousSchemeWrapper.js\");reactHotLoader.register(ContinuousSchemeWrapper, \"ContinuousSchemeWrapper\", \"/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/color/esm/scheme/wrappers/ContinuousSchemeWrapper.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/color/esm/scheme/wrappers/ContinuousSchemeWrapper.js"],"names":["interpolateRgb","piecewise","quantize","scaleSequential","scaleLinear","SchemeWrapper","isArrayOfArray","x","Array","isArray","length","ContinuousSchemeWrapper","colors","scheme","getColors","interpolator","slice","numColors","extent","adjustExtent","range","clamp","t","createScaleLinear"],"mappings":"uSAAA,SAASA,cAAT,EAAyBC,SAAzB,EAAoCC,QAApC,QAAoD,gBAApD;AACA,SAASC,eAAT,EAA0BC,WAA1B,QAA6C,UAA7C;AACA,OAAOC,aAAP,MAA0B,iBAA1B;;AAEA,SAASC,cAAT,CAAwBC,CAAxB,EAA2B;AACzB,SAAOC,KAAK,CAACC,OAAN,CAAcF,CAAC,CAACA,CAAC,CAACG,MAAF,GAAW,CAAZ,CAAf,CAAP;AACD;;AAED,eAAe,MAAMC,uBAAN,SAAsCN,aAAtC,CAAoD;AACvD,MAANO,MAAM,GAAG;AACX,QAAI,YAAY,KAAKC,MAAjB,IAA2B,OAAO,KAAKA,MAAL,CAAYD,MAAnB,KAA8B,WAA7D,EAA0E;AACxE,aAAO,KAAKC,MAAL,CAAYD,MAAnB;AACD;;AAED,WAAO,KAAKE,SAAL,EAAP;AACD;;AAEe,MAAZC,YAAY,GAAG;AACjB,QAAI,kBAAkB,KAAKF,MAAvB,IAAiC,OAAO,KAAKA,MAAL,CAAYE,YAAnB,KAAoC,WAAzE,EAAsF;AACpF,aAAO,KAAKF,MAAL,CAAYE,YAAnB;AACD;;AAED,UAAMH,MAAM,GAAG,KAAKC,MAAL,CAAYD,MAA3B;AACA,WAAOX,SAAS,CAACD,cAAD,EAAiB,CAACM,cAAc,CAACM,MAAD,CAAd,GAAyBA,MAAM,CAACA,MAAM,CAACF,MAAP,GAAgB,CAAjB,CAA/B,GAAqDE,MAAtD,EAA8DI,KAA9D,EAAjB,CAAhB;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGEF,EAAAA,SAAS,CAACG,SAAS,GAAG,CAAb,EAAgBC,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAzB,EAAiC;AACxC,QAAI,YAAY,KAAKL,MAAjB,IAA2B,OAAO,KAAKA,MAAL,CAAYD,MAAnB,KAA8B,WAAzD,IAAwEM,MAAM,CAAC,CAAD,CAAN,KAAc,CAAtF,IAA2FA,MAAM,CAAC,CAAD,CAAN,KAAc,CAA7G,EAAgH;AAC9G,YAAM;AACJN,QAAAA,MADI;AAEF,WAAKC,MAFT;;AAIA,UAAIP,cAAc,CAACM,MAAD,CAAlB,EAA4B;AAC1B,YAAI,OAAOA,MAAM,CAACK,SAAD,CAAb,KAA6B,WAAjC,EAA8C;AAC5C,iBAAOL,MAAM,CAACK,SAAD,CAAN,CAAkBD,KAAlB,EAAP;AACD;AACF,OAJD,MAIO,IAAIC,SAAS,KAAKL,MAAM,CAACF,MAAzB,EAAiC;AACtC,eAAOE,MAAM,CAACI,KAAP,EAAP;AACD;AACF;;AAED,UAAM;AACJD,MAAAA,YADI;AAEF,QAFJ;AAGA,UAAMI,YAAY,GAAGf,WAAW,GAAGgB,KAAd,CAAoBF,MAApB,EAA4BG,KAA5B,CAAkC,IAAlC,CAArB;AACA,WAAOnB,QAAQ,CAAC,CAAAoB,CAAC,KAAIP,YAAY,CAACI,YAAY,CAACG,CAAD,CAAb,CAAlB,EAAqCL,SAArC,CAAf;AACD;;AAEDM,EAAAA,iBAAiB,GAAG;AAClB;AACA;AACA;AACA,WAAOpB,eAAe,CAAC,KAAKY,YAAN,CAAtB;AACD,GAtDgE;AAAA;AAAA,6B,iLAJ1DT,c,8KAIYK,uB","sourcesContent":["import { interpolateRgb, piecewise, quantize } from 'd3-interpolate';\nimport { scaleSequential, scaleLinear } from 'd3-scale';\nimport SchemeWrapper from './SchemeWrapper';\n\nfunction isArrayOfArray(x) {\n  return Array.isArray(x[x.length - 1]);\n}\n\nexport default class ContinuousSchemeWrapper extends SchemeWrapper {\n  get colors() {\n    if ('colors' in this.scheme && typeof this.scheme.colors !== 'undefined') {\n      return this.scheme.colors;\n    }\n\n    return this.getColors();\n  }\n\n  get interpolator() {\n    if ('interpolator' in this.scheme && typeof this.scheme.interpolator !== 'undefined') {\n      return this.scheme.interpolator;\n    }\n\n    const colors = this.scheme.colors;\n    return piecewise(interpolateRgb, (isArrayOfArray(colors) ? colors[colors.length - 1] : colors).slice());\n  }\n  /**\n   * Get colors from this scheme\n   * @param numColors number of colors to return.\n   * Will interpolate the current scheme to match the number of colors requested\n   * @param extent The extent of the color range to use.\n   * For example [0.2, 1] will rescale the color scheme\n   * such that color values in the range [0, 0.2) are excluded from the scheme.\n   */\n\n\n  getColors(numColors = 2, extent = [0, 1]) {\n    if ('colors' in this.scheme && typeof this.scheme.colors !== 'undefined' && extent[0] === 0 && extent[1] === 1) {\n      const {\n        colors\n      } = this.scheme;\n\n      if (isArrayOfArray(colors)) {\n        if (typeof colors[numColors] !== 'undefined') {\n          return colors[numColors].slice();\n        }\n      } else if (numColors === colors.length) {\n        return colors.slice();\n      }\n    }\n\n    const {\n      interpolator\n    } = this;\n    const adjustExtent = scaleLinear().range(extent).clamp(true);\n    return quantize(t => interpolator(adjustExtent(t)), numColors);\n  }\n\n  createScaleLinear() {\n    // The manual casting is necessary until @types/d3-scale is corrected\n    // In recent version of d3-scale the output from scaleSequential is compatible with linear scale\n    // (It has .range(),  ...)\n    return scaleSequential(this.interpolator);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}