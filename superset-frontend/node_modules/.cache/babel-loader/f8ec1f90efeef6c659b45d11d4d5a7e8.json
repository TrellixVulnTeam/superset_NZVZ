{"ast":null,"code":"import _isString from \"lodash/isString\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport {\nBehavior,\nCategoricalColorNamespace,\ngetChartMetadataRegistry } from\n'@superset-ui/core';\n\nimport { chart } from 'src/chart/chartReducer';\nimport { initSliceEntities } from 'src/dashboard/reducers/sliceEntities';\nimport { getInitialState as getInitialNativeFilterState } from 'src/dashboard/reducers/nativeFilters';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport { buildActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport findPermission, {\ncanUserEditDashboard } from\n'src/dashboard/util/findPermission';\nimport {\nDASHBOARD_FILTER_SCOPE_GLOBAL,\ndashboardFilter } from\n'src/dashboard/reducers/dashboardFilters';\nimport {\nDASHBOARD_HEADER_ID,\nGRID_DEFAULT_CHART_WIDTH,\nGRID_COLUMN_COUNT,\nDASHBOARD_ROOT_ID } from\n'src/dashboard/util/constants';\nimport {\nDASHBOARD_HEADER_TYPE,\nCHART_TYPE,\nROW_TYPE } from\n'src/dashboard/util/componentTypes';\nimport findFirstParentContainerId from 'src/dashboard/util/findFirstParentContainer';\nimport getEmptyLayout from 'src/dashboard/util/getEmptyLayout';\nimport getFilterConfigsFromFormdata from 'src/dashboard/util/getFilterConfigsFromFormdata';\nimport getLocationHash from 'src/dashboard/util/getLocationHash';\nimport newComponentFactory from 'src/dashboard/util/newComponentFactory';\nimport { TIME_RANGE } from 'src/visualizations/FilterBox/FilterBox';\nimport { URL_PARAMS } from 'src/constants';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport { FeatureFlag, isFeatureEnabled } from '../../featureFlags';\nimport extractUrlParams from '../util/extractUrlParams';\n\nexport const HYDRATE_DASHBOARD = 'HYDRATE_DASHBOARD';\n\nexport const hydrateDashboard = (dashboardData, chartData) => (\ndispatch,\ngetState) =>\n{var _metadata, _metadata2, _metadata3, _metadata4, _dashboardData$metada, _dashboardData$metada2, _metadata5, _metadata6, _metadata7, _metadata8;\n  const { user, common } = getState();\n  let { metadata } = dashboardData;\n  const regularUrlParams = extractUrlParams('regular');\n  const reservedUrlParams = extractUrlParams('reserved');\n  const editMode = reservedUrlParams.edit === 'true';\n\n  let preselectFilters = {};\n\n  chartData.forEach((chart) => {\n    // eslint-disable-next-line no-param-reassign\n    chart.slice_id = chart.form_data.slice_id;\n  });\n  try {\n    // allow request parameter overwrite dashboard metadata\n    preselectFilters =\n    getUrlParam(URL_PARAMS.preselectFilters) ||\n    JSON.parse(metadata.default_filters);\n  } catch (e) {\n    //\n  }\n\n  // Priming the color palette with user's label-color mapping provided in\n  // the dashboard's JSON metadata\n  if ((_metadata = metadata) != null && _metadata.label_colors) {\n    const namespace = metadata.color_namespace;\n    const colorMap = _isString(metadata.label_colors) ?\n    JSON.parse(metadata.label_colors) :\n    metadata.label_colors;\n    const categoricalNamespace = CategoricalColorNamespace.getNamespace(\n    namespace);\n\n\n    Object.keys(colorMap).forEach((label) => {\n      categoricalNamespace.setColor(label, colorMap[label]);\n    });\n  }\n\n  // dashboard layout\n  const { position_data } = dashboardData;\n  // new dash: position_json could be {} or null\n  const layout =\n  position_data && Object.keys(position_data).length > 0 ?\n  position_data :\n  getEmptyLayout();\n\n  // create a lookup to sync layout names with slice names\n  const chartIdToLayoutId = {};\n  Object.values(layout).forEach((layoutComponent) => {\n    if (layoutComponent.type === CHART_TYPE) {\n      chartIdToLayoutId[layoutComponent.meta.chartId] = layoutComponent.id;\n    }\n  });\n\n  // find root level chart container node for newly-added slices\n  const parentId = findFirstParentContainerId(layout);\n  const parent = layout[parentId];\n  let newSlicesContainer;\n  let newSlicesContainerWidth = 0;\n\n  const filterScopes = ((_metadata2 = metadata) == null ? void 0 : _metadata2.filter_scopes) || {};\n\n  const chartQueries = {};\n  const dashboardFilters = {};\n  const slices = {};\n  const sliceIds = new Set();\n  chartData.forEach((slice) => {\n    const key = slice.slice_id;\n    const form_data = {\n      ...slice.form_data,\n      url_params: {\n        ...slice.form_data.url_params,\n        ...regularUrlParams } };\n\n\n    chartQueries[key] = {\n      ...chart,\n      id: key,\n      form_data,\n      formData: applyDefaultFormData(form_data) };\n\n\n    slices[key] = {\n      slice_id: key,\n      slice_url: slice.slice_url,\n      slice_name: slice.slice_name,\n      form_data: slice.form_data,\n      viz_type: slice.form_data.viz_type,\n      datasource: slice.form_data.datasource,\n      description: slice.description,\n      description_markeddown: slice.description_markeddown,\n      owners: slice.owners,\n      modified: slice.modified,\n      changed_on: new Date(slice.changed_on).getTime() };\n\n\n    sliceIds.add(key);\n\n    // if there are newly added slices from explore view, fill slices into 1 or more rows\n    if (!chartIdToLayoutId[key] && layout[parentId]) {\n      if (\n      newSlicesContainerWidth === 0 ||\n      newSlicesContainerWidth + GRID_DEFAULT_CHART_WIDTH > GRID_COLUMN_COUNT)\n      {\n        newSlicesContainer = newComponentFactory(\n        ROW_TYPE,\n        (parent.parents || []).slice());\n\n        layout[newSlicesContainer.id] = newSlicesContainer;\n        parent.children.push(newSlicesContainer.id);\n        newSlicesContainerWidth = 0;\n      }\n\n      const chartHolder = newComponentFactory(\n      CHART_TYPE,\n      {\n        chartId: slice.slice_id },\n\n      (newSlicesContainer.parents || []).slice());\n\n\n      layout[chartHolder.id] = chartHolder;\n      newSlicesContainer.children.push(chartHolder.id);\n      chartIdToLayoutId[chartHolder.meta.chartId] = chartHolder.id;\n      newSlicesContainerWidth += GRID_DEFAULT_CHART_WIDTH;\n    }\n\n    // build DashboardFilters for interactive filter features\n    if (slice.form_data.viz_type === 'filter_box') {\n      const configs = getFilterConfigsFromFormdata(slice.form_data);\n      let { columns } = configs;\n      const { labels } = configs;\n      if (preselectFilters[key]) {\n        Object.keys(columns).forEach((col) => {\n          if (preselectFilters[key][col]) {\n            columns = {\n              ...columns,\n              [col]: preselectFilters[key][col] };\n\n          }\n        });\n      }\n\n      const scopesByChartId = Object.keys(columns).reduce((map, column) => {\n        const scopeSettings = {\n          ...filterScopes[key] };\n\n        const { scope, immune } = {\n          ...DASHBOARD_FILTER_SCOPE_GLOBAL,\n          ...scopeSettings[column] };\n\n\n        return {\n          ...map,\n          [column]: {\n            scope,\n            immune } };\n\n\n      }, {});\n\n      const componentId = chartIdToLayoutId[key];\n      const directPathToFilter = (layout[componentId].parents || []).slice();\n      directPathToFilter.push(componentId);\n      dashboardFilters[key] = {\n        ...dashboardFilter,\n        chartId: key,\n        componentId,\n        datasourceId: slice.form_data.datasource,\n        filterName: slice.slice_name,\n        directPathToFilter,\n        columns,\n        labels,\n        scopes: scopesByChartId,\n        isInstantFilter: !!slice.form_data.instant_filtering,\n        isDateFilter: Object.keys(columns).includes(TIME_RANGE) };\n\n    }\n\n    // sync layout names with current slice names in case a slice was edited\n    // in explore since the layout was updated. name updates go through layout for undo/redo\n    // functionality and python updates slice names based on layout upon dashboard save\n    const layoutId = chartIdToLayoutId[key];\n    if (layoutId && layout[layoutId]) {\n      layout[layoutId].meta.sliceName = slice.slice_name;\n    }\n  });\n  buildActiveFilters({\n    dashboardFilters,\n    components: layout });\n\n\n  // store the header as a layout component so we can undo/redo changes\n  layout[DASHBOARD_HEADER_ID] = {\n    id: DASHBOARD_HEADER_ID,\n    type: DASHBOARD_HEADER_TYPE,\n    meta: {\n      text: dashboardData.dashboard_title } };\n\n\n\n  const dashboardLayout = {\n    past: [],\n    present: layout,\n    future: [] };\n\n\n  // find direct link component and path from root\n  const directLinkComponentId = getLocationHash();\n  let directPathToChild = [];\n  if (layout[directLinkComponentId]) {\n    directPathToChild = (layout[directLinkComponentId].parents || []).slice();\n    directPathToChild.push(directLinkComponentId);\n  }\n\n  const nativeFilters = getInitialNativeFilterState({\n    filterConfig: ((_metadata3 = metadata) == null ? void 0 : _metadata3.native_filter_configuration) || [],\n    filterSetsConfig: ((_metadata4 = metadata) == null ? void 0 : _metadata4.filter_sets_configuration) || [] });\n\n\n  if (!metadata) {\n    metadata = {};\n  }\n\n  metadata.show_native_filters = (_dashboardData$metada =\n  dashboardData == null ? void 0 : (_dashboardData$metada2 = dashboardData.metadata) == null ? void 0 : _dashboardData$metada2.show_native_filters) != null ? _dashboardData$metada :\n  isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS);\n\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    // If user just added cross filter to dashboard it's not saving it scope on server,\n    // so we tweak it until user will update scope and will save it in server\n    Object.values(dashboardLayout.present).forEach((layoutItem) => {var _layoutItem$meta, _behaviors, _ref, _getChartMetadataRegi, _chartQueries$chartId, _chartQueries$chartId2;\n      const chartId = (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId;\n      const behaviors = (_behaviors = (_ref = (_getChartMetadataRegi =\n\n      getChartMetadataRegistry().get((_chartQueries$chartId =\n      chartQueries[chartId]) == null ? void 0 : (_chartQueries$chartId2 = _chartQueries$chartId.formData) == null ? void 0 : _chartQueries$chartId2.viz_type)) != null ? _getChartMetadataRegi :\n      {}) == null ? void 0 : _ref.\n      behaviors) != null ? _behaviors : [];\n\n      if (!metadata.chart_configuration) {\n        metadata.chart_configuration = {};\n      }\n      if (\n      behaviors.includes(Behavior.INTERACTIVE_CHART) &&\n      !metadata.chart_configuration[chartId])\n      {\n        metadata.chart_configuration[chartId] = {\n          id: chartId,\n          crossFilters: {\n            scope: {\n              rootPath: [DASHBOARD_ROOT_ID],\n              excluded: [chartId] // By default it doesn't affects itself\n            } } };\n\n\n      }\n    });\n  }\n\n  const { roles } = user;\n  const canEdit = canUserEditDashboard(dashboardData, user);\n\n  return dispatch({\n    type: HYDRATE_DASHBOARD,\n    data: {\n      sliceEntities: { ...initSliceEntities, slices, isLoading: false },\n      charts: chartQueries,\n      // read-only data\n      dashboardInfo: {\n        ...dashboardData,\n        metadata,\n        userId: user.userId ? String(user.userId) : null, // legacy, please use state.user instead\n        dash_edit_perm: canEdit,\n        dash_save_perm: findPermission('can_save_dash', 'Superset', roles),\n        dash_share_perm: findPermission(\n        'can_share_dashboard',\n        'Superset',\n        roles),\n\n        superset_can_explore: findPermission('can_explore', 'Superset', roles),\n        superset_can_share: findPermission(\n        'can_share_chart',\n        'Superset',\n        roles),\n\n        superset_can_csv: findPermission('can_csv', 'Superset', roles),\n        slice_can_edit: findPermission('can_slice', 'Superset', roles),\n        common: {\n          // legacy, please use state.common instead\n          flash_messages: common.flash_messages,\n          conf: common.conf } },\n\n\n      dashboardFilters,\n      nativeFilters,\n      dashboardState: {\n        preselectNativeFilters: getUrlParam(URL_PARAMS.nativeFilters),\n        sliceIds: Array.from(sliceIds),\n        directPathToChild,\n        directPathLastUpdated: Date.now(),\n        focusedFilterField: null,\n        expandedSlices: ((_metadata5 = metadata) == null ? void 0 : _metadata5.expanded_slices) || {},\n        refreshFrequency: ((_metadata6 = metadata) == null ? void 0 : _metadata6.refresh_frequency) || 0,\n        // dashboard viewers can set refresh frequency for the current visit,\n        // only persistent refreshFrequency will be saved to backend\n        shouldPersistRefreshFrequency: false,\n        css: dashboardData.css || '',\n        colorNamespace: ((_metadata7 = metadata) == null ? void 0 : _metadata7.color_namespace) || null,\n        colorScheme: ((_metadata8 = metadata) == null ? void 0 : _metadata8.color_scheme) || null,\n        editMode: canEdit && editMode,\n        isPublished: dashboardData.published,\n        hasUnsavedChanges: false,\n        maxUndoHistoryExceeded: false,\n        lastModifiedTime: dashboardData.changed_on,\n        isRefreshing: false,\n        activeTabs: [] },\n\n      dashboardLayout } });\n\n\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(HYDRATE_DASHBOARD, \"HYDRATE_DASHBOARD\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/actions/hydrate.js\");reactHotLoader.register(hydrateDashboard, \"hydrateDashboard\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/actions/hydrate.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/actions/hydrate.js"],"names":["Behavior","CategoricalColorNamespace","getChartMetadataRegistry","chart","initSliceEntities","getInitialState","getInitialNativeFilterState","applyDefaultFormData","buildActiveFilters","findPermission","canUserEditDashboard","DASHBOARD_FILTER_SCOPE_GLOBAL","dashboardFilter","DASHBOARD_HEADER_ID","GRID_DEFAULT_CHART_WIDTH","GRID_COLUMN_COUNT","DASHBOARD_ROOT_ID","DASHBOARD_HEADER_TYPE","CHART_TYPE","ROW_TYPE","findFirstParentContainerId","getEmptyLayout","getFilterConfigsFromFormdata","getLocationHash","newComponentFactory","TIME_RANGE","URL_PARAMS","getUrlParam","FeatureFlag","isFeatureEnabled","extractUrlParams","HYDRATE_DASHBOARD","hydrateDashboard","dashboardData","chartData","dispatch","getState","user","common","metadata","regularUrlParams","reservedUrlParams","editMode","edit","preselectFilters","forEach","slice_id","form_data","JSON","parse","default_filters","e","label_colors","namespace","color_namespace","colorMap","categoricalNamespace","getNamespace","Object","keys","label","setColor","position_data","layout","length","chartIdToLayoutId","values","layoutComponent","type","meta","chartId","id","parentId","parent","newSlicesContainer","newSlicesContainerWidth","filterScopes","filter_scopes","chartQueries","dashboardFilters","slices","sliceIds","Set","slice","key","url_params","formData","slice_url","slice_name","viz_type","datasource","description","description_markeddown","owners","modified","changed_on","Date","getTime","add","parents","children","push","chartHolder","configs","columns","labels","col","scopesByChartId","reduce","map","column","scopeSettings","scope","immune","componentId","directPathToFilter","datasourceId","filterName","scopes","isInstantFilter","instant_filtering","isDateFilter","includes","layoutId","sliceName","components","text","dashboard_title","dashboardLayout","past","present","future","directLinkComponentId","directPathToChild","nativeFilters","filterConfig","native_filter_configuration","filterSetsConfig","filter_sets_configuration","show_native_filters","DASHBOARD_NATIVE_FILTERS","DASHBOARD_CROSS_FILTERS","layoutItem","behaviors","get","chart_configuration","INTERACTIVE_CHART","crossFilters","rootPath","excluded","roles","canEdit","data","sliceEntities","isLoading","charts","dashboardInfo","userId","String","dash_edit_perm","dash_save_perm","dash_share_perm","superset_can_explore","superset_can_share","superset_can_csv","slice_can_edit","flash_messages","conf","dashboardState","preselectNativeFilters","Array","from","directPathLastUpdated","now","focusedFilterField","expandedSlices","expanded_slices","refreshFrequency","refresh_frequency","shouldPersistRefreshFrequency","css","colorNamespace","colorScheme","color_scheme","isPublished","published","hasUnsavedChanges","maxUndoHistoryExceeded","lastModifiedTime","isRefreshing","activeTabs"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { isString } from 'lodash';\nimport {\n  Behavior,\n  CategoricalColorNamespace,\n  getChartMetadataRegistry,\n} from '@superset-ui/core';\n\nimport { chart } from 'src/chart/chartReducer';\nimport { initSliceEntities } from 'src/dashboard/reducers/sliceEntities';\nimport { getInitialState as getInitialNativeFilterState } from 'src/dashboard/reducers/nativeFilters';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport { buildActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport findPermission, {\n  canUserEditDashboard,\n} from 'src/dashboard/util/findPermission';\nimport {\n  DASHBOARD_FILTER_SCOPE_GLOBAL,\n  dashboardFilter,\n} from 'src/dashboard/reducers/dashboardFilters';\nimport {\n  DASHBOARD_HEADER_ID,\n  GRID_DEFAULT_CHART_WIDTH,\n  GRID_COLUMN_COUNT,\n  DASHBOARD_ROOT_ID,\n} from 'src/dashboard/util/constants';\nimport {\n  DASHBOARD_HEADER_TYPE,\n  CHART_TYPE,\n  ROW_TYPE,\n} from 'src/dashboard/util/componentTypes';\nimport findFirstParentContainerId from 'src/dashboard/util/findFirstParentContainer';\nimport getEmptyLayout from 'src/dashboard/util/getEmptyLayout';\nimport getFilterConfigsFromFormdata from 'src/dashboard/util/getFilterConfigsFromFormdata';\nimport getLocationHash from 'src/dashboard/util/getLocationHash';\nimport newComponentFactory from 'src/dashboard/util/newComponentFactory';\nimport { TIME_RANGE } from 'src/visualizations/FilterBox/FilterBox';\nimport { URL_PARAMS } from 'src/constants';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport { FeatureFlag, isFeatureEnabled } from '../../featureFlags';\nimport extractUrlParams from '../util/extractUrlParams';\n\nexport const HYDRATE_DASHBOARD = 'HYDRATE_DASHBOARD';\n\nexport const hydrateDashboard = (dashboardData, chartData) => (\n  dispatch,\n  getState,\n) => {\n  const { user, common } = getState();\n  let { metadata } = dashboardData;\n  const regularUrlParams = extractUrlParams('regular');\n  const reservedUrlParams = extractUrlParams('reserved');\n  const editMode = reservedUrlParams.edit === 'true';\n\n  let preselectFilters = {};\n\n  chartData.forEach(chart => {\n    // eslint-disable-next-line no-param-reassign\n    chart.slice_id = chart.form_data.slice_id;\n  });\n  try {\n    // allow request parameter overwrite dashboard metadata\n    preselectFilters =\n      getUrlParam(URL_PARAMS.preselectFilters) ||\n      JSON.parse(metadata.default_filters);\n  } catch (e) {\n    //\n  }\n\n  // Priming the color palette with user's label-color mapping provided in\n  // the dashboard's JSON metadata\n  if (metadata?.label_colors) {\n    const namespace = metadata.color_namespace;\n    const colorMap = isString(metadata.label_colors)\n      ? JSON.parse(metadata.label_colors)\n      : metadata.label_colors;\n    const categoricalNamespace = CategoricalColorNamespace.getNamespace(\n      namespace,\n    );\n\n    Object.keys(colorMap).forEach(label => {\n      categoricalNamespace.setColor(label, colorMap[label]);\n    });\n  }\n\n  // dashboard layout\n  const { position_data } = dashboardData;\n  // new dash: position_json could be {} or null\n  const layout =\n    position_data && Object.keys(position_data).length > 0\n      ? position_data\n      : getEmptyLayout();\n\n  // create a lookup to sync layout names with slice names\n  const chartIdToLayoutId = {};\n  Object.values(layout).forEach(layoutComponent => {\n    if (layoutComponent.type === CHART_TYPE) {\n      chartIdToLayoutId[layoutComponent.meta.chartId] = layoutComponent.id;\n    }\n  });\n\n  // find root level chart container node for newly-added slices\n  const parentId = findFirstParentContainerId(layout);\n  const parent = layout[parentId];\n  let newSlicesContainer;\n  let newSlicesContainerWidth = 0;\n\n  const filterScopes = metadata?.filter_scopes || {};\n\n  const chartQueries = {};\n  const dashboardFilters = {};\n  const slices = {};\n  const sliceIds = new Set();\n  chartData.forEach(slice => {\n    const key = slice.slice_id;\n    const form_data = {\n      ...slice.form_data,\n      url_params: {\n        ...slice.form_data.url_params,\n        ...regularUrlParams,\n      },\n    };\n    chartQueries[key] = {\n      ...chart,\n      id: key,\n      form_data,\n      formData: applyDefaultFormData(form_data),\n    };\n\n    slices[key] = {\n      slice_id: key,\n      slice_url: slice.slice_url,\n      slice_name: slice.slice_name,\n      form_data: slice.form_data,\n      viz_type: slice.form_data.viz_type,\n      datasource: slice.form_data.datasource,\n      description: slice.description,\n      description_markeddown: slice.description_markeddown,\n      owners: slice.owners,\n      modified: slice.modified,\n      changed_on: new Date(slice.changed_on).getTime(),\n    };\n\n    sliceIds.add(key);\n\n    // if there are newly added slices from explore view, fill slices into 1 or more rows\n    if (!chartIdToLayoutId[key] && layout[parentId]) {\n      if (\n        newSlicesContainerWidth === 0 ||\n        newSlicesContainerWidth + GRID_DEFAULT_CHART_WIDTH > GRID_COLUMN_COUNT\n      ) {\n        newSlicesContainer = newComponentFactory(\n          ROW_TYPE,\n          (parent.parents || []).slice(),\n        );\n        layout[newSlicesContainer.id] = newSlicesContainer;\n        parent.children.push(newSlicesContainer.id);\n        newSlicesContainerWidth = 0;\n      }\n\n      const chartHolder = newComponentFactory(\n        CHART_TYPE,\n        {\n          chartId: slice.slice_id,\n        },\n        (newSlicesContainer.parents || []).slice(),\n      );\n\n      layout[chartHolder.id] = chartHolder;\n      newSlicesContainer.children.push(chartHolder.id);\n      chartIdToLayoutId[chartHolder.meta.chartId] = chartHolder.id;\n      newSlicesContainerWidth += GRID_DEFAULT_CHART_WIDTH;\n    }\n\n    // build DashboardFilters for interactive filter features\n    if (slice.form_data.viz_type === 'filter_box') {\n      const configs = getFilterConfigsFromFormdata(slice.form_data);\n      let { columns } = configs;\n      const { labels } = configs;\n      if (preselectFilters[key]) {\n        Object.keys(columns).forEach(col => {\n          if (preselectFilters[key][col]) {\n            columns = {\n              ...columns,\n              [col]: preselectFilters[key][col],\n            };\n          }\n        });\n      }\n\n      const scopesByChartId = Object.keys(columns).reduce((map, column) => {\n        const scopeSettings = {\n          ...filterScopes[key],\n        };\n        const { scope, immune } = {\n          ...DASHBOARD_FILTER_SCOPE_GLOBAL,\n          ...scopeSettings[column],\n        };\n\n        return {\n          ...map,\n          [column]: {\n            scope,\n            immune,\n          },\n        };\n      }, {});\n\n      const componentId = chartIdToLayoutId[key];\n      const directPathToFilter = (layout[componentId].parents || []).slice();\n      directPathToFilter.push(componentId);\n      dashboardFilters[key] = {\n        ...dashboardFilter,\n        chartId: key,\n        componentId,\n        datasourceId: slice.form_data.datasource,\n        filterName: slice.slice_name,\n        directPathToFilter,\n        columns,\n        labels,\n        scopes: scopesByChartId,\n        isInstantFilter: !!slice.form_data.instant_filtering,\n        isDateFilter: Object.keys(columns).includes(TIME_RANGE),\n      };\n    }\n\n    // sync layout names with current slice names in case a slice was edited\n    // in explore since the layout was updated. name updates go through layout for undo/redo\n    // functionality and python updates slice names based on layout upon dashboard save\n    const layoutId = chartIdToLayoutId[key];\n    if (layoutId && layout[layoutId]) {\n      layout[layoutId].meta.sliceName = slice.slice_name;\n    }\n  });\n  buildActiveFilters({\n    dashboardFilters,\n    components: layout,\n  });\n\n  // store the header as a layout component so we can undo/redo changes\n  layout[DASHBOARD_HEADER_ID] = {\n    id: DASHBOARD_HEADER_ID,\n    type: DASHBOARD_HEADER_TYPE,\n    meta: {\n      text: dashboardData.dashboard_title,\n    },\n  };\n\n  const dashboardLayout = {\n    past: [],\n    present: layout,\n    future: [],\n  };\n\n  // find direct link component and path from root\n  const directLinkComponentId = getLocationHash();\n  let directPathToChild = [];\n  if (layout[directLinkComponentId]) {\n    directPathToChild = (layout[directLinkComponentId].parents || []).slice();\n    directPathToChild.push(directLinkComponentId);\n  }\n\n  const nativeFilters = getInitialNativeFilterState({\n    filterConfig: metadata?.native_filter_configuration || [],\n    filterSetsConfig: metadata?.filter_sets_configuration || [],\n  });\n\n  if (!metadata) {\n    metadata = {};\n  }\n\n  metadata.show_native_filters =\n    dashboardData?.metadata?.show_native_filters ??\n    isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS);\n\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    // If user just added cross filter to dashboard it's not saving it scope on server,\n    // so we tweak it until user will update scope and will save it in server\n    Object.values(dashboardLayout.present).forEach(layoutItem => {\n      const chartId = layoutItem.meta?.chartId;\n      const behaviors =\n        (\n          getChartMetadataRegistry().get(\n            chartQueries[chartId]?.formData?.viz_type,\n          ) ?? {}\n        )?.behaviors ?? [];\n\n      if (!metadata.chart_configuration) {\n        metadata.chart_configuration = {};\n      }\n      if (\n        behaviors.includes(Behavior.INTERACTIVE_CHART) &&\n        !metadata.chart_configuration[chartId]\n      ) {\n        metadata.chart_configuration[chartId] = {\n          id: chartId,\n          crossFilters: {\n            scope: {\n              rootPath: [DASHBOARD_ROOT_ID],\n              excluded: [chartId], // By default it doesn't affects itself\n            },\n          },\n        };\n      }\n    });\n  }\n\n  const { roles } = user;\n  const canEdit = canUserEditDashboard(dashboardData, user);\n\n  return dispatch({\n    type: HYDRATE_DASHBOARD,\n    data: {\n      sliceEntities: { ...initSliceEntities, slices, isLoading: false },\n      charts: chartQueries,\n      // read-only data\n      dashboardInfo: {\n        ...dashboardData,\n        metadata,\n        userId: user.userId ? String(user.userId) : null, // legacy, please use state.user instead\n        dash_edit_perm: canEdit,\n        dash_save_perm: findPermission('can_save_dash', 'Superset', roles),\n        dash_share_perm: findPermission(\n          'can_share_dashboard',\n          'Superset',\n          roles,\n        ),\n        superset_can_explore: findPermission('can_explore', 'Superset', roles),\n        superset_can_share: findPermission(\n          'can_share_chart',\n          'Superset',\n          roles,\n        ),\n        superset_can_csv: findPermission('can_csv', 'Superset', roles),\n        slice_can_edit: findPermission('can_slice', 'Superset', roles),\n        common: {\n          // legacy, please use state.common instead\n          flash_messages: common.flash_messages,\n          conf: common.conf,\n        },\n      },\n      dashboardFilters,\n      nativeFilters,\n      dashboardState: {\n        preselectNativeFilters: getUrlParam(URL_PARAMS.nativeFilters),\n        sliceIds: Array.from(sliceIds),\n        directPathToChild,\n        directPathLastUpdated: Date.now(),\n        focusedFilterField: null,\n        expandedSlices: metadata?.expanded_slices || {},\n        refreshFrequency: metadata?.refresh_frequency || 0,\n        // dashboard viewers can set refresh frequency for the current visit,\n        // only persistent refreshFrequency will be saved to backend\n        shouldPersistRefreshFrequency: false,\n        css: dashboardData.css || '',\n        colorNamespace: metadata?.color_namespace || null,\n        colorScheme: metadata?.color_scheme || null,\n        editMode: canEdit && editMode,\n        isPublished: dashboardData.published,\n        hasUnsavedChanges: false,\n        maxUndoHistoryExceeded: false,\n        lastModifiedTime: dashboardData.changed_on,\n        isRefreshing: false,\n        activeTabs: [],\n      },\n      dashboardLayout,\n    },\n  });\n};\n"]},"metadata":{},"sourceType":"module"}