{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import _isString from \"lodash/isString\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport {\nBehavior,\nCategoricalColorNamespace,\ngetChartMetadataRegistry } from\n'@superset-ui/core';\n\nimport { chart } from 'src/chart/chartReducer';\nimport { initSliceEntities } from 'src/dashboard/reducers/sliceEntities';\nimport { getInitialState as getInitialNativeFilterState } from 'src/dashboard/reducers/nativeFilters';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport { buildActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport findPermission, {\ncanUserEditDashboard } from\n'src/dashboard/util/findPermission';\nimport {\nDASHBOARD_FILTER_SCOPE_GLOBAL,\ndashboardFilter } from\n'src/dashboard/reducers/dashboardFilters';\nimport {\nDASHBOARD_HEADER_ID,\nGRID_DEFAULT_CHART_WIDTH,\nGRID_COLUMN_COUNT,\nDASHBOARD_ROOT_ID } from\n'src/dashboard/util/constants';\nimport {\nDASHBOARD_HEADER_TYPE,\nCHART_TYPE,\nROW_TYPE } from\n'src/dashboard/util/componentTypes';\nimport findFirstParentContainerId from 'src/dashboard/util/findFirstParentContainer';\nimport getEmptyLayout from 'src/dashboard/util/getEmptyLayout';\nimport getFilterConfigsFromFormdata from 'src/dashboard/util/getFilterConfigsFromFormdata';\nimport getLocationHash from 'src/dashboard/util/getLocationHash';\nimport newComponentFactory from 'src/dashboard/util/newComponentFactory';\nimport { TIME_RANGE } from 'src/visualizations/FilterBox/FilterBox';\nimport { URL_PARAMS } from 'src/constants';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport { FeatureFlag, isFeatureEnabled } from '../../featureFlags';\nimport extractUrlParams from '../util/extractUrlParams';\n\nexport const HYDRATE_DASHBOARD = 'HYDRATE_DASHBOARD';\n\nexport const hydrateDashboard = (dashboardData, chartData) => (\ndispatch,\ngetState) =>\n{var _metadata, _metadata2, _metadata3, _metadata4, _dashboardData$metada, _dashboardData$metada2, _metadata5, _metadata6, _metadata7, _metadata8;\n  const { user, common } = getState();\n  let { metadata } = dashboardData;\n  const regularUrlParams = extractUrlParams('regular');\n  const reservedUrlParams = extractUrlParams('reserved');\n  const editMode = reservedUrlParams.edit === 'true';\n\n  let preselectFilters = {};\n\n  chartData.forEach((chart) => {\n    // eslint-disable-next-line no-param-reassign\n    chart.slice_id = chart.form_data.slice_id;\n  });\n  try {\n    // allow request parameter overwrite dashboard metadata\n    preselectFilters =\n    getUrlParam(URL_PARAMS.preselectFilters) ||\n    JSON.parse(metadata.default_filters);\n  } catch (e) {\n    //\n  }\n\n  // Priming the color palette with user's label-color mapping provided in\n  // the dashboard's JSON metadata\n  if ((_metadata = metadata) != null && _metadata.label_colors) {\n    const namespace = metadata.color_namespace;\n    const colorMap = _isString(metadata.label_colors) ?\n    JSON.parse(metadata.label_colors) :\n    metadata.label_colors;\n    const categoricalNamespace = CategoricalColorNamespace.getNamespace(\n    namespace);\n\n\n    Object.keys(colorMap).forEach((label) => {\n      categoricalNamespace.setColor(label, colorMap[label]);\n    });\n  }\n\n  // dashboard layout\n  const { position_data } = dashboardData;\n  // new dash: position_json could be {} or null\n  const layout =\n  position_data && Object.keys(position_data).length > 0 ?\n  position_data :\n  getEmptyLayout();\n\n  // create a lookup to sync layout names with slice names\n  const chartIdToLayoutId = {};\n  Object.values(layout).forEach((layoutComponent) => {\n    if (layoutComponent.type === CHART_TYPE) {\n      chartIdToLayoutId[layoutComponent.meta.chartId] = layoutComponent.id;\n    }\n  });\n\n  // find root level chart container node for newly-added slices\n  const parentId = findFirstParentContainerId(layout);\n  const parent = layout[parentId];\n  let newSlicesContainer;\n  let newSlicesContainerWidth = 0;\n\n  const filterScopes = ((_metadata2 = metadata) == null ? void 0 : _metadata2.filter_scopes) || {};\n\n  const chartQueries = {};\n  const dashboardFilters = {};\n  const slices = {};\n  const sliceIds = new Set();\n  chartData.forEach((slice) => {\n    const key = slice.slice_id;\n    const form_data = {\n      ...slice.form_data,\n      url_params: {\n        ...slice.form_data.url_params,\n        ...regularUrlParams } };\n\n\n    chartQueries[key] = {\n      ...chart,\n      id: key,\n      form_data,\n      formData: applyDefaultFormData(form_data) };\n\n\n    slices[key] = {\n      slice_id: key,\n      slice_url: slice.slice_url,\n      slice_name: slice.slice_name,\n      form_data: slice.form_data,\n      viz_type: slice.form_data.viz_type,\n      datasource: slice.form_data.datasource,\n      description: slice.description,\n      description_markeddown: slice.description_markeddown,\n      owners: slice.owners,\n      modified: slice.modified,\n      changed_on: new Date(slice.changed_on).getTime() };\n\n\n    sliceIds.add(key);\n\n    // if there are newly added slices from explore view, fill slices into 1 or more rows\n    if (!chartIdToLayoutId[key] && layout[parentId]) {\n      if (\n      newSlicesContainerWidth === 0 ||\n      newSlicesContainerWidth + GRID_DEFAULT_CHART_WIDTH > GRID_COLUMN_COUNT)\n      {\n        newSlicesContainer = newComponentFactory(\n        ROW_TYPE,\n        (parent.parents || []).slice());\n\n        layout[newSlicesContainer.id] = newSlicesContainer;\n        parent.children.push(newSlicesContainer.id);\n        newSlicesContainerWidth = 0;\n      }\n\n      const chartHolder = newComponentFactory(\n      CHART_TYPE,\n      {\n        chartId: slice.slice_id },\n\n      (newSlicesContainer.parents || []).slice());\n\n\n      layout[chartHolder.id] = chartHolder;\n      newSlicesContainer.children.push(chartHolder.id);\n      chartIdToLayoutId[chartHolder.meta.chartId] = chartHolder.id;\n      newSlicesContainerWidth += GRID_DEFAULT_CHART_WIDTH;\n    }\n\n    // build DashboardFilters for interactive filter features\n    if (slice.form_data.viz_type === 'filter_box') {\n      const configs = getFilterConfigsFromFormdata(slice.form_data);\n      let { columns } = configs;\n      const { labels } = configs;\n      if (preselectFilters[key]) {\n        Object.keys(columns).forEach((col) => {\n          if (preselectFilters[key][col]) {\n            columns = {\n              ...columns,\n              [col]: preselectFilters[key][col] };\n\n          }\n        });\n      }\n\n      const scopesByChartId = Object.keys(columns).reduce((map, column) => {\n        const scopeSettings = {\n          ...filterScopes[key] };\n\n        const { scope, immune } = {\n          ...DASHBOARD_FILTER_SCOPE_GLOBAL,\n          ...scopeSettings[column] };\n\n\n        return {\n          ...map,\n          [column]: {\n            scope,\n            immune } };\n\n\n      }, {});\n\n      const componentId = chartIdToLayoutId[key];\n      const directPathToFilter = (layout[componentId].parents || []).slice();\n      directPathToFilter.push(componentId);\n      dashboardFilters[key] = {\n        ...dashboardFilter,\n        chartId: key,\n        componentId,\n        datasourceId: slice.form_data.datasource,\n        filterName: slice.slice_name,\n        directPathToFilter,\n        columns,\n        labels,\n        scopes: scopesByChartId,\n        isInstantFilter: !!slice.form_data.instant_filtering,\n        isDateFilter: Object.keys(columns).includes(TIME_RANGE) };\n\n    }\n\n    // sync layout names with current slice names in case a slice was edited\n    // in explore since the layout was updated. name updates go through layout for undo/redo\n    // functionality and python updates slice names based on layout upon dashboard save\n    const layoutId = chartIdToLayoutId[key];\n    if (layoutId && layout[layoutId]) {\n      layout[layoutId].meta.sliceName = slice.slice_name;\n    }\n  });\n  buildActiveFilters({\n    dashboardFilters,\n    components: layout });\n\n\n  // store the header as a layout component so we can undo/redo changes\n  layout[DASHBOARD_HEADER_ID] = {\n    id: DASHBOARD_HEADER_ID,\n    type: DASHBOARD_HEADER_TYPE,\n    meta: {\n      text: dashboardData.dashboard_title } };\n\n\n\n  const dashboardLayout = {\n    past: [],\n    present: layout,\n    future: [] };\n\n\n  // find direct link component and path from root\n  const directLinkComponentId = getLocationHash();\n  let directPathToChild = [];\n  if (layout[directLinkComponentId]) {\n    directPathToChild = (layout[directLinkComponentId].parents || []).slice();\n    directPathToChild.push(directLinkComponentId);\n  }\n\n  const nativeFilters = getInitialNativeFilterState({\n    filterConfig: ((_metadata3 = metadata) == null ? void 0 : _metadata3.native_filter_configuration) || [],\n    filterSetsConfig: ((_metadata4 = metadata) == null ? void 0 : _metadata4.filter_sets_configuration) || [] });\n\n\n  if (!metadata) {\n    metadata = {};\n  }\n\n  metadata.show_native_filters = (_dashboardData$metada =\n  dashboardData == null ? void 0 : (_dashboardData$metada2 = dashboardData.metadata) == null ? void 0 : _dashboardData$metada2.show_native_filters) != null ? _dashboardData$metada :\n  isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS);\n\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    // If user just added cross filter to dashboard it's not saving it scope on server,\n    // so we tweak it until user will update scope and will save it in server\n    Object.values(dashboardLayout.present).forEach((layoutItem) => {var _layoutItem$meta, _behaviors, _ref, _getChartMetadataRegi, _chartQueries$chartId, _chartQueries$chartId2;\n      const chartId = (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId;\n      const behaviors = (_behaviors = (_ref = (_getChartMetadataRegi =\n\n      getChartMetadataRegistry().get((_chartQueries$chartId =\n      chartQueries[chartId]) == null ? void 0 : (_chartQueries$chartId2 = _chartQueries$chartId.formData) == null ? void 0 : _chartQueries$chartId2.viz_type)) != null ? _getChartMetadataRegi :\n      {}) == null ? void 0 : _ref.\n      behaviors) != null ? _behaviors : [];\n\n      if (!metadata.chart_configuration) {\n        metadata.chart_configuration = {};\n      }\n      if (\n      behaviors.includes(Behavior.INTERACTIVE_CHART) &&\n      !metadata.chart_configuration[chartId])\n      {\n        metadata.chart_configuration[chartId] = {\n          id: chartId,\n          crossFilters: {\n            scope: {\n              rootPath: [DASHBOARD_ROOT_ID],\n              excluded: [chartId] // By default it doesn't affects itself\n            } } };\n\n\n      }\n    });\n  }\n\n  const { roles } = user;\n  const canEdit = canUserEditDashboard(dashboardData, user);\n\n  return dispatch({\n    type: HYDRATE_DASHBOARD,\n    data: {\n      sliceEntities: { ...initSliceEntities, slices, isLoading: false },\n      charts: chartQueries,\n      // read-only data\n      dashboardInfo: {\n        ...dashboardData,\n        metadata,\n        userId: user.userId ? String(user.userId) : null, // legacy, please use state.user instead\n        dash_edit_perm: canEdit,\n        dash_save_perm: findPermission('can_save_dash', 'Superset', roles),\n        dash_share_perm: findPermission(\n        'can_share_dashboard',\n        'Superset',\n        roles),\n\n        superset_can_explore: findPermission('can_explore', 'Superset', roles),\n        superset_can_share: findPermission(\n        'can_share_chart',\n        'Superset',\n        roles),\n\n        superset_can_csv: findPermission('can_csv', 'Superset', roles),\n        slice_can_edit: findPermission('can_slice', 'Superset', roles),\n        common: {\n          // legacy, please use state.common instead\n          flash_messages: common.flash_messages,\n          conf: common.conf } },\n\n\n      dashboardFilters,\n      nativeFilters,\n      dashboardState: {\n        preselectNativeFilters: getUrlParam(URL_PARAMS.nativeFilters),\n        sliceIds: Array.from(sliceIds),\n        directPathToChild,\n        directPathLastUpdated: Date.now(),\n        focusedFilterField: null,\n        expandedSlices: ((_metadata5 = metadata) == null ? void 0 : _metadata5.expanded_slices) || {},\n        refreshFrequency: ((_metadata6 = metadata) == null ? void 0 : _metadata6.refresh_frequency) || 0,\n        // dashboard viewers can set refresh frequency for the current visit,\n        // only persistent refreshFrequency will be saved to backend\n        shouldPersistRefreshFrequency: false,\n        css: dashboardData.css || '',\n        colorNamespace: ((_metadata7 = metadata) == null ? void 0 : _metadata7.color_namespace) || null,\n        colorScheme: ((_metadata8 = metadata) == null ? void 0 : _metadata8.color_scheme) || null,\n        editMode: canEdit && editMode,\n        isPublished: dashboardData.published,\n        hasUnsavedChanges: false,\n        maxUndoHistoryExceeded: false,\n        lastModifiedTime: dashboardData.changed_on,\n        isRefreshing: false,\n        activeTabs: [] },\n\n      dashboardLayout } });\n\n\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(HYDRATE_DASHBOARD, \"HYDRATE_DASHBOARD\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/actions/hydrate.js\");reactHotLoader.register(hydrateDashboard, \"hydrateDashboard\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/actions/hydrate.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(__signature__, \"__signature__\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/actions/hydrate.js\");reactHotLoader.register(HYDRATE_DASHBOARD, \"HYDRATE_DASHBOARD\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/actions/hydrate.js\");reactHotLoader.register(hydrateDashboard, \"hydrateDashboard\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/actions/hydrate.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/actions/hydrate.js"],"names":["getInitialState","HYDRATE_DASHBOARD","hydrateDashboard","getState","regularUrlParams","extractUrlParams","reservedUrlParams","editMode","preselectFilters","chartData","chart","getUrlParam","URL_PARAMS","JSON","metadata","namespace","colorMap","categoricalNamespace","Object","layout","position_data","getEmptyLayout","chartIdToLayoutId","layoutComponent","parentId","findFirstParentContainerId","parent","newSlicesContainerWidth","filterScopes","chartQueries","dashboardFilters","slices","sliceIds","key","slice","form_data","url_params","id","formData","applyDefaultFormData","slice_id","slice_url","slice_name","viz_type","datasource","description","description_markeddown","owners","modified","changed_on","newSlicesContainer","newComponentFactory","chartHolder","chartId","configs","getFilterConfigsFromFormdata","columns","scopesByChartId","scopeSettings","componentId","directPathToFilter","datasourceId","filterName","scopes","isInstantFilter","isDateFilter","layoutId","buildActiveFilters","components","type","meta","text","dashboardData","dashboardLayout","past","present","future","directLinkComponentId","getLocationHash","directPathToChild","nativeFilters","getInitialNativeFilterState","filterConfig","filterSetsConfig","isFeatureEnabled","FeatureFlag","layoutItem","behaviors","getChartMetadataRegistry","Behavior","crossFilters","scope","rootPath","excluded","canEdit","canUserEditDashboard","dispatch","data","sliceEntities","isLoading","charts","dashboardInfo","userId","user","String","dash_edit_perm","dash_save_perm","findPermission","dash_share_perm","superset_can_explore","superset_can_share","superset_can_csv","slice_can_edit","common","flash_messages","conf","dashboardState","preselectNativeFilters","Array","directPathLastUpdated","Date","focusedFilterField","expandedSlices","refreshFrequency","shouldPersistRefreshFrequency","css","colorNamespace","colorScheme","isPublished","hasUnsavedChanges","maxUndoHistoryExceeded","lastModifiedTime","isRefreshing","activeTabs"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { isString } from 'lodash';\nimport {\n  Behavior,\n  CategoricalColorNamespace,\n  getChartMetadataRegistry,\n} from '@superset-ui/core';\n\nimport { chart } from 'src/chart/chartReducer';\nimport { initSliceEntities } from 'src/dashboard/reducers/sliceEntities';\nimport { getInitialState as getInitialNativeFilterState } from 'src/dashboard/reducers/nativeFilters';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport { buildActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport findPermission, {\n  canUserEditDashboard,\n} from 'src/dashboard/util/findPermission';\nimport {\n  DASHBOARD_FILTER_SCOPE_GLOBAL,\n  dashboardFilter,\n} from 'src/dashboard/reducers/dashboardFilters';\nimport {\n  DASHBOARD_HEADER_ID,\n  GRID_DEFAULT_CHART_WIDTH,\n  GRID_COLUMN_COUNT,\n  DASHBOARD_ROOT_ID,\n} from 'src/dashboard/util/constants';\nimport {\n  DASHBOARD_HEADER_TYPE,\n  CHART_TYPE,\n  ROW_TYPE,\n} from 'src/dashboard/util/componentTypes';\nimport findFirstParentContainerId from 'src/dashboard/util/findFirstParentContainer';\nimport getEmptyLayout from 'src/dashboard/util/getEmptyLayout';\nimport getFilterConfigsFromFormdata from 'src/dashboard/util/getFilterConfigsFromFormdata';\nimport getLocationHash from 'src/dashboard/util/getLocationHash';\nimport newComponentFactory from 'src/dashboard/util/newComponentFactory';\nimport { TIME_RANGE } from 'src/visualizations/FilterBox/FilterBox';\nimport { URL_PARAMS } from 'src/constants';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport { FeatureFlag, isFeatureEnabled } from '../../featureFlags';\nimport extractUrlParams from '../util/extractUrlParams';\n\nexport const HYDRATE_DASHBOARD = 'HYDRATE_DASHBOARD';\n\nexport const hydrateDashboard = (dashboardData, chartData) => (\n  dispatch,\n  getState,\n) => {\n  const { user, common } = getState();\n  let { metadata } = dashboardData;\n  const regularUrlParams = extractUrlParams('regular');\n  const reservedUrlParams = extractUrlParams('reserved');\n  const editMode = reservedUrlParams.edit === 'true';\n\n  let preselectFilters = {};\n\n  chartData.forEach(chart => {\n    // eslint-disable-next-line no-param-reassign\n    chart.slice_id = chart.form_data.slice_id;\n  });\n  try {\n    // allow request parameter overwrite dashboard metadata\n    preselectFilters =\n      getUrlParam(URL_PARAMS.preselectFilters) ||\n      JSON.parse(metadata.default_filters);\n  } catch (e) {\n    //\n  }\n\n  // Priming the color palette with user's label-color mapping provided in\n  // the dashboard's JSON metadata\n  if (metadata?.label_colors) {\n    const namespace = metadata.color_namespace;\n    const colorMap = isString(metadata.label_colors)\n      ? JSON.parse(metadata.label_colors)\n      : metadata.label_colors;\n    const categoricalNamespace = CategoricalColorNamespace.getNamespace(\n      namespace,\n    );\n\n    Object.keys(colorMap).forEach(label => {\n      categoricalNamespace.setColor(label, colorMap[label]);\n    });\n  }\n\n  // dashboard layout\n  const { position_data } = dashboardData;\n  // new dash: position_json could be {} or null\n  const layout =\n    position_data && Object.keys(position_data).length > 0\n      ? position_data\n      : getEmptyLayout();\n\n  // create a lookup to sync layout names with slice names\n  const chartIdToLayoutId = {};\n  Object.values(layout).forEach(layoutComponent => {\n    if (layoutComponent.type === CHART_TYPE) {\n      chartIdToLayoutId[layoutComponent.meta.chartId] = layoutComponent.id;\n    }\n  });\n\n  // find root level chart container node for newly-added slices\n  const parentId = findFirstParentContainerId(layout);\n  const parent = layout[parentId];\n  let newSlicesContainer;\n  let newSlicesContainerWidth = 0;\n\n  const filterScopes = metadata?.filter_scopes || {};\n\n  const chartQueries = {};\n  const dashboardFilters = {};\n  const slices = {};\n  const sliceIds = new Set();\n  chartData.forEach(slice => {\n    const key = slice.slice_id;\n    const form_data = {\n      ...slice.form_data,\n      url_params: {\n        ...slice.form_data.url_params,\n        ...regularUrlParams,\n      },\n    };\n    chartQueries[key] = {\n      ...chart,\n      id: key,\n      form_data,\n      formData: applyDefaultFormData(form_data),\n    };\n\n    slices[key] = {\n      slice_id: key,\n      slice_url: slice.slice_url,\n      slice_name: slice.slice_name,\n      form_data: slice.form_data,\n      viz_type: slice.form_data.viz_type,\n      datasource: slice.form_data.datasource,\n      description: slice.description,\n      description_markeddown: slice.description_markeddown,\n      owners: slice.owners,\n      modified: slice.modified,\n      changed_on: new Date(slice.changed_on).getTime(),\n    };\n\n    sliceIds.add(key);\n\n    // if there are newly added slices from explore view, fill slices into 1 or more rows\n    if (!chartIdToLayoutId[key] && layout[parentId]) {\n      if (\n        newSlicesContainerWidth === 0 ||\n        newSlicesContainerWidth + GRID_DEFAULT_CHART_WIDTH > GRID_COLUMN_COUNT\n      ) {\n        newSlicesContainer = newComponentFactory(\n          ROW_TYPE,\n          (parent.parents || []).slice(),\n        );\n        layout[newSlicesContainer.id] = newSlicesContainer;\n        parent.children.push(newSlicesContainer.id);\n        newSlicesContainerWidth = 0;\n      }\n\n      const chartHolder = newComponentFactory(\n        CHART_TYPE,\n        {\n          chartId: slice.slice_id,\n        },\n        (newSlicesContainer.parents || []).slice(),\n      );\n\n      layout[chartHolder.id] = chartHolder;\n      newSlicesContainer.children.push(chartHolder.id);\n      chartIdToLayoutId[chartHolder.meta.chartId] = chartHolder.id;\n      newSlicesContainerWidth += GRID_DEFAULT_CHART_WIDTH;\n    }\n\n    // build DashboardFilters for interactive filter features\n    if (slice.form_data.viz_type === 'filter_box') {\n      const configs = getFilterConfigsFromFormdata(slice.form_data);\n      let { columns } = configs;\n      const { labels } = configs;\n      if (preselectFilters[key]) {\n        Object.keys(columns).forEach(col => {\n          if (preselectFilters[key][col]) {\n            columns = {\n              ...columns,\n              [col]: preselectFilters[key][col],\n            };\n          }\n        });\n      }\n\n      const scopesByChartId = Object.keys(columns).reduce((map, column) => {\n        const scopeSettings = {\n          ...filterScopes[key],\n        };\n        const { scope, immune } = {\n          ...DASHBOARD_FILTER_SCOPE_GLOBAL,\n          ...scopeSettings[column],\n        };\n\n        return {\n          ...map,\n          [column]: {\n            scope,\n            immune,\n          },\n        };\n      }, {});\n\n      const componentId = chartIdToLayoutId[key];\n      const directPathToFilter = (layout[componentId].parents || []).slice();\n      directPathToFilter.push(componentId);\n      dashboardFilters[key] = {\n        ...dashboardFilter,\n        chartId: key,\n        componentId,\n        datasourceId: slice.form_data.datasource,\n        filterName: slice.slice_name,\n        directPathToFilter,\n        columns,\n        labels,\n        scopes: scopesByChartId,\n        isInstantFilter: !!slice.form_data.instant_filtering,\n        isDateFilter: Object.keys(columns).includes(TIME_RANGE),\n      };\n    }\n\n    // sync layout names with current slice names in case a slice was edited\n    // in explore since the layout was updated. name updates go through layout for undo/redo\n    // functionality and python updates slice names based on layout upon dashboard save\n    const layoutId = chartIdToLayoutId[key];\n    if (layoutId && layout[layoutId]) {\n      layout[layoutId].meta.sliceName = slice.slice_name;\n    }\n  });\n  buildActiveFilters({\n    dashboardFilters,\n    components: layout,\n  });\n\n  // store the header as a layout component so we can undo/redo changes\n  layout[DASHBOARD_HEADER_ID] = {\n    id: DASHBOARD_HEADER_ID,\n    type: DASHBOARD_HEADER_TYPE,\n    meta: {\n      text: dashboardData.dashboard_title,\n    },\n  };\n\n  const dashboardLayout = {\n    past: [],\n    present: layout,\n    future: [],\n  };\n\n  // find direct link component and path from root\n  const directLinkComponentId = getLocationHash();\n  let directPathToChild = [];\n  if (layout[directLinkComponentId]) {\n    directPathToChild = (layout[directLinkComponentId].parents || []).slice();\n    directPathToChild.push(directLinkComponentId);\n  }\n\n  const nativeFilters = getInitialNativeFilterState({\n    filterConfig: metadata?.native_filter_configuration || [],\n    filterSetsConfig: metadata?.filter_sets_configuration || [],\n  });\n\n  if (!metadata) {\n    metadata = {};\n  }\n\n  metadata.show_native_filters =\n    dashboardData?.metadata?.show_native_filters ??\n    isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS);\n\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    // If user just added cross filter to dashboard it's not saving it scope on server,\n    // so we tweak it until user will update scope and will save it in server\n    Object.values(dashboardLayout.present).forEach(layoutItem => {\n      const chartId = layoutItem.meta?.chartId;\n      const behaviors =\n        (\n          getChartMetadataRegistry().get(\n            chartQueries[chartId]?.formData?.viz_type,\n          ) ?? {}\n        )?.behaviors ?? [];\n\n      if (!metadata.chart_configuration) {\n        metadata.chart_configuration = {};\n      }\n      if (\n        behaviors.includes(Behavior.INTERACTIVE_CHART) &&\n        !metadata.chart_configuration[chartId]\n      ) {\n        metadata.chart_configuration[chartId] = {\n          id: chartId,\n          crossFilters: {\n            scope: {\n              rootPath: [DASHBOARD_ROOT_ID],\n              excluded: [chartId], // By default it doesn't affects itself\n            },\n          },\n        };\n      }\n    });\n  }\n\n  const { roles } = user;\n  const canEdit = canUserEditDashboard(dashboardData, user);\n\n  return dispatch({\n    type: HYDRATE_DASHBOARD,\n    data: {\n      sliceEntities: { ...initSliceEntities, slices, isLoading: false },\n      charts: chartQueries,\n      // read-only data\n      dashboardInfo: {\n        ...dashboardData,\n        metadata,\n        userId: user.userId ? String(user.userId) : null, // legacy, please use state.user instead\n        dash_edit_perm: canEdit,\n        dash_save_perm: findPermission('can_save_dash', 'Superset', roles),\n        dash_share_perm: findPermission(\n          'can_share_dashboard',\n          'Superset',\n          roles,\n        ),\n        superset_can_explore: findPermission('can_explore', 'Superset', roles),\n        superset_can_share: findPermission(\n          'can_share_chart',\n          'Superset',\n          roles,\n        ),\n        superset_can_csv: findPermission('can_csv', 'Superset', roles),\n        slice_can_edit: findPermission('can_slice', 'Superset', roles),\n        common: {\n          // legacy, please use state.common instead\n          flash_messages: common.flash_messages,\n          conf: common.conf,\n        },\n      },\n      dashboardFilters,\n      nativeFilters,\n      dashboardState: {\n        preselectNativeFilters: getUrlParam(URL_PARAMS.nativeFilters),\n        sliceIds: Array.from(sliceIds),\n        directPathToChild,\n        directPathLastUpdated: Date.now(),\n        focusedFilterField: null,\n        expandedSlices: metadata?.expanded_slices || {},\n        refreshFrequency: metadata?.refresh_frequency || 0,\n        // dashboard viewers can set refresh frequency for the current visit,\n        // only persistent refreshFrequency will be saved to backend\n        shouldPersistRefreshFrequency: false,\n        css: dashboardData.css || '',\n        colorNamespace: metadata?.color_namespace || null,\n        colorScheme: metadata?.color_scheme || null,\n        editMode: canEdit && editMode,\n        isPublished: dashboardData.published,\n        hasUnsavedChanges: false,\n        maxUndoHistoryExceeded: false,\n        lastModifiedTime: dashboardData.changed_on,\n        isRefreshing: false,\n        activeTabs: [],\n      },\n      dashboardLayout,\n    },\n  });\n};\n"]},"metadata":{},"sourceType":"module"}