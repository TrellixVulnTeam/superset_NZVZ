{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import shortid from 'shortid';\nimport { getInitialDataMask } from 'src/dataMask/reducer';\nimport { t } from '@superset-ui/core';\nexport const REMOVAL_DELAY_SECS = 5;\nexport const validateForm = async (form, currentFilterId, filterConfigMap, filterIds, removedFilters, setCurrentFilterId) => {\n  const addValidationError = (filterId, field, error) => {\n    const fieldError = {\n      name: ['filters', filterId, field],\n      errors: [error] };\n\n    form.setFields([fieldError]);\n    setCurrentFilterId(filterId);\n  };\n  try {\n    let formValues;\n    try {\n      formValues = await form.validateFields();\n    }\n    catch (error) {var _error$errorFields;\n      // In Jest tests in chain of tests, Ant generate `outOfDate` error so need to catch it here\n      if (!(error != null && (_error$errorFields = error.errorFields) != null && _error$errorFields.length) && error != null && error.outOfDate) {\n        formValues = error.values;\n      } else\n      {\n        throw error;\n      }\n    }\n    const validateCycles = (filterId, trace = []) => {var _formValues$filters, _formValues$filters$f, _formValues$filters$f2, _filterConfigMap$filt, _filterConfigMap$filt2;\n      if (trace.includes(filterId)) {\n        addValidationError(filterId, 'parentFilter', t('Cannot create cyclic hierarchy'));\n        return false;\n      }\n      const parentId = (_formValues$filters = formValues.filters) != null && _formValues$filters[filterId] ? (_formValues$filters$f =\n      formValues.filters[filterId]) == null ? void 0 : (_formValues$filters$f2 = _formValues$filters$f.parentFilter) == null ? void 0 : _formValues$filters$f2.value : (_filterConfigMap$filt =\n      filterConfigMap[filterId]) == null ? void 0 : (_filterConfigMap$filt2 = _filterConfigMap$filt.cascadeParentIds) == null ? void 0 : _filterConfigMap$filt2[0];\n      if (parentId) {\n        return validateCycles(parentId, [...trace, filterId]);\n      }\n      return true;\n    };\n    const invalid = filterIds.\n    filter((id) => !removedFilters[id]).\n    some((filterId) => !validateCycles(filterId));\n    if (invalid) {\n      return null;\n    }\n    return formValues;\n  }\n  catch (error) {\n    console.warn('Filter configuration failed:', error);\n    if (!error.errorFields || !error.errorFields.length)\n    return null; // not a validation error\n    const errorFields = error.errorFields;\n    // filter id is the second item in the field name\n    if (!errorFields.some((field) => field.name[1] === currentFilterId)) {\n      // switch to the first tab that had a validation error\n      const filterError = errorFields.find((field) => field.name[0] === 'filters');\n      if (filterError) {\n        const filterId = filterError.name[1];\n        setCurrentFilterId(filterId);\n      }\n    }\n    return null;\n  }\n};\nexport const createHandleSave = (filterConfigMap, filterIds, removedFilters, saveForm, values) => async () => {\n  const newFilterConfig = filterIds.\n  filter((id) => !removedFilters[id]).\n  map((id) => {var _values$filters, _formInputs$controlVa, _formInputs$requiredF, _formInputs$defaultDa;\n    // create a filter config object from the form inputs\n    const formInputs = (_values$filters = values.filters) == null ? void 0 : _values$filters[id];\n    // if user didn't open a filter, return the original config\n    if (!formInputs)\n    return filterConfigMap[id];\n    const target = {};\n    if (formInputs.dataset) {\n      target.datasetId = formInputs.dataset.value;\n    }\n    if (formInputs.dataset && formInputs.column) {\n      target.column = { name: formInputs.column };\n    }\n    return {\n      id,\n      adhoc_filters: formInputs.adhoc_filters,\n      time_range: formInputs.time_range,\n      controlValues: (_formInputs$controlVa = formInputs.controlValues) != null ? _formInputs$controlVa : {},\n      granularity_sqla: formInputs.granularity_sqla,\n      requiredFirst: Object.values((_formInputs$requiredF = formInputs.requiredFirst) != null ? _formInputs$requiredF : {}).find((rf) => rf),\n      name: formInputs.name,\n      filterType: formInputs.filterType,\n      // for now there will only ever be one target\n      targets: [target],\n      defaultDataMask: (_formInputs$defaultDa = formInputs.defaultDataMask) != null ? _formInputs$defaultDa : getInitialDataMask(),\n      cascadeParentIds: formInputs.parentFilter ?\n      [formInputs.parentFilter.value] :\n      [],\n      scope: formInputs.scope,\n      sortMetric: formInputs.sortMetric,\n      type: formInputs.type };\n\n  });\n  await saveForm(newFilterConfig);\n};\nexport const createHandleTabEdit = (setRemovedFilters, setSaveAlertVisible, addFilter) => (filterId, action) => {\n  const completeFilterRemoval = (filterId) => {\n    // the filter state will actually stick around in the form,\n    // and the filterConfig/newFilterIds, but we use removedFilters\n    // to mark it as removed.\n    setRemovedFilters((removedFilters) => ({\n      ...removedFilters,\n      [filterId]: { isPending: false } }));\n\n  };\n  if (action === 'remove') {\n    // first set up the timer to completely remove it\n    const timerId = window.setTimeout(() => completeFilterRemoval(filterId), REMOVAL_DELAY_SECS * 1000);\n    // mark the filter state as \"removal in progress\"\n    setRemovedFilters((removedFilters) => ({\n      ...removedFilters,\n      [filterId]: { isPending: true, timerId } }));\n\n    setSaveAlertVisible(false);\n  } else\n  if (action === 'add') {\n    addFilter();\n  }\n};\nexport const NATIVE_FILTER_PREFIX = 'NATIVE_FILTER-';\nexport const generateFilterId = () => `${NATIVE_FILTER_PREFIX}${shortid.generate()}`;\nexport const getFilterIds = (config) => config.map((filter) => filter.id);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(REMOVAL_DELAY_SECS, \"REMOVAL_DELAY_SECS\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(validateForm, \"validateForm\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(createHandleSave, \"createHandleSave\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(createHandleTabEdit, \"createHandleTabEdit\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(NATIVE_FILTER_PREFIX, \"NATIVE_FILTER_PREFIX\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(generateFilterId, \"generateFilterId\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(getFilterIds, \"getFilterIds\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { FormInstance } from 'antd/lib/form';\nimport shortid from 'shortid';\nimport { getInitialDataMask } from 'src/dataMask/reducer';\nimport { t } from '@superset-ui/core';\nimport { FilterRemoval, NativeFiltersForm } from './types';\nimport { Filter, FilterConfiguration, Target } from '../types';\n\nexport const REMOVAL_DELAY_SECS = 5;\n\nexport const validateForm = async (\n  form: FormInstance<NativeFiltersForm>,\n  currentFilterId: string,\n  filterConfigMap: Record<string, Filter>,\n  filterIds: string[],\n  removedFilters: Record<string, FilterRemoval>,\n  setCurrentFilterId: Function,\n) => {\n  const addValidationError = (\n    filterId: string,\n    field: string,\n    error: string,\n  ) => {\n    const fieldError = {\n      name: ['filters', filterId, field],\n      errors: [error],\n    };\n    form.setFields([fieldError]);\n    setCurrentFilterId(filterId);\n  };\n\n  try {\n    let formValues: NativeFiltersForm;\n    try {\n      formValues = (await form.validateFields()) as NativeFiltersForm;\n    } catch (error) {\n      // In Jest tests in chain of tests, Ant generate `outOfDate` error so need to catch it here\n      if (!error?.errorFields?.length && error?.outOfDate) {\n        formValues = error.values;\n      } else {\n        throw error;\n      }\n    }\n\n    const validateCycles = (\n      filterId: string,\n      trace: string[] = [],\n    ): boolean => {\n      if (trace.includes(filterId)) {\n        addValidationError(\n          filterId,\n          'parentFilter',\n          t('Cannot create cyclic hierarchy'),\n        );\n        return false;\n      }\n      const parentId = formValues.filters?.[filterId]\n        ? formValues.filters[filterId]?.parentFilter?.value\n        : filterConfigMap[filterId]?.cascadeParentIds?.[0];\n      if (parentId) {\n        return validateCycles(parentId, [...trace, filterId]);\n      }\n      return true;\n    };\n\n    const invalid = filterIds\n      .filter(id => !removedFilters[id])\n      .some(filterId => !validateCycles(filterId));\n\n    if (invalid) {\n      return null;\n    }\n\n    return formValues;\n  } catch (error) {\n    console.warn('Filter configuration failed:', error);\n\n    if (!error.errorFields || !error.errorFields.length) return null; // not a validation error\n\n    // the name is in array format since the fields are nested\n    type ErrorFields = { name: ['filters', string, string] }[];\n    const errorFields = error.errorFields as ErrorFields;\n    // filter id is the second item in the field name\n    if (!errorFields.some(field => field.name[1] === currentFilterId)) {\n      // switch to the first tab that had a validation error\n      const filterError = errorFields.find(\n        field => field.name[0] === 'filters',\n      );\n      if (filterError) {\n        const filterId = filterError.name[1];\n        setCurrentFilterId(filterId);\n      }\n    }\n    return null;\n  }\n};\n\nexport const createHandleSave = (\n  filterConfigMap: Record<string, Filter>,\n  filterIds: string[],\n  removedFilters: Record<string, FilterRemoval>,\n  saveForm: Function,\n  values: NativeFiltersForm,\n) => async () => {\n  const newFilterConfig: FilterConfiguration = filterIds\n    .filter(id => !removedFilters[id])\n    .map(id => {\n      // create a filter config object from the form inputs\n      const formInputs = values.filters?.[id];\n      // if user didn't open a filter, return the original config\n      if (!formInputs) return filterConfigMap[id];\n      const target: Partial<Target> = {};\n      if (formInputs.dataset) {\n        target.datasetId = formInputs.dataset.value;\n      }\n      if (formInputs.dataset && formInputs.column) {\n        target.column = { name: formInputs.column };\n      }\n      return {\n        id,\n        adhoc_filters: formInputs.adhoc_filters,\n        time_range: formInputs.time_range,\n        controlValues: formInputs.controlValues ?? {},\n        granularity_sqla: formInputs.granularity_sqla,\n        requiredFirst: Object.values(formInputs.requiredFirst ?? {}).find(\n          rf => rf,\n        ),\n        name: formInputs.name,\n        filterType: formInputs.filterType,\n        // for now there will only ever be one target\n        targets: [target],\n        defaultDataMask: formInputs.defaultDataMask ?? getInitialDataMask(),\n        cascadeParentIds: formInputs.parentFilter\n          ? [formInputs.parentFilter.value]\n          : [],\n        scope: formInputs.scope,\n        sortMetric: formInputs.sortMetric,\n        type: formInputs.type,\n      };\n    });\n\n  await saveForm(newFilterConfig);\n};\n\nexport const createHandleTabEdit = (\n  setRemovedFilters: (\n    value:\n      | ((\n          prevState: Record<string, FilterRemoval>,\n        ) => Record<string, FilterRemoval>)\n      | Record<string, FilterRemoval>,\n  ) => void,\n  setSaveAlertVisible: Function,\n  addFilter: Function,\n) => (filterId: string, action: 'add' | 'remove') => {\n  const completeFilterRemoval = (filterId: string) => {\n    // the filter state will actually stick around in the form,\n    // and the filterConfig/newFilterIds, but we use removedFilters\n    // to mark it as removed.\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: false },\n    }));\n  };\n\n  if (action === 'remove') {\n    // first set up the timer to completely remove it\n    const timerId = window.setTimeout(\n      () => completeFilterRemoval(filterId),\n      REMOVAL_DELAY_SECS * 1000,\n    );\n    // mark the filter state as \"removal in progress\"\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: true, timerId },\n    }));\n    setSaveAlertVisible(false);\n  } else if (action === 'add') {\n    addFilter();\n  }\n};\n\nexport const NATIVE_FILTER_PREFIX = 'NATIVE_FILTER-';\nexport const generateFilterId = () =>\n  `${NATIVE_FILTER_PREFIX}${shortid.generate()}`;\n\nexport const getFilterIds = (config: FilterConfiguration) =>\n  config.map(filter => filter.id);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}