{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ensureIsArray, FeatureFlag, isFeatureEnabled } from '@superset-ui/core';\nimport { NO_TIME_RANGE, TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport { DataMaskType } from 'src/dataMask/types';\nimport { areObjectsEqual } from 'src/reduxUtils';\nimport { getTreeCheckedItems } from '../nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils';\nexport var IndicatorStatus;\n(function (IndicatorStatus) {\n  IndicatorStatus[\"Unset\"] = \"UNSET\";\n  IndicatorStatus[\"Applied\"] = \"APPLIED\";\n  IndicatorStatus[\"Incompatible\"] = \"INCOMPATIBLE\";\n  IndicatorStatus[\"CrossFilterApplied\"] = \"CROSS_FILTER_APPLIED\";\n})(IndicatorStatus || (IndicatorStatus = {}));\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\nconst extractLabel = (filter) => {\n  if (filter != null && filter.label) {\n    return filter.label;\n  }\n  if (filter != null && filter.value) {\n    return ensureIsArray(filter == null ? void 0 : filter.value).join(', ');\n  }\n  return null;\n};\nconst selectIndicatorValue = (columnKey, filter, datasource) => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n  if (values == null ||\n  filter.isDateFilter && values === NO_TIME_RANGE ||\n  arrValues.length === 0) {\n    return [];\n  }\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = ((columnKey === TIME_FILTER_MAP.time_grain_sqla ?\n    datasource.time_grain_sqla :\n    datasource.granularity) || []).reduce((map, [key, value]) => ({\n      ...map,\n      [key]: value }),\n    {});\n    return arrValues.map((value) => timeGranularityMap[value] || value);\n  }\n  return arrValues;\n};\nconst selectIndicatorsForChartFromFilter = (chartId, filter, filterDataSource, appliedColumns, rejectedColumns) => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column, filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n    return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n  return Object.keys(filter.columns).\n  filter((column) => getChartIdsInFilterScope({\n    filterScope: filter.scopes[column] }).\n  includes(chartId)).\n  map((column) => ({\n    column,\n    name: filter.labels[column] || column,\n    value: selectIndicatorValue(column, filter, filterDataSource),\n    status: getStatus(column, filter),\n    path: filter.directPathToFilter }));\n\n};\nconst getAppliedColumns = (chart) => {var _chart$queriesRespons, _chart$queriesRespons2;return new Set(((chart == null ? void 0 : (_chart$queriesRespons = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons2 = _chart$queriesRespons[0]) == null ? void 0 : _chart$queriesRespons2.applied_filters) || []).map((filter) => filter.column));};\nconst getRejectedColumns = (chart) => {var _chart$queriesRespons3, _chart$queriesRespons4;return new Set(((chart == null ? void 0 : (_chart$queriesRespons3 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons4 = _chart$queriesRespons3[0]) == null ? void 0 : _chart$queriesRespons4.rejected_filters) || []).map((filter) => filter.column));};\nconst cachedIndicatorsForChart = {};\nconst cachedDashboardFilterDataForChart = {};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (chartId, filters, datasources, chart) => {\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const matchingFilters = Object.values(filters).filter((filter) => filter.chartId !== chartId);\n  const matchingDatasources = Object.entries(datasources).\n  filter(([key]) => matchingFilters.find((filter) => filter.datasourceId === key)).\n  map(([, datasource]) => datasource);\n  const cachedFilterData = cachedDashboardFilterDataForChart[chartId];\n  if (cachedIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.rejectedColumns, rejectedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.matchingFilters, matchingFilters) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.matchingDatasources, matchingDatasources)) {\n    return cachedIndicatorsForChart[chartId];\n  }\n  const indicators = matchingFilters.reduce((acc, filter) => acc.concat(selectIndicatorsForChartFromFilter(chartId, filter, datasources[filter.datasourceId] || {}, appliedColumns, rejectedColumns)), []);\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  cachedIndicatorsForChart[chartId] = indicators;\n  cachedDashboardFilterDataForChart[chartId] = {\n    appliedColumns,\n    rejectedColumns,\n    matchingFilters,\n    matchingDatasources };\n\n  return indicators;\n};\nconst cachedNativeIndicatorsForChart = {};\nconst cachedNativeFilterDataForChart = {};\nconst defaultChartConfig = {};\nexport const selectNativeIndicatorsForChart = (nativeFilters, dataMask, chartId, chart, dashboardLayout, chartConfiguration = defaultChartConfig) => {\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const cachedFilterData = cachedNativeFilterDataForChart[chartId];\n  if (cachedNativeIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.rejectedColumns, rejectedColumns) &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.nativeFilters) === nativeFilters &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.dashboardLayout) === dashboardLayout &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.chartConfiguration) === chartConfiguration &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.dataMask) === dataMask) {\n    return cachedNativeIndicatorsForChart[chartId];\n  }\n  const getStatus = ({ label, column, type = DataMaskType.NativeFilters }) => {\n    // a filter is only considered unset if it's value is null\n    const hasValue = label !== null;\n    if (type === DataMaskType.CrossFilters && hasValue) {\n      return IndicatorStatus.CrossFilterApplied;\n    }\n    if (!column && hasValue) {\n      // Filter without datasource\n      return IndicatorStatus.Applied;\n    }\n    if (column && rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    if (column && appliedColumns.has(column) && hasValue) {\n      return IndicatorStatus.Applied;\n    }\n    return IndicatorStatus.Unset;\n  };\n  let nativeFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS)) {\n    nativeFilterIndicators =\n    nativeFilters &&\n    Object.values(nativeFilters).\n    filter((nativeFilter) => getTreeCheckedItems(nativeFilter.scope, dashboardLayout).some((layoutItem) => {var _dashboardLayout$layo, _dashboardLayout$layo2;return ((_dashboardLayout$layo = dashboardLayout[layoutItem]) == null ? void 0 : (_dashboardLayout$layo2 = _dashboardLayout$layo.meta) == null ? void 0 : _dashboardLayout$layo2.chartId) === chartId;})).\n    map((nativeFilter) => {var _nativeFilter$targets, _nativeFilter$targets2, _dataMask$nativeFilte;\n      const column = (_nativeFilter$targets = nativeFilter.targets[0]) == null ? void 0 : (_nativeFilter$targets2 = _nativeFilter$targets.column) == null ? void 0 : _nativeFilter$targets2.name;\n      const filterState = (_dataMask$nativeFilte = dataMask[nativeFilter.id]) == null ? void 0 : _dataMask$nativeFilte.filterState;\n      const label = extractLabel(filterState);\n      return {\n        column,\n        name: nativeFilter.name,\n        path: [nativeFilter.id],\n        status: getStatus({ label, column }),\n        value: label };\n\n    });\n  }\n  let crossFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    crossFilterIndicators = Object.values(chartConfiguration).\n    filter((chartConfig) => {var _chartConfig$crossFil;return getTreeCheckedItems(chartConfig == null ? void 0 : (_chartConfig$crossFil = chartConfig.crossFilters) == null ? void 0 : _chartConfig$crossFil.scope, dashboardLayout).some((layoutItem) => {var _dashboardLayout$layo3, _dashboardLayout$layo4;return ((_dashboardLayout$layo3 = dashboardLayout[layoutItem]) == null ? void 0 : (_dashboardLayout$layo4 = _dashboardLayout$layo3.meta) == null ? void 0 : _dashboardLayout$layo4.chartId) === chartId;});}).\n    map((chartConfig) => {var _dataMask$chartConfig, _dashboardLayoutItem$, _dashboardLayoutItem$2;\n      const filterState = (_dataMask$chartConfig = dataMask[chartConfig.id]) == null ? void 0 : _dataMask$chartConfig.filterState;\n      const label = extractLabel(filterState);\n      const filtersState = filterState == null ? void 0 : filterState.filters;\n      const column = filtersState && Object.keys(filtersState)[0];\n      const dashboardLayoutItem = Object.values(dashboardLayout).find((layoutItem) => {var _layoutItem$meta;return (layoutItem == null ? void 0 : (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId) === chartConfig.id;});\n      return {\n        column,\n        name: dashboardLayoutItem == null ? void 0 : (_dashboardLayoutItem$ = dashboardLayoutItem.meta) == null ? void 0 : _dashboardLayoutItem$.sliceName,\n        path: [\n        ...((_dashboardLayoutItem$2 = dashboardLayoutItem == null ? void 0 : dashboardLayoutItem.parents) != null ? _dashboardLayoutItem$2 : []),\n        dashboardLayoutItem == null ? void 0 : dashboardLayoutItem.id],\n\n        status: getStatus({\n          label,\n          type: DataMaskType.CrossFilters }),\n\n        value: label };\n\n    }).\n    filter((filter) => filter.status === IndicatorStatus.CrossFilterApplied);\n  }\n  const indicators = crossFilterIndicators.concat(nativeFilterIndicators);\n  cachedNativeIndicatorsForChart[chartId] = indicators;\n  cachedNativeFilterDataForChart[chartId] = {\n    nativeFilters,\n    dashboardLayout,\n    chartConfiguration,\n    dataMask,\n    appliedColumns,\n    rejectedColumns };\n\n  return indicators;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(IndicatorStatus, \"IndicatorStatus\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(TIME_GRANULARITY_FIELDS, \"TIME_GRANULARITY_FIELDS\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(extractLabel, \"extractLabel\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorValue, \"selectIndicatorValue\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorsForChartFromFilter, \"selectIndicatorsForChartFromFilter\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(getAppliedColumns, \"getAppliedColumns\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(getRejectedColumns, \"getRejectedColumns\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(cachedIndicatorsForChart, \"cachedIndicatorsForChart\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(cachedDashboardFilterDataForChart, \"cachedDashboardFilterDataForChart\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorsForChart, \"selectIndicatorsForChart\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(cachedNativeIndicatorsForChart, \"cachedNativeIndicatorsForChart\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(cachedNativeFilterDataForChart, \"cachedNativeFilterDataForChart\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(defaultChartConfig, \"defaultChartConfig\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectNativeIndicatorsForChart, \"selectNativeIndicatorsForChart\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  ensureIsArray,\n  FeatureFlag,\n  FilterState,\n  isFeatureEnabled,\n} from '@superset-ui/core';\nimport { NO_TIME_RANGE, TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport { ChartConfiguration, Filters } from 'src/dashboard/reducers/types';\nimport { DataMaskStateWithId, DataMaskType } from 'src/dataMask/types';\nimport { areObjectsEqual } from 'src/reduxUtils';\nimport { Layout } from '../../types';\nimport { getTreeCheckedItems } from '../nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils';\n\nexport enum IndicatorStatus {\n  Unset = 'UNSET',\n  Applied = 'APPLIED',\n  Incompatible = 'INCOMPATIBLE',\n  CrossFilterApplied = 'CROSS_FILTER_APPLIED',\n}\n\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\n\n// As of 2020-09-28, the DatasourceMeta type in superset-ui is incorrect.\n// Should patch it here until the DatasourceMeta type is updated.\ntype Datasource = {\n  time_grain_sqla?: [string, string][];\n  granularity?: [string, string][];\n};\n\ntype Filter = {\n  chartId: number;\n  columns: { [key: string]: string | string[] };\n  scopes: { [key: string]: any };\n  labels: { [key: string]: string };\n  isDateFilter: boolean;\n  directPathToFilter: string[];\n  datasourceId: string;\n};\n\nconst extractLabel = (filter?: FilterState): string | null => {\n  if (filter?.label) {\n    return filter.label;\n  }\n  if (filter?.value) {\n    return ensureIsArray(filter?.value).join(', ');\n  }\n  return null;\n};\n\nconst selectIndicatorValue = (\n  columnKey: string,\n  filter: Filter,\n  datasource: Datasource,\n): any => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n\n  if (\n    values == null ||\n    (filter.isDateFilter && values === NO_TIME_RANGE) ||\n    arrValues.length === 0\n  ) {\n    return [];\n  }\n\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = (\n      (columnKey === TIME_FILTER_MAP.time_grain_sqla\n        ? datasource.time_grain_sqla\n        : datasource.granularity) || []\n    ).reduce(\n      (map, [key, value]) => ({\n        ...map,\n        [key]: value,\n      }),\n      {},\n    );\n\n    return arrValues.map(value => timeGranularityMap[value] || value);\n  }\n\n  return arrValues;\n};\n\nconst selectIndicatorsForChartFromFilter = (\n  chartId: number,\n  filter: Filter,\n  filterDataSource: Datasource,\n  appliedColumns: Set<string>,\n  rejectedColumns: Set<string>,\n): Indicator[] => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column: string, filter: Filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n      return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column)) return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n\n  return Object.keys(filter.columns)\n    .filter(column =>\n      getChartIdsInFilterScope({\n        filterScope: filter.scopes[column],\n      }).includes(chartId),\n    )\n    .map(column => ({\n      column,\n      name: filter.labels[column] || column,\n      value: selectIndicatorValue(column, filter, filterDataSource),\n      status: getStatus(column, filter),\n      path: filter.directPathToFilter,\n    }));\n};\n\nconst getAppliedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.applied_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n\nconst getRejectedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.rejected_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n\nexport type Indicator = {\n  column?: string;\n  name: string;\n  value?: any;\n  status?: IndicatorStatus;\n  path?: string[];\n};\n\nconst cachedIndicatorsForChart = {};\nconst cachedDashboardFilterDataForChart = {};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (\n  chartId: number,\n  filters: { [key: number]: Filter },\n  datasources: { [key: string]: Datasource },\n  chart: any,\n): Indicator[] => {\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const matchingFilters = Object.values(filters).filter(\n    filter => filter.chartId !== chartId,\n  );\n  const matchingDatasources = Object.entries(datasources)\n    .filter(([key]) =>\n      matchingFilters.find(filter => filter.datasourceId === key),\n    )\n    .map(([, datasource]) => datasource);\n\n  const cachedFilterData = cachedDashboardFilterDataForChart[chartId];\n  if (\n    cachedIndicatorsForChart[chartId] &&\n    areObjectsEqual(cachedFilterData?.appliedColumns, appliedColumns) &&\n    areObjectsEqual(cachedFilterData?.rejectedColumns, rejectedColumns) &&\n    areObjectsEqual(cachedFilterData?.matchingFilters, matchingFilters) &&\n    areObjectsEqual(cachedFilterData?.matchingDatasources, matchingDatasources)\n  ) {\n    return cachedIndicatorsForChart[chartId];\n  }\n  const indicators = matchingFilters.reduce(\n    (acc, filter) =>\n      acc.concat(\n        selectIndicatorsForChartFromFilter(\n          chartId,\n          filter,\n          datasources[filter.datasourceId] || {},\n          appliedColumns,\n          rejectedColumns,\n        ),\n      ),\n    [] as Indicator[],\n  );\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  cachedIndicatorsForChart[chartId] = indicators;\n  cachedDashboardFilterDataForChart[chartId] = {\n    appliedColumns,\n    rejectedColumns,\n    matchingFilters,\n    matchingDatasources,\n  };\n  return indicators;\n};\n\nconst cachedNativeIndicatorsForChart = {};\nconst cachedNativeFilterDataForChart: any = {};\nconst defaultChartConfig = {};\nexport const selectNativeIndicatorsForChart = (\n  nativeFilters: Filters,\n  dataMask: DataMaskStateWithId,\n  chartId: number,\n  chart: any,\n  dashboardLayout: Layout,\n  chartConfiguration: ChartConfiguration = defaultChartConfig,\n): Indicator[] => {\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n\n  const cachedFilterData = cachedNativeFilterDataForChart[chartId];\n  if (\n    cachedNativeIndicatorsForChart[chartId] &&\n    areObjectsEqual(cachedFilterData?.appliedColumns, appliedColumns) &&\n    areObjectsEqual(cachedFilterData?.rejectedColumns, rejectedColumns) &&\n    cachedFilterData?.nativeFilters === nativeFilters &&\n    cachedFilterData?.dashboardLayout === dashboardLayout &&\n    cachedFilterData?.chartConfiguration === chartConfiguration &&\n    cachedFilterData?.dataMask === dataMask\n  ) {\n    return cachedNativeIndicatorsForChart[chartId];\n  }\n  const getStatus = ({\n    label,\n    column,\n    type = DataMaskType.NativeFilters,\n  }: {\n    label: string | null;\n    column?: string;\n    type?: DataMaskType;\n  }): IndicatorStatus => {\n    // a filter is only considered unset if it's value is null\n    const hasValue = label !== null;\n    if (type === DataMaskType.CrossFilters && hasValue) {\n      return IndicatorStatus.CrossFilterApplied;\n    }\n    if (!column && hasValue) {\n      // Filter without datasource\n      return IndicatorStatus.Applied;\n    }\n    if (column && rejectedColumns.has(column))\n      return IndicatorStatus.Incompatible;\n    if (column && appliedColumns.has(column) && hasValue) {\n      return IndicatorStatus.Applied;\n    }\n    return IndicatorStatus.Unset;\n  };\n\n  let nativeFilterIndicators: any = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS)) {\n    nativeFilterIndicators =\n      nativeFilters &&\n      Object.values(nativeFilters)\n        .filter(nativeFilter =>\n          getTreeCheckedItems(nativeFilter.scope, dashboardLayout).some(\n            layoutItem =>\n              dashboardLayout[layoutItem]?.meta?.chartId === chartId,\n          ),\n        )\n        .map(nativeFilter => {\n          const column = nativeFilter.targets[0]?.column?.name;\n          const filterState = dataMask[nativeFilter.id]?.filterState;\n          const label = extractLabel(filterState);\n          return {\n            column,\n            name: nativeFilter.name,\n            path: [nativeFilter.id],\n            status: getStatus({ label, column }),\n            value: label,\n          };\n        });\n  }\n\n  let crossFilterIndicators: any = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    crossFilterIndicators = Object.values(chartConfiguration)\n      .filter(chartConfig =>\n        getTreeCheckedItems(\n          chartConfig?.crossFilters?.scope,\n          dashboardLayout,\n        ).some(\n          layoutItem => dashboardLayout[layoutItem]?.meta?.chartId === chartId,\n        ),\n      )\n      .map(chartConfig => {\n        const filterState = dataMask[chartConfig.id]?.filterState;\n        const label = extractLabel(filterState);\n        const filtersState = filterState?.filters;\n        const column = filtersState && Object.keys(filtersState)[0];\n\n        const dashboardLayoutItem = Object.values(dashboardLayout).find(\n          layoutItem => layoutItem?.meta?.chartId === chartConfig.id,\n        );\n        return {\n          column,\n          name: dashboardLayoutItem?.meta?.sliceName as string,\n          path: [\n            ...(dashboardLayoutItem?.parents ?? []),\n            dashboardLayoutItem?.id,\n          ],\n          status: getStatus({\n            label,\n            type: DataMaskType.CrossFilters,\n          }),\n          value: label,\n        };\n      })\n      .filter(filter => filter.status === IndicatorStatus.CrossFilterApplied);\n  }\n  const indicators = crossFilterIndicators.concat(nativeFilterIndicators);\n  cachedNativeIndicatorsForChart[chartId] = indicators;\n  cachedNativeFilterDataForChart[chartId] = {\n    nativeFilters,\n    dashboardLayout,\n    chartConfiguration,\n    dataMask,\n    appliedColumns,\n    rejectedColumns,\n  };\n  return indicators;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}