{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport isValidChild from './isValidChild';\nimport { TAB_TYPE, TABS_TYPE } from './componentTypes';\n\nexport const DROP_TOP = 'DROP_TOP';\nexport const DROP_RIGHT = 'DROP_RIGHT';\nexport const DROP_BOTTOM = 'DROP_BOTTOM';\nexport const DROP_LEFT = 'DROP_LEFT';\n\n// this defines how close the mouse must be to the edge of a component to display\n// a sibling type drop indicator\nconst SIBLING_DROP_THRESHOLD = 20;\nconst NON_SHALLOW_DROP_THRESHOLD = 20;\n\n// We cache the last recorded clientOffset per component in order to\n// have access to it beyond the handleHover phase and into the handleDrop phase\n// of drag-and-drop. we do not have access to it during drop because react-dnd's\n// monitor.getClientOffset() returns null at this point\nlet CACHED_CLIENT_OFFSET = {};\nexport function clearDropCache() {\n  CACHED_CLIENT_OFFSET = {};\n}\n\nexport default function getDropPosition(monitor, Component) {\n  const {\n    depth: componentDepth,\n    parentComponent,\n    component,\n    orientation,\n    isDraggingOverShallow } =\n  Component.props;\n\n  const draggingItem = monitor.getItem();\n\n  // if dropped self on self, do nothing\n  if (!draggingItem || draggingItem.id === component.id) {\n    return null;\n  }\n\n  // TODO need a better solution to prevent nested tabs\n  if (\n  draggingItem.type === TABS_TYPE &&\n  component.type === TAB_TYPE &&\n  componentDepth === 2)\n  {\n    return null;\n  }\n\n  const validChild = isValidChild({\n    parentType: component.type,\n    parentDepth: componentDepth,\n    childType: draggingItem.type });\n\n\n  const parentType = parentComponent && parentComponent.type;\n  const parentDepth = // see isValidChild.js for why tabs don't increment child depth\n  componentDepth + (\n  parentType === TAB_TYPE || parentType === TABS_TYPE ? 0 : -1);\n\n  const validSibling = isValidChild({\n    parentType,\n    parentDepth,\n    childType: draggingItem.type });\n\n\n  if (!validChild && !validSibling) {\n    return null;\n  }\n\n  const hasChildren = (component.children || []).length > 0;\n  const childDropOrientation =\n  orientation === 'row' ? 'vertical' : 'horizontal';\n  const siblingDropOrientation =\n  orientation === 'row' ? 'horizontal' : 'vertical';\n\n  if (isDraggingOverShallow && validChild && !validSibling) {\n    // easiest case, insert as child\n    if (childDropOrientation === 'vertical') {\n      return hasChildren ? DROP_RIGHT : DROP_LEFT;\n    }\n    return hasChildren ? DROP_BOTTOM : DROP_TOP;\n  }\n\n  const refBoundingRect = Component.ref.getBoundingClientRect();\n  const clientOffset =\n  monitor.getClientOffset() || CACHED_CLIENT_OFFSET[component.id];\n\n  if (!clientOffset || !refBoundingRect) {\n    return null;\n  }\n\n  CACHED_CLIENT_OFFSET[component.id] = clientOffset;\n  const deltaTop = Math.abs(clientOffset.y - refBoundingRect.top);\n  const deltaBottom = Math.abs(clientOffset.y - refBoundingRect.bottom);\n  const deltaLeft = Math.abs(clientOffset.x - refBoundingRect.left);\n  const deltaRight = Math.abs(clientOffset.x - refBoundingRect.right);\n\n  // Most of the time we only want a drop indicator for shallow (top-level, non-nested) drop targets\n  // However there are some cases where considering only shallow targets would result in NO drop\n  // indicators which is a bad UX.\n  // e.g.,\n  //    when dragging row-a over a chart that's in another row-b, the chart is the shallow droptarget\n  //    but row-a is not a valid child or sibling. in this case we want to show a sibling drop\n  //    indicator for row-b, which is NOT a shallow drop target.\n  // BUT if we ALWAYS consider non-shallow drop targets we may get multiple indicators shown at the\n  // same time, which is also a bad UX. to prevent this we can enforce a threshold proximity of the\n  // mouse to the edge of a non-shallow target\n  if (\n  !isDraggingOverShallow &&\n  [deltaTop, deltaBottom, deltaLeft, deltaRight].every(\n  (delta) => delta > NON_SHALLOW_DROP_THRESHOLD))\n\n  {\n    return null;\n  }\n\n  // Drop based on mouse position relative to component center\n  if (validSibling && !validChild) {\n    if (siblingDropOrientation === 'vertical') {\n      const refMiddleX =\n      refBoundingRect.left +\n      (refBoundingRect.right - refBoundingRect.left) / 2;\n      return clientOffset.x < refMiddleX ? DROP_LEFT : DROP_RIGHT;\n    }\n    const refMiddleY =\n    refBoundingRect.top + (refBoundingRect.bottom - refBoundingRect.top) / 2;\n    return clientOffset.y < refMiddleY ? DROP_TOP : DROP_BOTTOM;\n  }\n\n  // either is valid, so choose location based on boundary deltas\n  if (validSibling && validChild) {\n    // if near enough to a sibling boundary, drop there\n    if (siblingDropOrientation === 'vertical') {\n      if (deltaLeft < SIBLING_DROP_THRESHOLD) return DROP_LEFT;\n      if (deltaRight < SIBLING_DROP_THRESHOLD) return DROP_RIGHT;\n    } else {\n      if (deltaTop < SIBLING_DROP_THRESHOLD) return DROP_TOP;\n      if (deltaBottom < SIBLING_DROP_THRESHOLD) return DROP_BOTTOM;\n    }\n\n    // drop as child\n    if (childDropOrientation === 'vertical') {\n      return hasChildren ? DROP_RIGHT : DROP_LEFT;\n    }\n    return hasChildren ? DROP_BOTTOM : DROP_TOP;\n  }\n\n  return null;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(DROP_TOP, \"DROP_TOP\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(DROP_RIGHT, \"DROP_RIGHT\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(DROP_BOTTOM, \"DROP_BOTTOM\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(DROP_LEFT, \"DROP_LEFT\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(SIBLING_DROP_THRESHOLD, \"SIBLING_DROP_THRESHOLD\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(NON_SHALLOW_DROP_THRESHOLD, \"NON_SHALLOW_DROP_THRESHOLD\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(CACHED_CLIENT_OFFSET, \"CACHED_CLIENT_OFFSET\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(clearDropCache, \"clearDropCache\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(getDropPosition, \"getDropPosition\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(__signature__, \"__signature__\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(DROP_TOP, \"DROP_TOP\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(DROP_RIGHT, \"DROP_RIGHT\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(DROP_BOTTOM, \"DROP_BOTTOM\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(DROP_LEFT, \"DROP_LEFT\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(SIBLING_DROP_THRESHOLD, \"SIBLING_DROP_THRESHOLD\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(NON_SHALLOW_DROP_THRESHOLD, \"NON_SHALLOW_DROP_THRESHOLD\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(CACHED_CLIENT_OFFSET, \"CACHED_CLIENT_OFFSET\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(clearDropCache, \"clearDropCache\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");reactHotLoader.register(getDropPosition, \"getDropPosition\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/util/getDropPosition.js"],"names":["DROP_TOP","DROP_RIGHT","DROP_BOTTOM","DROP_LEFT","SIBLING_DROP_THRESHOLD","NON_SHALLOW_DROP_THRESHOLD","CACHED_CLIENT_OFFSET","clearDropCache","getDropPosition","depth","Component","draggingItem","monitor","component","componentDepth","validChild","isValidChild","parentType","parentDepth","childType","parentComponent","validSibling","hasChildren","childDropOrientation","orientation","siblingDropOrientation","isDraggingOverShallow","refBoundingRect","clientOffset","deltaTop","Math","deltaBottom","deltaLeft","deltaRight","delta","refMiddleX","refMiddleY"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport isValidChild from './isValidChild';\nimport { TAB_TYPE, TABS_TYPE } from './componentTypes';\n\nexport const DROP_TOP = 'DROP_TOP';\nexport const DROP_RIGHT = 'DROP_RIGHT';\nexport const DROP_BOTTOM = 'DROP_BOTTOM';\nexport const DROP_LEFT = 'DROP_LEFT';\n\n// this defines how close the mouse must be to the edge of a component to display\n// a sibling type drop indicator\nconst SIBLING_DROP_THRESHOLD = 20;\nconst NON_SHALLOW_DROP_THRESHOLD = 20;\n\n// We cache the last recorded clientOffset per component in order to\n// have access to it beyond the handleHover phase and into the handleDrop phase\n// of drag-and-drop. we do not have access to it during drop because react-dnd's\n// monitor.getClientOffset() returns null at this point\nlet CACHED_CLIENT_OFFSET = {};\nexport function clearDropCache() {\n  CACHED_CLIENT_OFFSET = {};\n}\n\nexport default function getDropPosition(monitor, Component) {\n  const {\n    depth: componentDepth,\n    parentComponent,\n    component,\n    orientation,\n    isDraggingOverShallow,\n  } = Component.props;\n\n  const draggingItem = monitor.getItem();\n\n  // if dropped self on self, do nothing\n  if (!draggingItem || draggingItem.id === component.id) {\n    return null;\n  }\n\n  // TODO need a better solution to prevent nested tabs\n  if (\n    draggingItem.type === TABS_TYPE &&\n    component.type === TAB_TYPE &&\n    componentDepth === 2\n  ) {\n    return null;\n  }\n\n  const validChild = isValidChild({\n    parentType: component.type,\n    parentDepth: componentDepth,\n    childType: draggingItem.type,\n  });\n\n  const parentType = parentComponent && parentComponent.type;\n  const parentDepth = // see isValidChild.js for why tabs don't increment child depth\n    componentDepth +\n    (parentType === TAB_TYPE || parentType === TABS_TYPE ? 0 : -1);\n\n  const validSibling = isValidChild({\n    parentType,\n    parentDepth,\n    childType: draggingItem.type,\n  });\n\n  if (!validChild && !validSibling) {\n    return null;\n  }\n\n  const hasChildren = (component.children || []).length > 0;\n  const childDropOrientation =\n    orientation === 'row' ? 'vertical' : 'horizontal';\n  const siblingDropOrientation =\n    orientation === 'row' ? 'horizontal' : 'vertical';\n\n  if (isDraggingOverShallow && validChild && !validSibling) {\n    // easiest case, insert as child\n    if (childDropOrientation === 'vertical') {\n      return hasChildren ? DROP_RIGHT : DROP_LEFT;\n    }\n    return hasChildren ? DROP_BOTTOM : DROP_TOP;\n  }\n\n  const refBoundingRect = Component.ref.getBoundingClientRect();\n  const clientOffset =\n    monitor.getClientOffset() || CACHED_CLIENT_OFFSET[component.id];\n\n  if (!clientOffset || !refBoundingRect) {\n    return null;\n  }\n\n  CACHED_CLIENT_OFFSET[component.id] = clientOffset;\n  const deltaTop = Math.abs(clientOffset.y - refBoundingRect.top);\n  const deltaBottom = Math.abs(clientOffset.y - refBoundingRect.bottom);\n  const deltaLeft = Math.abs(clientOffset.x - refBoundingRect.left);\n  const deltaRight = Math.abs(clientOffset.x - refBoundingRect.right);\n\n  // Most of the time we only want a drop indicator for shallow (top-level, non-nested) drop targets\n  // However there are some cases where considering only shallow targets would result in NO drop\n  // indicators which is a bad UX.\n  // e.g.,\n  //    when dragging row-a over a chart that's in another row-b, the chart is the shallow droptarget\n  //    but row-a is not a valid child or sibling. in this case we want to show a sibling drop\n  //    indicator for row-b, which is NOT a shallow drop target.\n  // BUT if we ALWAYS consider non-shallow drop targets we may get multiple indicators shown at the\n  // same time, which is also a bad UX. to prevent this we can enforce a threshold proximity of the\n  // mouse to the edge of a non-shallow target\n  if (\n    !isDraggingOverShallow &&\n    [deltaTop, deltaBottom, deltaLeft, deltaRight].every(\n      delta => delta > NON_SHALLOW_DROP_THRESHOLD,\n    )\n  ) {\n    return null;\n  }\n\n  // Drop based on mouse position relative to component center\n  if (validSibling && !validChild) {\n    if (siblingDropOrientation === 'vertical') {\n      const refMiddleX =\n        refBoundingRect.left +\n        (refBoundingRect.right - refBoundingRect.left) / 2;\n      return clientOffset.x < refMiddleX ? DROP_LEFT : DROP_RIGHT;\n    }\n    const refMiddleY =\n      refBoundingRect.top + (refBoundingRect.bottom - refBoundingRect.top) / 2;\n    return clientOffset.y < refMiddleY ? DROP_TOP : DROP_BOTTOM;\n  }\n\n  // either is valid, so choose location based on boundary deltas\n  if (validSibling && validChild) {\n    // if near enough to a sibling boundary, drop there\n    if (siblingDropOrientation === 'vertical') {\n      if (deltaLeft < SIBLING_DROP_THRESHOLD) return DROP_LEFT;\n      if (deltaRight < SIBLING_DROP_THRESHOLD) return DROP_RIGHT;\n    } else {\n      if (deltaTop < SIBLING_DROP_THRESHOLD) return DROP_TOP;\n      if (deltaBottom < SIBLING_DROP_THRESHOLD) return DROP_BOTTOM;\n    }\n\n    // drop as child\n    if (childDropOrientation === 'vertical') {\n      return hasChildren ? DROP_RIGHT : DROP_LEFT;\n    }\n    return hasChildren ? DROP_BOTTOM : DROP_TOP;\n  }\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}