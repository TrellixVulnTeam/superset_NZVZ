{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport moment from 'moment';\nimport { SEPARATOR } from './dateFilterUtils';\nimport { SEVEN_DAYS_AGO, MIDNIGHT, MOMENT_FORMAT } from './constants';\n/**\n * RegExp to test a string for a full ISO 8601 Date\n * Does not do any sort of date validation, only checks if the string is according to the ISO 8601 spec.\n *  YYYY-MM-DDThh:mm:ss\n *  YYYY-MM-DDThh:mm:ssTZD\n *  YYYY-MM-DDThh:mm:ss.sTZD\n * @see: https://www.w3.org/TR/NOTE-datetime\n */\nconst iso8601 = String.raw`\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.\\d+)?(?:(?:[+-]\\d\\d:\\d\\d)|Z)?`;\nconst datetimeConstant = String.raw`TODAY|NOW`;\nconst grainValue = String.raw`[+-]?[1-9][0-9]*`;\nconst grain = String.raw`YEAR|QUARTER|MONTH|WEEK|DAY|HOUR|MINUTE|SECOND`;\nconst CUSTOM_RANGE_EXPRESSION = RegExp(String.raw`^DATEADD\\(DATETIME\\(\"(${iso8601}|${datetimeConstant})\"\\),\\s(${grainValue}),\\s(${grain})\\)$`, 'i');\nexport const ISO8601_AND_CONSTANT = RegExp(String.raw`^${iso8601}$|^${datetimeConstant}$`, 'i');\nconst DATETIME_CONSTANT = ['now', 'today'];\nconst defaultCustomRange = {\n  sinceDatetime: SEVEN_DAYS_AGO,\n  sinceMode: 'relative',\n  sinceGrain: 'day',\n  sinceGrainValue: -7,\n  untilDatetime: MIDNIGHT,\n  untilMode: 'specific',\n  untilGrain: 'day',\n  untilGrainValue: 7,\n  anchorMode: 'now',\n  anchorValue: 'now' };\n\nconst SPECIFIC_MODE = ['specific', 'today', 'now'];\nexport const dttmToMoment = (dttm) => {\n  if (dttm === 'now') {\n    return moment().utc().startOf('second');\n  }\n  if (dttm === 'today') {\n    return moment().utc().startOf('day');\n  }\n  return moment(dttm);\n};\nexport const dttmToString = (dttm) => dttmToMoment(dttm).format(MOMENT_FORMAT);\nexport const customTimeRangeDecode = (timeRange) => {\n  const splitDateRange = timeRange.split(SEPARATOR);\n  if (splitDateRange.length === 2) {\n    const [since, until] = splitDateRange;\n    // specific : specific\n    if (ISO8601_AND_CONSTANT.test(since) && ISO8601_AND_CONSTANT.test(until)) {\n      const sinceMode = DATETIME_CONSTANT.includes(since) ?\n      since :\n      'specific';\n      const untilMode = DATETIME_CONSTANT.includes(until) ?\n      until :\n      'specific';\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          sinceDatetime: since,\n          untilDatetime: until,\n          sinceMode,\n          untilMode },\n\n        matchedFlag: true };\n\n    }\n    // relative : specific\n    const sinceCapturedGroup = since.match(CUSTOM_RANGE_EXPRESSION);\n    if (sinceCapturedGroup &&\n    ISO8601_AND_CONSTANT.test(until) &&\n    since.includes(until)) {\n      const [dttm, grainValue, grain] = sinceCapturedGroup.slice(1);\n      const untilMode = DATETIME_CONSTANT.includes(until) ?\n      until :\n      'specific';\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          sinceGrain: grain,\n          sinceGrainValue: parseInt(grainValue, 10),\n          sinceDatetime: dttm,\n          untilDatetime: dttm,\n          sinceMode: 'relative',\n          untilMode },\n\n        matchedFlag: true };\n\n    }\n    // specific : relative\n    const untilCapturedGroup = until.match(CUSTOM_RANGE_EXPRESSION);\n    if (ISO8601_AND_CONSTANT.test(since) &&\n    untilCapturedGroup &&\n    until.includes(since)) {\n      const [dttm, grainValue, grain] = [...untilCapturedGroup.slice(1)];\n      const sinceMode = DATETIME_CONSTANT.includes(since) ?\n      since :\n      'specific';\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          untilGrain: grain,\n          untilGrainValue: parseInt(grainValue, 10),\n          sinceDatetime: dttm,\n          untilDatetime: dttm,\n          untilMode: 'relative',\n          sinceMode },\n\n        matchedFlag: true };\n\n    }\n    // relative : relative\n    if (sinceCapturedGroup && untilCapturedGroup) {\n      const [sinceDttm, sinceGrainValue, sinceGrain] = [\n      ...sinceCapturedGroup.slice(1)];\n\n      const [untileDttm, untilGrainValue, untilGrain] = [\n      ...untilCapturedGroup.slice(1)];\n\n      if (sinceDttm === untileDttm) {\n        return {\n          customRange: {\n            ...defaultCustomRange,\n            sinceGrain: sinceGrain,\n            sinceGrainValue: parseInt(sinceGrainValue, 10),\n            sinceDatetime: sinceDttm,\n            untilGrain: untilGrain,\n            untilGrainValue: parseInt(untilGrainValue, 10),\n            untilDatetime: untileDttm,\n            anchorValue: sinceDttm,\n            sinceMode: 'relative',\n            untilMode: 'relative',\n            anchorMode: sinceDttm === 'now' ? 'now' : 'specific' },\n\n          matchedFlag: true };\n\n      }\n    }\n  }\n  return {\n    customRange: defaultCustomRange,\n    matchedFlag: false };\n\n};\nexport const customTimeRangeEncode = (customRange) => {\n  const { sinceDatetime, sinceMode, sinceGrain, sinceGrainValue, untilDatetime, untilMode, untilGrain, untilGrainValue, anchorValue } = { ...customRange };\n  // specific : specific\n  if (SPECIFIC_MODE.includes(sinceMode) && SPECIFIC_MODE.includes(untilMode)) {\n    const since = sinceMode === 'specific' ? dttmToString(sinceDatetime) : sinceMode;\n    const until = untilMode === 'specific' ? dttmToString(untilDatetime) : untilMode;\n    return `${since} : ${until}`;\n  }\n  // specific : relative\n  if (SPECIFIC_MODE.includes(sinceMode) && untilMode === 'relative') {\n    const since = sinceMode === 'specific' ? dttmToString(sinceDatetime) : sinceMode;\n    const until = `DATEADD(DATETIME(\"${since}\"), ${untilGrainValue}, ${untilGrain})`;\n    return `${since} : ${until}`;\n  }\n  // relative : specific\n  if (sinceMode === 'relative' && SPECIFIC_MODE.includes(untilMode)) {\n    const until = untilMode === 'specific' ? dttmToString(untilDatetime) : untilMode;\n    const since = `DATEADD(DATETIME(\"${until}\"), ${-Math.abs(sinceGrainValue)}, ${sinceGrain})`;\n    return `${since} : ${until}`;\n  }\n  // relative : relative\n  const since = `DATEADD(DATETIME(\"${anchorValue}\"), ${-Math.abs(sinceGrainValue)}, ${sinceGrain})`;\n  const until = `DATEADD(DATETIME(\"${anchorValue}\"), ${untilGrainValue}, ${untilGrain})`;\n  return `${since} : ${until}`;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(iso8601, \"iso8601\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(datetimeConstant, \"datetimeConstant\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(grainValue, \"grainValue\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(grain, \"grain\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(CUSTOM_RANGE_EXPRESSION, \"CUSTOM_RANGE_EXPRESSION\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(ISO8601_AND_CONSTANT, \"ISO8601_AND_CONSTANT\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(DATETIME_CONSTANT, \"DATETIME_CONSTANT\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(defaultCustomRange, \"defaultCustomRange\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(SPECIFIC_MODE, \"SPECIFIC_MODE\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(dttmToMoment, \"dttmToMoment\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(dttmToString, \"dttmToString\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(customTimeRangeDecode, \"customTimeRangeDecode\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");reactHotLoader.register(customTimeRangeEncode, \"customTimeRangeEncode\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport moment, { Moment } from 'moment';\nimport {\n  CustomRangeDecodeType,\n  CustomRangeType,\n  DateTimeGrainType,\n  DateTimeModeType,\n} from 'src/explore/components/controls/DateFilterControl/types';\nimport { SEPARATOR } from './dateFilterUtils';\nimport { SEVEN_DAYS_AGO, MIDNIGHT, MOMENT_FORMAT } from './constants';\n\n/**\n * RegExp to test a string for a full ISO 8601 Date\n * Does not do any sort of date validation, only checks if the string is according to the ISO 8601 spec.\n *  YYYY-MM-DDThh:mm:ss\n *  YYYY-MM-DDThh:mm:ssTZD\n *  YYYY-MM-DDThh:mm:ss.sTZD\n * @see: https://www.w3.org/TR/NOTE-datetime\n */\nconst iso8601 = String.raw`\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.\\d+)?(?:(?:[+-]\\d\\d:\\d\\d)|Z)?`;\nconst datetimeConstant = String.raw`TODAY|NOW`;\nconst grainValue = String.raw`[+-]?[1-9][0-9]*`;\nconst grain = String.raw`YEAR|QUARTER|MONTH|WEEK|DAY|HOUR|MINUTE|SECOND`;\nconst CUSTOM_RANGE_EXPRESSION = RegExp(\n  String.raw`^DATEADD\\(DATETIME\\(\"(${iso8601}|${datetimeConstant})\"\\),\\s(${grainValue}),\\s(${grain})\\)$`,\n  'i',\n);\nexport const ISO8601_AND_CONSTANT = RegExp(\n  String.raw`^${iso8601}$|^${datetimeConstant}$`,\n  'i',\n);\nconst DATETIME_CONSTANT = ['now', 'today'];\nconst defaultCustomRange: CustomRangeType = {\n  sinceDatetime: SEVEN_DAYS_AGO,\n  sinceMode: 'relative',\n  sinceGrain: 'day',\n  sinceGrainValue: -7,\n  untilDatetime: MIDNIGHT,\n  untilMode: 'specific',\n  untilGrain: 'day',\n  untilGrainValue: 7,\n  anchorMode: 'now',\n  anchorValue: 'now',\n};\nconst SPECIFIC_MODE = ['specific', 'today', 'now'];\n\nexport const dttmToMoment = (dttm: string): Moment => {\n  if (dttm === 'now') {\n    return moment().utc().startOf('second');\n  }\n  if (dttm === 'today') {\n    return moment().utc().startOf('day');\n  }\n  return moment(dttm);\n};\n\nexport const dttmToString = (dttm: string): string =>\n  dttmToMoment(dttm).format(MOMENT_FORMAT);\n\nexport const customTimeRangeDecode = (\n  timeRange: string,\n): CustomRangeDecodeType => {\n  const splitDateRange = timeRange.split(SEPARATOR);\n\n  if (splitDateRange.length === 2) {\n    const [since, until] = splitDateRange;\n\n    // specific : specific\n    if (ISO8601_AND_CONSTANT.test(since) && ISO8601_AND_CONSTANT.test(until)) {\n      const sinceMode = (DATETIME_CONSTANT.includes(since)\n        ? since\n        : 'specific') as DateTimeModeType;\n      const untilMode = (DATETIME_CONSTANT.includes(until)\n        ? until\n        : 'specific') as DateTimeModeType;\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          sinceDatetime: since,\n          untilDatetime: until,\n          sinceMode,\n          untilMode,\n        },\n        matchedFlag: true,\n      };\n    }\n\n    // relative : specific\n    const sinceCapturedGroup = since.match(CUSTOM_RANGE_EXPRESSION);\n    if (\n      sinceCapturedGroup &&\n      ISO8601_AND_CONSTANT.test(until) &&\n      since.includes(until)\n    ) {\n      const [dttm, grainValue, grain] = sinceCapturedGroup.slice(1);\n      const untilMode = (DATETIME_CONSTANT.includes(until)\n        ? until\n        : 'specific') as DateTimeModeType;\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          sinceGrain: grain as DateTimeGrainType,\n          sinceGrainValue: parseInt(grainValue, 10),\n          sinceDatetime: dttm,\n          untilDatetime: dttm,\n          sinceMode: 'relative',\n          untilMode,\n        },\n        matchedFlag: true,\n      };\n    }\n\n    // specific : relative\n    const untilCapturedGroup = until.match(CUSTOM_RANGE_EXPRESSION);\n    if (\n      ISO8601_AND_CONSTANT.test(since) &&\n      untilCapturedGroup &&\n      until.includes(since)\n    ) {\n      const [dttm, grainValue, grain] = [...untilCapturedGroup.slice(1)];\n      const sinceMode = (DATETIME_CONSTANT.includes(since)\n        ? since\n        : 'specific') as DateTimeModeType;\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          untilGrain: grain as DateTimeGrainType,\n          untilGrainValue: parseInt(grainValue, 10),\n          sinceDatetime: dttm,\n          untilDatetime: dttm,\n          untilMode: 'relative',\n          sinceMode,\n        },\n        matchedFlag: true,\n      };\n    }\n\n    // relative : relative\n    if (sinceCapturedGroup && untilCapturedGroup) {\n      const [sinceDttm, sinceGrainValue, sinceGrain] = [\n        ...sinceCapturedGroup.slice(1),\n      ];\n      const [untileDttm, untilGrainValue, untilGrain] = [\n        ...untilCapturedGroup.slice(1),\n      ];\n      if (sinceDttm === untileDttm) {\n        return {\n          customRange: {\n            ...defaultCustomRange,\n            sinceGrain: sinceGrain as DateTimeGrainType,\n            sinceGrainValue: parseInt(sinceGrainValue, 10),\n            sinceDatetime: sinceDttm,\n            untilGrain: untilGrain as DateTimeGrainType,\n            untilGrainValue: parseInt(untilGrainValue, 10),\n            untilDatetime: untileDttm,\n            anchorValue: sinceDttm,\n            sinceMode: 'relative',\n            untilMode: 'relative',\n            anchorMode: sinceDttm === 'now' ? 'now' : 'specific',\n          },\n          matchedFlag: true,\n        };\n      }\n    }\n  }\n\n  return {\n    customRange: defaultCustomRange,\n    matchedFlag: false,\n  };\n};\n\nexport const customTimeRangeEncode = (customRange: CustomRangeType): string => {\n  const {\n    sinceDatetime,\n    sinceMode,\n    sinceGrain,\n    sinceGrainValue,\n    untilDatetime,\n    untilMode,\n    untilGrain,\n    untilGrainValue,\n    anchorValue,\n  } = { ...customRange };\n  // specific : specific\n  if (SPECIFIC_MODE.includes(sinceMode) && SPECIFIC_MODE.includes(untilMode)) {\n    const since =\n      sinceMode === 'specific' ? dttmToString(sinceDatetime) : sinceMode;\n    const until =\n      untilMode === 'specific' ? dttmToString(untilDatetime) : untilMode;\n    return `${since} : ${until}`;\n  }\n\n  // specific : relative\n  if (SPECIFIC_MODE.includes(sinceMode) && untilMode === 'relative') {\n    const since =\n      sinceMode === 'specific' ? dttmToString(sinceDatetime) : sinceMode;\n    const until = `DATEADD(DATETIME(\"${since}\"), ${untilGrainValue}, ${untilGrain})`;\n    return `${since} : ${until}`;\n  }\n\n  // relative : specific\n  if (sinceMode === 'relative' && SPECIFIC_MODE.includes(untilMode)) {\n    const until =\n      untilMode === 'specific' ? dttmToString(untilDatetime) : untilMode;\n    const since = `DATEADD(DATETIME(\"${until}\"), ${-Math.abs(\n      sinceGrainValue,\n    )}, ${sinceGrain})`;\n    return `${since} : ${until}`;\n  }\n\n  // relative : relative\n  const since = `DATEADD(DATETIME(\"${anchorValue}\"), ${-Math.abs(\n    sinceGrainValue,\n  )}, ${sinceGrain})`;\n  const until = `DATEADD(DATETIME(\"${anchorValue}\"), ${untilGrainValue}, ${untilGrain})`;\n  return `${since} : ${until}`;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}