{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}\n\nimport { SyncRegistry } from '@encodable/registry';\nimport { getCategoricalScheme, getColorSchemeRegistry } from '../scheme';\nimport stringifyAndTrim from '../utils/stringifyAndTrim';\nimport ScaleCategoricalColor from './ScaleCategoricalColor';\nexport default class ColorNamespace {\n  constructor(nameOrState) {\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"scales\", void 0);\n\n    this.state = typeof nameOrState === 'string' ? {\n      name: nameOrState,\n      manualColors: {},\n      scales: {} } :\n    nameOrState;\n    this.scales = new SyncRegistry();\n  }\n\n  get name() {\n    return this.state.name;\n  }\n  /**\n   * Check if the specified value is subjected to manual color assignment\n   * @param value\n   */\n\n\n  hasManualColor(value) {\n    return typeof this.state.manualColors[stringifyAndTrim(value)] !== 'undefined';\n  }\n  /**\n   * Enforce specific color for given value\n   * This will apply across all color scales\n   * in this namespace.\n   * @param {*} value value\n   * @param {*} manualColor color\n   */\n\n\n  setColor(value, manualColor) {\n    this.state.manualColors[stringifyAndTrim(value)] = manualColor;\n    return this;\n  }\n  /**\n   * Removed enforced specific color for given value\n   * This will apply across all color scales\n   * in this namespace.\n   * @param {*} value value\n   * @param {*} manualColor color\n   */\n\n\n  unsetColor(value) {\n    delete this.state.manualColors[stringifyAndTrim(value)];\n    return this;\n  }\n  /**\n   * Clear all manually assigned colors\n   */\n\n\n  clearManualColors() {\n    this.state.manualColors = {};\n    return this;\n  }\n\n  hasScale(scheme) {\n    return typeof this.state.scales[scheme] !== 'undefined';\n  }\n\n  getScale(scheme) {var _ref;\n    const schemeName = (_ref = scheme != null ? scheme : getColorSchemeRegistry().categorical.getDefaultKey()) != null ? _ref : 'undefined';\n\n    if (typeof this.state.scales[schemeName] === 'undefined') {var _getCategoricalScheme, _getCategoricalScheme2;\n      // create scale\n      const scale = new ScaleCategoricalColor((_getCategoricalScheme = (_getCategoricalScheme2 = getCategoricalScheme(schemeName)) == null ? void 0 : _getCategoricalScheme2.colors.slice()) != null ? _getCategoricalScheme : [], this.state.manualColors); // add state to lookup\n\n      this.state.scales[schemeName] = scale.state;\n      this.scales.registerValue(schemeName, scale);\n      return scale;\n    }\n\n    if (this.scales.has(schemeName)) {\n      return this.scales.get(schemeName);\n    } // create scale\n\n\n    const scale = new ScaleCategoricalColor(this.state.scales[schemeName], this.state.manualColors);\n    this.scales.registerValue(schemeName, scale);\n    return scale;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_defineProperty, \"_defineProperty\", \"/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/color/esm/scale/ColorNamespace.js\");reactHotLoader.register(ColorNamespace, \"ColorNamespace\", \"/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/color/esm/scale/ColorNamespace.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/color/esm/scale/ColorNamespace.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","SyncRegistry","getCategoricalScheme","getColorSchemeRegistry","stringifyAndTrim","ScaleCategoricalColor","ColorNamespace","constructor","nameOrState","state","name","manualColors","scales","hasManualColor","setColor","manualColor","unsetColor","clearManualColors","hasScale","scheme","getScale","schemeName","categorical","getDefaultKey","scale","colors","slice","registerValue","has","get"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { SyncRegistry } from '@encodable/registry';\nimport { getCategoricalScheme, getColorSchemeRegistry } from '../scheme';\nimport stringifyAndTrim from '../utils/stringifyAndTrim';\nimport ScaleCategoricalColor from './ScaleCategoricalColor';\nexport default class ColorNamespace {\n  constructor(nameOrState) {\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"scales\", void 0);\n\n    this.state = typeof nameOrState === 'string' ? {\n      name: nameOrState,\n      manualColors: {},\n      scales: {}\n    } : nameOrState;\n    this.scales = new SyncRegistry();\n  }\n\n  get name() {\n    return this.state.name;\n  }\n  /**\n   * Check if the specified value is subjected to manual color assignment\n   * @param value\n   */\n\n\n  hasManualColor(value) {\n    return typeof this.state.manualColors[stringifyAndTrim(value)] !== 'undefined';\n  }\n  /**\n   * Enforce specific color for given value\n   * This will apply across all color scales\n   * in this namespace.\n   * @param {*} value value\n   * @param {*} manualColor color\n   */\n\n\n  setColor(value, manualColor) {\n    this.state.manualColors[stringifyAndTrim(value)] = manualColor;\n    return this;\n  }\n  /**\n   * Removed enforced specific color for given value\n   * This will apply across all color scales\n   * in this namespace.\n   * @param {*} value value\n   * @param {*} manualColor color\n   */\n\n\n  unsetColor(value) {\n    delete this.state.manualColors[stringifyAndTrim(value)];\n    return this;\n  }\n  /**\n   * Clear all manually assigned colors\n   */\n\n\n  clearManualColors() {\n    this.state.manualColors = {};\n    return this;\n  }\n\n  hasScale(scheme) {\n    return typeof this.state.scales[scheme] !== 'undefined';\n  }\n\n  getScale(scheme) {\n    const schemeName = scheme ?? getColorSchemeRegistry().categorical.getDefaultKey() ?? 'undefined';\n\n    if (typeof this.state.scales[schemeName] === 'undefined') {\n      // create scale\n      const scale = new ScaleCategoricalColor(getCategoricalScheme(schemeName)?.colors.slice() ?? [], this.state.manualColors); // add state to lookup\n\n      this.state.scales[schemeName] = scale.state;\n      this.scales.registerValue(schemeName, scale);\n      return scale;\n    }\n\n    if (this.scales.has(schemeName)) {\n      return this.scales.get(schemeName);\n    } // create scale\n\n\n    const scale = new ScaleCategoricalColor(this.state.scales[schemeName], this.state.manualColors);\n    this.scales.registerValue(schemeName, scale);\n    return scale;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}