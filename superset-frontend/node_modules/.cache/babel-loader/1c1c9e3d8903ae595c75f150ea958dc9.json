{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport {\nDASHBOARD_ROOT_ID,\nDASHBOARD_GRID_ID,\nNEW_COMPONENTS_SOURCE_ID,\nDASHBOARD_HEADER_ID } from\n'../util/constants';\nimport componentIsResizable from '../util/componentIsResizable';\nimport findParentId from '../util/findParentId';\nimport getComponentWidthFromDrop from '../util/getComponentWidthFromDrop';\nimport updateComponentParentsList from '../util/updateComponentParentsList';\nimport newComponentFactory from '../util/newComponentFactory';\nimport newEntitiesFromDrop from '../util/newEntitiesFromDrop';\nimport reorderItem from '../util/dnd-reorder';\nimport shouldWrapChildInRow from '../util/shouldWrapChildInRow';\nimport { ROW_TYPE, TAB_TYPE, TABS_TYPE } from '../util/componentTypes';\n\nimport {\nUPDATE_COMPONENTS,\nUPDATE_COMPONENTS_PARENTS_LIST,\nDELETE_COMPONENT,\nCREATE_COMPONENT,\nMOVE_COMPONENT,\nCREATE_TOP_LEVEL_TABS,\nDELETE_TOP_LEVEL_TABS,\nDASHBOARD_TITLE_CHANGED } from\n'../actions/dashboardLayout';\n\nimport { HYDRATE_DASHBOARD } from '../actions/hydrate';\n\nconst actionHandlers = {\n  [HYDRATE_DASHBOARD](state, action) {\n    return {\n      ...action.data.dashboardLayout.present };\n\n  },\n\n  [UPDATE_COMPONENTS](state, action) {\n    const {\n      payload: { nextComponents } } =\n    action;\n    return {\n      ...state,\n      ...nextComponents };\n\n  },\n\n  [DELETE_COMPONENT](state, action) {\n    const {\n      payload: { id, parentId } } =\n    action;\n\n    if (!parentId || !id || !state[id] || !state[parentId]) return state;\n\n    const nextComponents = { ...state };\n\n    function recursivelyDeleteChildren(componentId, componentParentId) {\n      // delete child and it's children\n      const component = nextComponents[componentId];\n      delete nextComponents[componentId];\n\n      const { children = [] } = component;\n      children.forEach((childId) => {\n        recursivelyDeleteChildren(childId, componentId);\n      });\n\n      const parent = nextComponents[componentParentId];\n      if (parent) {\n        // may have been deleted in another recursion\n        const componentIndex = (parent.children || []).indexOf(componentId);\n        if (componentIndex > -1) {\n          const nextChildren = [...parent.children];\n          nextChildren.splice(componentIndex, 1);\n          nextComponents[componentParentId] = {\n            ...parent,\n            children: nextChildren };\n\n        }\n      }\n    }\n\n    recursivelyDeleteChildren(id, parentId);\n    const nextParent = nextComponents[parentId];\n    if (nextParent.type === ROW_TYPE && nextParent.children.length === 0) {\n      const grandparentId = findParentId({\n        childId: parentId,\n        layout: nextComponents });\n\n      recursivelyDeleteChildren(parentId, grandparentId);\n    }\n\n    return nextComponents;\n  },\n\n  [CREATE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n\n    return {\n      ...state,\n      ...newEntities };\n\n  },\n\n  [MOVE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n    const { source, destination, dragging } = dropResult;\n\n    if (!source || !destination || !dragging) return state;\n\n    const nextEntities = reorderItem({\n      entitiesMap: state,\n      source,\n      destination });\n\n\n    if (componentIsResizable(nextEntities[dragging.id])) {\n      // update component width if it changed\n      const nextWidth =\n      getComponentWidthFromDrop({\n        dropResult,\n        layout: state }) ||\n      undefined; // don't set a 0 width\n      if ((nextEntities[dragging.id].meta || {}).width !== nextWidth) {\n        nextEntities[dragging.id] = {\n          ...nextEntities[dragging.id],\n          meta: {\n            ...nextEntities[dragging.id].meta,\n            width: nextWidth } };\n\n\n      }\n    }\n\n    // wrap the dragged component in a row depending on destination type\n    const wrapInRow = shouldWrapChildInRow({\n      parentType: destination.type,\n      childType: dragging.type });\n\n\n    if (wrapInRow) {\n      const destinationEntity = nextEntities[destination.id];\n      const destinationChildren = destinationEntity.children;\n      const newRow = newComponentFactory(ROW_TYPE);\n      newRow.children = [destinationChildren[destination.index]];\n      newRow.parents = (destinationEntity.parents || []).concat(destination.id);\n      destinationChildren[destination.index] = newRow.id;\n      nextEntities[newRow.id] = newRow;\n    }\n\n    return {\n      ...state,\n      ...nextEntities };\n\n  },\n\n  [CREATE_TOP_LEVEL_TABS](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n    const { source, dragging } = dropResult;\n\n    // move children of current root to be children of the dragging tab\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelComponent = state[topLevelId];\n\n    if (source.id !== NEW_COMPONENTS_SOURCE_ID) {\n      // component already exists\n      const draggingTabs = state[dragging.id];\n      const draggingTabId = draggingTabs.children[0];\n      const draggingTab = state[draggingTabId];\n\n      // move all children except the one that is dragging\n      const childrenToMove = [...topLevelComponent.children].filter(\n      (id) => id !== dragging.id);\n\n\n      return {\n        ...state,\n        [DASHBOARD_ROOT_ID]: {\n          ...rootComponent,\n          children: [dragging.id] },\n\n        [topLevelId]: {\n          ...topLevelComponent,\n          children: [] },\n\n        [draggingTabId]: {\n          ...draggingTab,\n          children: [...draggingTab.children, ...childrenToMove] } };\n\n\n    }\n\n    // create new component\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n    const newEntitiesArray = Object.values(newEntities);\n    const tabComponent = newEntitiesArray.find(\n    (component) => component.type === TAB_TYPE);\n\n    const tabsComponent = newEntitiesArray.find(\n    (component) => component.type === TABS_TYPE);\n\n\n    tabComponent.children = [...topLevelComponent.children];\n    newEntities[topLevelId] = { ...topLevelComponent, children: [] };\n    newEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [tabsComponent.id] };\n\n\n    return {\n      ...state,\n      ...newEntities };\n\n  },\n\n  [DELETE_TOP_LEVEL_TABS](state) {\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelTabs = state[topLevelId];\n\n    if (topLevelTabs.type !== TABS_TYPE) return state;\n\n    let childrenToMove = [];\n    const nextEntities = { ...state };\n\n    topLevelTabs.children.forEach((tabId) => {\n      const tabComponent = state[tabId];\n      childrenToMove = [...childrenToMove, ...tabComponent.children];\n      delete nextEntities[tabId];\n    });\n\n    delete nextEntities[topLevelId];\n\n    nextEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [DASHBOARD_GRID_ID] };\n\n\n    nextEntities[DASHBOARD_GRID_ID] = {\n      ...state[DASHBOARD_GRID_ID],\n      children: childrenToMove };\n\n\n    return nextEntities;\n  },\n\n  [UPDATE_COMPONENTS_PARENTS_LIST](state) {\n    const nextState = {\n      ...state };\n\n\n    updateComponentParentsList({\n      currentComponent: nextState[DASHBOARD_ROOT_ID],\n      layout: nextState });\n\n\n    return {\n      ...nextState };\n\n  },\n\n  [DASHBOARD_TITLE_CHANGED](state, action) {\n    return {\n      ...state,\n      [DASHBOARD_HEADER_ID]: {\n        ...state[DASHBOARD_HEADER_ID],\n        meta: {\n          ...state[DASHBOARD_HEADER_ID].meta,\n          text: action.text } } };\n\n\n\n  } };\n\n\nexport default function layoutReducer(state = {}, action) {\n  if (action.type in actionHandlers) {\n    const handler = actionHandlers[action.type];\n    return handler(state, action);\n  }\n\n  return state;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(actionHandlers, \"actionHandlers\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/reducers/dashboardLayout.js\");reactHotLoader.register(layoutReducer, \"layoutReducer\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/reducers/dashboardLayout.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(__signature__, \"__signature__\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/reducers/dashboardLayout.js\");reactHotLoader.register(actionHandlers, \"actionHandlers\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/reducers/dashboardLayout.js\");reactHotLoader.register(layoutReducer, \"layoutReducer\", \"/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/reducers/dashboardLayout.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/src/dashboard/reducers/dashboardLayout.js"],"names":["actionHandlers","action","payload","state","nextComponents","component","children","recursivelyDeleteChildren","parent","componentIndex","nextChildren","nextParent","grandparentId","findParentId","childId","layout","newEntities","newEntitiesFromDrop","nextEntities","reorderItem","entitiesMap","componentIsResizable","dragging","nextWidth","getComponentWidthFromDrop","meta","width","wrapInRow","shouldWrapChildInRow","parentType","destination","childType","destinationEntity","destinationChildren","newRow","newComponentFactory","rootComponent","topLevelId","topLevelComponent","source","draggingTabs","draggingTabId","draggingTab","childrenToMove","id","newEntitiesArray","Object","tabComponent","tabsComponent","topLevelTabs","nextState","updateComponentParentsList","currentComponent","text","layoutReducer","handler"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  DASHBOARD_ROOT_ID,\n  DASHBOARD_GRID_ID,\n  NEW_COMPONENTS_SOURCE_ID,\n  DASHBOARD_HEADER_ID,\n} from '../util/constants';\nimport componentIsResizable from '../util/componentIsResizable';\nimport findParentId from '../util/findParentId';\nimport getComponentWidthFromDrop from '../util/getComponentWidthFromDrop';\nimport updateComponentParentsList from '../util/updateComponentParentsList';\nimport newComponentFactory from '../util/newComponentFactory';\nimport newEntitiesFromDrop from '../util/newEntitiesFromDrop';\nimport reorderItem from '../util/dnd-reorder';\nimport shouldWrapChildInRow from '../util/shouldWrapChildInRow';\nimport { ROW_TYPE, TAB_TYPE, TABS_TYPE } from '../util/componentTypes';\n\nimport {\n  UPDATE_COMPONENTS,\n  UPDATE_COMPONENTS_PARENTS_LIST,\n  DELETE_COMPONENT,\n  CREATE_COMPONENT,\n  MOVE_COMPONENT,\n  CREATE_TOP_LEVEL_TABS,\n  DELETE_TOP_LEVEL_TABS,\n  DASHBOARD_TITLE_CHANGED,\n} from '../actions/dashboardLayout';\n\nimport { HYDRATE_DASHBOARD } from '../actions/hydrate';\n\nconst actionHandlers = {\n  [HYDRATE_DASHBOARD](state, action) {\n    return {\n      ...action.data.dashboardLayout.present,\n    };\n  },\n\n  [UPDATE_COMPONENTS](state, action) {\n    const {\n      payload: { nextComponents },\n    } = action;\n    return {\n      ...state,\n      ...nextComponents,\n    };\n  },\n\n  [DELETE_COMPONENT](state, action) {\n    const {\n      payload: { id, parentId },\n    } = action;\n\n    if (!parentId || !id || !state[id] || !state[parentId]) return state;\n\n    const nextComponents = { ...state };\n\n    function recursivelyDeleteChildren(componentId, componentParentId) {\n      // delete child and it's children\n      const component = nextComponents[componentId];\n      delete nextComponents[componentId];\n\n      const { children = [] } = component;\n      children.forEach(childId => {\n        recursivelyDeleteChildren(childId, componentId);\n      });\n\n      const parent = nextComponents[componentParentId];\n      if (parent) {\n        // may have been deleted in another recursion\n        const componentIndex = (parent.children || []).indexOf(componentId);\n        if (componentIndex > -1) {\n          const nextChildren = [...parent.children];\n          nextChildren.splice(componentIndex, 1);\n          nextComponents[componentParentId] = {\n            ...parent,\n            children: nextChildren,\n          };\n        }\n      }\n    }\n\n    recursivelyDeleteChildren(id, parentId);\n    const nextParent = nextComponents[parentId];\n    if (nextParent.type === ROW_TYPE && nextParent.children.length === 0) {\n      const grandparentId = findParentId({\n        childId: parentId,\n        layout: nextComponents,\n      });\n      recursivelyDeleteChildren(parentId, grandparentId);\n    }\n\n    return nextComponents;\n  },\n\n  [CREATE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n\n    return {\n      ...state,\n      ...newEntities,\n    };\n  },\n\n  [MOVE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n    const { source, destination, dragging } = dropResult;\n\n    if (!source || !destination || !dragging) return state;\n\n    const nextEntities = reorderItem({\n      entitiesMap: state,\n      source,\n      destination,\n    });\n\n    if (componentIsResizable(nextEntities[dragging.id])) {\n      // update component width if it changed\n      const nextWidth =\n        getComponentWidthFromDrop({\n          dropResult,\n          layout: state,\n        }) || undefined; // don't set a 0 width\n      if ((nextEntities[dragging.id].meta || {}).width !== nextWidth) {\n        nextEntities[dragging.id] = {\n          ...nextEntities[dragging.id],\n          meta: {\n            ...nextEntities[dragging.id].meta,\n            width: nextWidth,\n          },\n        };\n      }\n    }\n\n    // wrap the dragged component in a row depending on destination type\n    const wrapInRow = shouldWrapChildInRow({\n      parentType: destination.type,\n      childType: dragging.type,\n    });\n\n    if (wrapInRow) {\n      const destinationEntity = nextEntities[destination.id];\n      const destinationChildren = destinationEntity.children;\n      const newRow = newComponentFactory(ROW_TYPE);\n      newRow.children = [destinationChildren[destination.index]];\n      newRow.parents = (destinationEntity.parents || []).concat(destination.id);\n      destinationChildren[destination.index] = newRow.id;\n      nextEntities[newRow.id] = newRow;\n    }\n\n    return {\n      ...state,\n      ...nextEntities,\n    };\n  },\n\n  [CREATE_TOP_LEVEL_TABS](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n    const { source, dragging } = dropResult;\n\n    // move children of current root to be children of the dragging tab\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelComponent = state[topLevelId];\n\n    if (source.id !== NEW_COMPONENTS_SOURCE_ID) {\n      // component already exists\n      const draggingTabs = state[dragging.id];\n      const draggingTabId = draggingTabs.children[0];\n      const draggingTab = state[draggingTabId];\n\n      // move all children except the one that is dragging\n      const childrenToMove = [...topLevelComponent.children].filter(\n        id => id !== dragging.id,\n      );\n\n      return {\n        ...state,\n        [DASHBOARD_ROOT_ID]: {\n          ...rootComponent,\n          children: [dragging.id],\n        },\n        [topLevelId]: {\n          ...topLevelComponent,\n          children: [],\n        },\n        [draggingTabId]: {\n          ...draggingTab,\n          children: [...draggingTab.children, ...childrenToMove],\n        },\n      };\n    }\n\n    // create new component\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n    const newEntitiesArray = Object.values(newEntities);\n    const tabComponent = newEntitiesArray.find(\n      component => component.type === TAB_TYPE,\n    );\n    const tabsComponent = newEntitiesArray.find(\n      component => component.type === TABS_TYPE,\n    );\n\n    tabComponent.children = [...topLevelComponent.children];\n    newEntities[topLevelId] = { ...topLevelComponent, children: [] };\n    newEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [tabsComponent.id],\n    };\n\n    return {\n      ...state,\n      ...newEntities,\n    };\n  },\n\n  [DELETE_TOP_LEVEL_TABS](state) {\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelTabs = state[topLevelId];\n\n    if (topLevelTabs.type !== TABS_TYPE) return state;\n\n    let childrenToMove = [];\n    const nextEntities = { ...state };\n\n    topLevelTabs.children.forEach(tabId => {\n      const tabComponent = state[tabId];\n      childrenToMove = [...childrenToMove, ...tabComponent.children];\n      delete nextEntities[tabId];\n    });\n\n    delete nextEntities[topLevelId];\n\n    nextEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [DASHBOARD_GRID_ID],\n    };\n\n    nextEntities[DASHBOARD_GRID_ID] = {\n      ...state[DASHBOARD_GRID_ID],\n      children: childrenToMove,\n    };\n\n    return nextEntities;\n  },\n\n  [UPDATE_COMPONENTS_PARENTS_LIST](state) {\n    const nextState = {\n      ...state,\n    };\n\n    updateComponentParentsList({\n      currentComponent: nextState[DASHBOARD_ROOT_ID],\n      layout: nextState,\n    });\n\n    return {\n      ...nextState,\n    };\n  },\n\n  [DASHBOARD_TITLE_CHANGED](state, action) {\n    return {\n      ...state,\n      [DASHBOARD_HEADER_ID]: {\n        ...state[DASHBOARD_HEADER_ID],\n        meta: {\n          ...state[DASHBOARD_HEADER_ID].meta,\n          text: action.text,\n        },\n      },\n    };\n  },\n};\n\nexport default function layoutReducer(state = {}, action) {\n  if (action.type in actionHandlers) {\n    const handler = actionHandlers[action.type];\n    return handler(state, action);\n  }\n\n  return state;\n}\n"]},"metadata":{},"sourceType":"module"}