{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}\n\n/* eslint no-console: 0 */\nimport { globalBox } from 'global-box';\nimport OverwritePolicy from './OverwritePolicy';\nimport createRegistryState from './createRegistryState';\n/**\n * Registry class\n *\n * Can use generic to specify type of item in the registry\n * @type V Type of value\n * @type L Type of value returned from loader function when using `registerLoader()`.\n * `L` can be either `V`, `Promise<V>` or `V | Promise<V>`\n * Set `L=V` when does not support asynchronous loader.\n * By default `L` is set to `V | Promise<V>` to support\n * both synchronous and asynchronous loaders.\n */\n\nexport default class Registry {\n  constructor(config = {}) {\n    _defineProperty(this, \"state\", void 0);\n\n    if (typeof config.globalId === 'undefined') {\n      this.state = createRegistryState(config);\n    } else {\n      this.state = globalBox().getOrCreate(config.globalId, () => createRegistryState(config));\n    }\n  }\n  /**\n   * Clear all item in the registry.\n   * Reset default key to initial default key (if any)\n   */\n\n\n  clear() {\n    this.state.items = {};\n    this.state.promises = {};\n    this.state.defaultKey = this.state.initialDefaultKey;\n    return this;\n  }\n  /**\n   * Check if item with the given key exists\n   * @param key the key to look for\n   */\n\n\n  has(key) {\n    const item = this.state.items[key];\n    return item !== null && item !== undefined;\n  }\n  /**\n   * Register key with a value\n   * @param key\n   * @param value\n   */\n\n\n  registerValue(key, value) {\n    const item = this.state.items[key];\n    const willOverwrite = this.has(key) && ('value' in item && item.value !== value || 'loader' in item);\n\n    if (willOverwrite) {\n      if (this.state.overwritePolicy === OverwritePolicy.WARN) {\n        console.warn(\"Item with key \\\"\" + key + \"\\\" already exists. You are assigning a new value.\");\n      } else if (this.state.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(\"Item with key \\\"\" + key + \"\\\" already exists. Cannot overwrite.\");\n      }\n    }\n\n    if (!item || willOverwrite) {\n      this.state.items[key] = {\n        value };\n\n      delete this.state.promises[key];\n    } // If there is no default, set as default\n\n\n    if (this.state.setFirstItemAsDefault && !this.state.defaultKey) {\n      this.state.defaultKey = key;\n    }\n\n    return this;\n  }\n  /**\n   * Register key with a loader, a function that returns a value.\n   * @param key\n   * @param loader\n   */\n\n\n  registerLoader(key, loader) {\n    const item = this.state.items[key];\n    const willOverwrite = this.has(key) && ('loader' in item && item.loader !== loader || 'value' in item);\n\n    if (willOverwrite) {\n      if (this.state.overwritePolicy === OverwritePolicy.WARN) {\n        console.warn(\"Item with key \\\"\" + key + \"\\\" already exists. You are assigning a new value.\");\n      } else if (this.state.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(\"Item with key \\\"\" + key + \"\\\" already exists. Cannot overwrite.\");\n      }\n    }\n\n    if (!item || willOverwrite) {\n      this.state.items[key] = {\n        loader };\n\n      delete this.state.promises[key];\n    } // If there is no default, set as default\n\n\n    if (this.state.setFirstItemAsDefault && !this.state.defaultKey) {\n      this.state.defaultKey = key;\n    }\n\n    return this;\n  }\n  /**\n   * Get value from the specified key.\n   * If the item contains a loader, invoke the loader and return its output.\n   * @param key\n   */\n\n\n  get(key) {\n    const targetKey = key != null ? key : this.state.defaultKey;\n    if (typeof targetKey === 'undefined') return undefined;\n    const item = this.state.items[targetKey];\n\n    if (item !== undefined) {\n      if ('loader' in item) {\n        return item.loader && item.loader();\n      }\n\n      return item.value;\n    }\n\n    return undefined;\n  }\n  /**\n   * Similar to `.get()` but wrap results in a `Promise`.\n   * This is useful when some items are async loaders to provide uniform output.\n   * @param key\n   */\n\n\n  getAsPromise(key) {\n    const promise = this.state.promises[key];\n\n    if (typeof promise !== 'undefined') {\n      return promise;\n    }\n\n    const item = this.get(key);\n\n    if (item !== undefined) {\n      const newPromise = Promise.resolve(item);\n      this.state.promises[key] = newPromise;\n      return newPromise;\n    }\n\n    return Promise.reject(new Error(\"Item with key \\\"\" + key + \"\\\" is not registered.\"));\n  }\n  /**\n   * Return the current default key.\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   */\n\n\n  getDefaultKey() {\n    return this.state.defaultKey;\n  }\n  /**\n   * Set default key to the specified key\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   * @param key\n   */\n\n\n  setDefaultKey(key) {\n    this.state.defaultKey = key;\n    return this;\n  }\n  /**\n   * Remove default key.\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   */\n\n\n  clearDefaultKey() {\n    this.state.defaultKey = undefined;\n    return this;\n  }\n  /**\n   * Return a map of all key-values in this registry.\n   */\n\n\n  getMap() {\n    return this.keys().reduce((prev, key) => {\n      const map = prev;\n      map[key] = this.get(key);\n      return map;\n    }, {});\n  }\n  /**\n   * Same with `.getMap()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  getMapAsPromise() {\n    const keys = this.keys();\n    return Promise.all(keys.map((key) => this.getAsPromise(key))).then((values) => values.reduce((prev, value, i) => {\n      const map = prev;\n      map[keys[i]] = value;\n      return map;\n    }, {}));\n  }\n  /**\n   * Return all keys in this registry.\n   */\n\n\n  keys() {\n    return Object.keys(this.state.items);\n  }\n  /**\n   * Return all values in this registry.\n   * For loaders, they are invoked and their outputs are returned.\n   */\n\n\n  values() {\n    return this.keys().map((key) => this.get(key));\n  }\n  /**\n   * Same with `.values()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  valuesAsPromise() {\n    return Promise.all(this.keys().map((key) => this.getAsPromise(key)));\n  }\n  /**\n   * Return all key-value entries in this registry.\n   */\n\n\n  entries() {\n    return this.keys().map((key) => ({\n      key,\n      value: this.get(key) }));\n\n  }\n  /**\n   * Same with `.entries()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  entriesAsPromise() {\n    const keys = this.keys();\n    return Promise.all(keys.map((key) => this.getAsPromise(key))).then((values) => values.map((value, i) => ({\n      key: keys[i],\n      value })));\n\n  }\n  /**\n   * Remove the item with the specified key.\n   * Do nothing if an item with the given key does not exist.\n   * @param key\n   */\n\n\n  remove(key) {\n    delete this.state.items[key];\n    delete this.state.promises[key];\n    return this;\n  }\n  /**\n   * Get number of items in the registry\n   */\n\n\n  size() {\n    return this.keys().length;\n  }\n  /**\n   * Returns true if there is no item in the registry\n   */\n\n\n  isEmpty() {\n    return this.size() === 0;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_defineProperty, \"_defineProperty\", \"/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/registry/esm/models/Registry.js\");reactHotLoader.register(Registry, \"Registry\", \"/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/registry/esm/models/Registry.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/ubuntu/my_plugin/superset/superset-frontend/node_modules/@encodable/registry/esm/models/Registry.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","globalBox","OverwritePolicy","createRegistryState","Registry","constructor","config","globalId","state","getOrCreate","clear","items","promises","defaultKey","initialDefaultKey","has","item","undefined","registerValue","willOverwrite","overwritePolicy","WARN","console","warn","PROHIBIT","Error","setFirstItemAsDefault","registerLoader","loader","get","targetKey","getAsPromise","promise","newPromise","Promise","resolve","reject","getDefaultKey","setDefaultKey","clearDefaultKey","getMap","keys","reduce","prev","map","getMapAsPromise","all","then","values","i","valuesAsPromise","entries","entriesAsPromise","remove","size","length","isEmpty"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint no-console: 0 */\nimport { globalBox } from 'global-box';\nimport OverwritePolicy from './OverwritePolicy';\nimport createRegistryState from './createRegistryState';\n/**\n * Registry class\n *\n * Can use generic to specify type of item in the registry\n * @type V Type of value\n * @type L Type of value returned from loader function when using `registerLoader()`.\n * `L` can be either `V`, `Promise<V>` or `V | Promise<V>`\n * Set `L=V` when does not support asynchronous loader.\n * By default `L` is set to `V | Promise<V>` to support\n * both synchronous and asynchronous loaders.\n */\n\nexport default class Registry {\n  constructor(config = {}) {\n    _defineProperty(this, \"state\", void 0);\n\n    if (typeof config.globalId === 'undefined') {\n      this.state = createRegistryState(config);\n    } else {\n      this.state = globalBox().getOrCreate(config.globalId, () => createRegistryState(config));\n    }\n  }\n  /**\n   * Clear all item in the registry.\n   * Reset default key to initial default key (if any)\n   */\n\n\n  clear() {\n    this.state.items = {};\n    this.state.promises = {};\n    this.state.defaultKey = this.state.initialDefaultKey;\n    return this;\n  }\n  /**\n   * Check if item with the given key exists\n   * @param key the key to look for\n   */\n\n\n  has(key) {\n    const item = this.state.items[key];\n    return item !== null && item !== undefined;\n  }\n  /**\n   * Register key with a value\n   * @param key\n   * @param value\n   */\n\n\n  registerValue(key, value) {\n    const item = this.state.items[key];\n    const willOverwrite = this.has(key) && ('value' in item && item.value !== value || 'loader' in item);\n\n    if (willOverwrite) {\n      if (this.state.overwritePolicy === OverwritePolicy.WARN) {\n        console.warn(\"Item with key \\\"\" + key + \"\\\" already exists. You are assigning a new value.\");\n      } else if (this.state.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(\"Item with key \\\"\" + key + \"\\\" already exists. Cannot overwrite.\");\n      }\n    }\n\n    if (!item || willOverwrite) {\n      this.state.items[key] = {\n        value\n      };\n      delete this.state.promises[key];\n    } // If there is no default, set as default\n\n\n    if (this.state.setFirstItemAsDefault && !this.state.defaultKey) {\n      this.state.defaultKey = key;\n    }\n\n    return this;\n  }\n  /**\n   * Register key with a loader, a function that returns a value.\n   * @param key\n   * @param loader\n   */\n\n\n  registerLoader(key, loader) {\n    const item = this.state.items[key];\n    const willOverwrite = this.has(key) && ('loader' in item && item.loader !== loader || 'value' in item);\n\n    if (willOverwrite) {\n      if (this.state.overwritePolicy === OverwritePolicy.WARN) {\n        console.warn(\"Item with key \\\"\" + key + \"\\\" already exists. You are assigning a new value.\");\n      } else if (this.state.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(\"Item with key \\\"\" + key + \"\\\" already exists. Cannot overwrite.\");\n      }\n    }\n\n    if (!item || willOverwrite) {\n      this.state.items[key] = {\n        loader\n      };\n      delete this.state.promises[key];\n    } // If there is no default, set as default\n\n\n    if (this.state.setFirstItemAsDefault && !this.state.defaultKey) {\n      this.state.defaultKey = key;\n    }\n\n    return this;\n  }\n  /**\n   * Get value from the specified key.\n   * If the item contains a loader, invoke the loader and return its output.\n   * @param key\n   */\n\n\n  get(key) {\n    const targetKey = key != null ? key : this.state.defaultKey;\n    if (typeof targetKey === 'undefined') return undefined;\n    const item = this.state.items[targetKey];\n\n    if (item !== undefined) {\n      if ('loader' in item) {\n        return item.loader && item.loader();\n      }\n\n      return item.value;\n    }\n\n    return undefined;\n  }\n  /**\n   * Similar to `.get()` but wrap results in a `Promise`.\n   * This is useful when some items are async loaders to provide uniform output.\n   * @param key\n   */\n\n\n  getAsPromise(key) {\n    const promise = this.state.promises[key];\n\n    if (typeof promise !== 'undefined') {\n      return promise;\n    }\n\n    const item = this.get(key);\n\n    if (item !== undefined) {\n      const newPromise = Promise.resolve(item);\n      this.state.promises[key] = newPromise;\n      return newPromise;\n    }\n\n    return Promise.reject(new Error(\"Item with key \\\"\" + key + \"\\\" is not registered.\"));\n  }\n  /**\n   * Return the current default key.\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   */\n\n\n  getDefaultKey() {\n    return this.state.defaultKey;\n  }\n  /**\n   * Set default key to the specified key\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   * @param key\n   */\n\n\n  setDefaultKey(key) {\n    this.state.defaultKey = key;\n    return this;\n  }\n  /**\n   * Remove default key.\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   */\n\n\n  clearDefaultKey() {\n    this.state.defaultKey = undefined;\n    return this;\n  }\n  /**\n   * Return a map of all key-values in this registry.\n   */\n\n\n  getMap() {\n    return this.keys().reduce((prev, key) => {\n      const map = prev;\n      map[key] = this.get(key);\n      return map;\n    }, {});\n  }\n  /**\n   * Same with `.getMap()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  getMapAsPromise() {\n    const keys = this.keys();\n    return Promise.all(keys.map(key => this.getAsPromise(key))).then(values => values.reduce((prev, value, i) => {\n      const map = prev;\n      map[keys[i]] = value;\n      return map;\n    }, {}));\n  }\n  /**\n   * Return all keys in this registry.\n   */\n\n\n  keys() {\n    return Object.keys(this.state.items);\n  }\n  /**\n   * Return all values in this registry.\n   * For loaders, they are invoked and their outputs are returned.\n   */\n\n\n  values() {\n    return this.keys().map(key => this.get(key));\n  }\n  /**\n   * Same with `.values()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  valuesAsPromise() {\n    return Promise.all(this.keys().map(key => this.getAsPromise(key)));\n  }\n  /**\n   * Return all key-value entries in this registry.\n   */\n\n\n  entries() {\n    return this.keys().map(key => ({\n      key,\n      value: this.get(key)\n    }));\n  }\n  /**\n   * Same with `.entries()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  entriesAsPromise() {\n    const keys = this.keys();\n    return Promise.all(keys.map(key => this.getAsPromise(key))).then(values => values.map((value, i) => ({\n      key: keys[i],\n      value\n    })));\n  }\n  /**\n   * Remove the item with the specified key.\n   * Do nothing if an item with the given key does not exist.\n   * @param key\n   */\n\n\n  remove(key) {\n    delete this.state.items[key];\n    delete this.state.promises[key];\n    return this;\n  }\n  /**\n   * Get number of items in the registry\n   */\n\n\n  size() {\n    return this.keys().length;\n  }\n  /**\n   * Returns true if there is no item in the registry\n   */\n\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}